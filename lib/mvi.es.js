import { openBlock, createElementBlock, normalizeClass, normalizeStyle, h, resolveComponent, createBlock, withCtx, renderSlot, Fragment, createVNode, toDisplayString, createCommentVNode, createElementVNode, renderList, Teleport, Transition, withDirectives, mergeProps, withModifiers, vShow, getCurrentInstance, vModelText, vModelDynamic, createSlots, withKeys, createTextVNode, createApp, pushScopeId, popScopeId } from "vue";
const mviDefault = "";
const mviSupport = "";
const number$1 = {
  formatNumber(num) {
    if (this.isNumber(num)) {
      return num.toString().replace(/(\d)(?=(?:\d{3})+$)/g, "$1,");
    } else {
      return num;
    }
  },
  isNumber(num) {
    if (typeof num == "number" && !isNaN(num)) {
      return true;
    } else {
      return false;
    }
  },
  add(...values) {
    return values.reduce((num, value) => {
      let r1 = 0;
      let r2 = 0;
      let m = 0;
      try {
        r1 = num.toString().split(".")[1].length;
      } catch (e) {
      }
      try {
        r2 = value.toString().split(".")[1].length;
      } catch (e) {
      }
      m = Math.pow(10, Math.max(r1, r2));
      return (num * m + value * m) / m;
    });
  },
  subtract(...values) {
    return values.reduce((num, value) => {
      let r1 = 0;
      let r2 = 0;
      let m = 0;
      try {
        r1 = num.toString().split(".")[1].length;
      } catch (e) {
      }
      try {
        r2 = value.toString().split(".")[1].length;
      } catch (e) {
      }
      m = Math.pow(10, Math.max(r1, r2));
      return (num * m - value * m) / m;
    });
  },
  mutiply(...values) {
    return values.reduce((num, value) => {
      let m = 0;
      let s1 = num.toString();
      let s2 = value.toString();
      try {
        m += s1.split(".")[1].length;
      } catch (e) {
      }
      try {
        m += s2.split(".")[1].length;
      } catch (e) {
      }
      return Number(s1.replace(".", "")) * Number(s2.replace(".", "")) / Math.pow(10, m);
    });
  },
  divide(...values) {
    return values.reduce((num, value) => {
      let t1 = 0;
      let t2 = 0;
      let s1 = num.toString();
      let s2 = value.toString();
      try {
        t1 = s1.split(".")[1].length;
      } catch (e) {
      }
      try {
        t2 = s2.split(".")[1].length;
      } catch (e) {
      }
      s1 = Number(s1.replace(".", ""));
      s2 = Number(s2.replace(".", ""));
      return s1 / s2 * Math.pow(10, t2 - t1);
    });
  }
};
const string$1 = {
  insert(original, str, index) {
    if (!original || typeof original != "string") {
      throw new TypeError("The first argument must be a string");
    }
    if (typeof str != "string") {
      throw new TypeError("The second argument must be a string");
    }
    if (!number$1.isNumber(index)) {
      throw new TypeError("The third argument must be a number");
    }
    if (index < 0) {
      throw new Error("The third argument cannot be less than 0");
    }
    return original.substring(0, index) + str + original.substring(index, original.length);
  },
  delete(original, index, num) {
    if (!original || typeof original != "string") {
      throw new TypeError("The first argument must be a string");
    }
    if (!number$1.isNumber(index)) {
      throw new TypeError("The second argument must be a number");
    }
    if (index < 0) {
      throw new Error("The second argument cannot be less than 0");
    }
    if (!number$1.isNumber(num)) {
      throw new TypeError("The third argument must be a number");
    }
    if (num < 0) {
      throw new Error("The third argument cannot be less than 0");
    }
    return original.substring(0, index) + original.substring(index + num, original.length);
  },
  replace(original, start, end, str) {
    if (!original || typeof original != "string") {
      throw new TypeError("The first argument must be a string");
    }
    if (!number$1.isNumber(start)) {
      throw new TypeError("The second argument must be a number");
    }
    if (start < 0) {
      throw new Error("The second argument cannot be less than 0");
    }
    if (!number$1.isNumber(end)) {
      throw new TypeError("The third argument must be a number");
    }
    if (end < 0) {
      throw new Error("The third argument cannot be less than 0");
    }
    if (typeof str != "string") {
      throw new TypeError("The fourth argument must be a string");
    }
    return original.substring(0, start) + str + original.substring(end, original.length);
  },
  trim(str, global2) {
    if (typeof str != "string") {
      throw new TypeError("The first argument must be a string");
    }
    let result = str.replace(/(^\s+)|(\s+$)/g, "");
    if (global2) {
      result = result.replace(/\s/g, "");
    }
    return result;
  }
};
const element$1 = {
  isWindow(data2) {
    return data2 && data2 instanceof Window;
  },
  getElementPoint(el, root) {
    if (!this.isElement(el)) {
      throw new TypeError("The first argument must be an element");
    }
    if (!this.isElement(root)) {
      root = document.body;
    }
    if (!this.isContains(root, el)) {
      throw new Error("The second argument and the first argument have no hierarchical relationship");
    }
    let obj2 = el;
    let offsetTop = 0;
    let offsetLeft = 0;
    while (this.isElement(el) && this.isContains(root, el) && root !== el) {
      offsetTop += el.offsetTop;
      offsetLeft += el.offsetLeft;
      el = el.offsetParent;
    }
    let offsetRight = root.offsetWidth - offsetLeft - obj2.offsetWidth;
    let offsetBottom = root.offsetHeight - offsetTop - obj2.offsetHeight;
    return {
      top: offsetTop,
      left: offsetLeft,
      right: offsetRight,
      bottom: offsetBottom
    };
  },
  isContains(parentNode, childNode) {
    if (!this.isElement(parentNode)) {
      throw new TypeError("The first argument must be an element");
    }
    if (!this.isElement(childNode, true)) {
      throw new TypeError("The second argument must be an element");
    }
    if (parentNode === childNode) {
      return true;
    }
    if (parentNode.contains) {
      return parentNode.contains(childNode);
    }
    if (parentNode.compareDocumentPosition) {
      return !!(parentNode.compareDocumentPosition(childNode) & 16);
    }
  },
  isParentNode(parentNode, childNode) {
    if (!this.isElement(parentNode)) {
      throw new TypeError("The first argument must be an element");
    }
    if (!this.isElement(childNode, true)) {
      throw new TypeError("The second argument must be an element");
    }
    if (parentNode === childNode) {
      return false;
    }
    return childNode.parentNode === parentNode;
  },
  children(el, selector) {
    if (!this.isElement(el)) {
      throw new TypeError("The first argument must be an element");
    }
    if (selector && typeof selector != "string") {
      throw new TypeError("The second argument must be a string");
    }
    const res = el.querySelectorAll(selector || "*");
    return [...res].filter((ele) => {
      return ele.parentNode === el;
    });
  },
  siblings(el, selector) {
    if (!this.isElement(el)) {
      throw new TypeError("The first argument must be an element");
    }
    if (selector && typeof selector != "string") {
      throw new TypeError("The second argument must be a string");
    }
    if (!el.parentNode) {
      return [];
    }
    const res = el.parentNode.querySelectorAll(selector || "*");
    return [...res].filter((ele) => {
      return ele.parentNode === el.parentNode && ele != el;
    });
  },
  rem2px(num) {
    if (!number$1.isNumber(num)) {
      throw new TypeError("The argument must be a number");
    }
    let fs = this.getCssStyle(document.documentElement, "font-size");
    return number$1.mutiply(num, parseFloat(fs));
  },
  px2rem(num) {
    if (!number$1.isNumber(num)) {
      throw new TypeError("The argument must be a number");
    }
    let fs = this.getCssStyle(document.documentElement, "font-size");
    return number$1.divide(num, parseFloat(fs));
  },
  width(el) {
    if (typeof el == "string" && el) {
      el = document.body.querySelector(el);
    }
    if (!this.isElement(el)) {
      el = document.body;
    }
    let clientWidth = el.clientWidth;
    let paddingLeft_width = parseFloat(this.getCssStyle(el, "padding-left"));
    let paddingRight_width = parseFloat(this.getCssStyle(el, "padding-right"));
    return number$1.subtract(clientWidth, paddingLeft_width, paddingRight_width);
  },
  height(el) {
    if (typeof el == "string" && el) {
      el = document.body.querySelector(el);
    }
    if (!this.isElement(el)) {
      el = document.body;
    }
    let clientHeight = el.clientHeight;
    let paddingTop_height = parseFloat(this.getCssStyle(el, "padding-top"));
    let paddingBottom_height = parseFloat(this.getCssStyle(el, "padding-bottom"));
    return number$1.subtract(clientHeight, paddingTop_height, paddingBottom_height);
  },
  removeClass(el, className) {
    if (!this.isElement(el)) {
      throw new TypeError("The first argument must be an element");
    }
    if (!className || typeof className != "string") {
      throw new TypeError("The second argument must be a string");
    }
    let classList = el.classList;
    let classArray = string$1.trim(className).split(/\s+/);
    classArray.forEach((item, index) => {
      classList.remove(item);
    });
  },
  addClass(el, className) {
    if (!this.isElement(el)) {
      throw new TypeError("The first argument must be an element");
    }
    if (!className || typeof className != "string") {
      throw new TypeError("The second argument must be a string");
    }
    let classList = el.classList;
    let classArray = string$1.trim(className).split(/\s+/);
    classArray.forEach((item, index) => {
      classList.add(item);
    });
  },
  hasClass(el, className) {
    if (!this.isElement(el)) {
      throw new TypeError("The first argument must be an element");
    }
    if (!className || typeof className != "string") {
      throw new TypeError("The second argument must be a string");
    }
    let classList = el.classList;
    let classArray = string$1.trim(className).split(/\s+/);
    return classArray.every((item, index) => {
      return classList.contains(item);
    });
  },
  scrollTopBottomTrigger(el, callback) {
    if (typeof el == "string" && el) {
      el = document.body.querySelector(el);
    }
    let scrollEle = window;
    if (this.isElement(el) && el != document.body && el != document.documentElement) {
      scrollEle = el;
    }
    if (typeof el == "function") {
      callback = el;
    }
    let flag = true;
    scrollEle.addEventListener("scroll", (e) => {
      if (this.getScrollTop(scrollEle) <= 0) {
        let options = {
          state: "top",
          target: scrollEle
        };
        if (!flag) {
          return;
        }
        if (typeof callback == "function") {
          flag = false;
          callback(options);
        }
      } else {
        let options = {
          state: "bottom",
          target: scrollEle
        };
        let height = 0;
        if (scrollEle == window) {
          height = window.innerHeight;
        } else {
          height = scrollEle.clientHeight;
        }
        if (number$1.add(this.getScrollTop(scrollEle), height) + 1 >= this.getScrollHeight(scrollEle) && height != this.getScrollHeight(scrollEle)) {
          if (!flag) {
            return;
          }
          if (typeof callback == "function") {
            flag = false;
            callback(options);
          }
        } else {
          flag = true;
        }
      }
    });
  },
  getScrollWidth(el) {
    if (typeof el == "string" && el) {
      el = document.body.querySelector(el);
    }
    let scrollWidth = 0;
    if (this.isElement(el) && el != document.documentElement && el != document.body) {
      scrollWidth = el.scrollWidth;
    } else {
      if (document.documentElement.scrollWidth == 0 || document.body.scrollWidth == 0) {
        scrollWidth = document.documentElement.scrollWidth || document.body.scrollWidth;
      } else {
        scrollWidth = document.documentElement.scrollWidth > document.body.scrollWidth ? document.documentElement.scrollWidth : document.body.scrollWidth;
      }
    }
    return scrollWidth;
  },
  getScrollHeight(el) {
    if (typeof el == "string" && el) {
      el = document.body.querySelector(el);
    }
    let scrollHeight = 0;
    if (this.isElement(el) && el != document.documentElement && el != document.body) {
      scrollHeight = el.scrollHeight;
    } else {
      if (document.documentElement.scrollHeight == 0 || document.body.scrollHeight == 0) {
        scrollHeight = document.documentElement.scrollHeight || document.body.scrollHeight;
      } else {
        scrollHeight = document.documentElement.scrollHeight > document.body.scrollHeight ? document.documentElement.scrollHeight : document.body.scrollHeight;
      }
    }
    return scrollHeight;
  },
  setScrollTop(options) {
    let isWindow = false;
    let el = options.el;
    if (typeof el == "string" && el) {
      el = document.body.querySelector(el);
    }
    let number$1$1 = options.number || 0;
    let time = options.time || 0;
    if (!this.isElement(el) || el == document.body || el == document.documentElement || el == window) {
      isWindow = true;
    }
    return new Promise((resolve, reject) => {
      if (time <= 0) {
        if (isWindow) {
          document.documentElement.scrollTop = document.body.scrollTop = number$1$1;
        } else {
          el.scrollTop = number$1$1;
        }
        resolve();
      } else {
        let spacingTime = 10;
        let spacingIndex = number$1.divide(time, spacingTime);
        let nowTop = this.getScrollTop(el);
        let everTop = number$1.divide(number$1.subtract(number$1$1, nowTop), spacingIndex);
        let scrollTimer = setInterval(() => {
          if (spacingIndex > 0) {
            spacingIndex--;
            if (isWindow) {
              document.documentElement.scrollTop = document.body.scrollTop = nowTop = number$1.add(nowTop, everTop);
            } else {
              el.scrollTop = nowTop = number$1.add(nowTop, everTop);
            }
          } else {
            clearInterval(scrollTimer);
            resolve();
          }
        }, spacingTime);
      }
    });
  },
  getScrollTop(el) {
    if (typeof el == "string" && el) {
      el = document.body.querySelector(el);
    }
    let scrollTop = 0;
    if (this.isElement(el) && el != document.body && el != document.documentElement && el != window) {
      scrollTop = el.scrollTop;
    } else {
      if (document.documentElement.scrollTop == 0 || document.body.scrollTop == 0) {
        scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
      } else {
        scrollTop = document.documentElement.scrollTop > document.body.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop;
      }
    }
    return scrollTop;
  },
  getScrollLeft(el) {
    if (typeof el == "string" && el) {
      el = document.body.querySelector(el);
    }
    let scrollLeft = 0;
    if (this.isElement(el) && el != document.body && el != document.documentElement && el != window) {
      scrollLeft = el.scrollLeft;
    } else {
      if (document.documentElement.scrollLeft == 0 || document.body.scrollLeft == 0) {
        scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;
      } else {
        scrollLeft = document.documentElement.scrollLeft > document.body.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft;
      }
    }
    return scrollLeft;
  },
  setScrollLeft(options) {
    let isWindow = false;
    let el = options.el;
    if (typeof el == "string" && el) {
      el = document.body.querySelector(el);
    }
    let number$1$1 = options.number || 0;
    let time = options.time || 0;
    if (!this.isElement(el) || el == document.body || el == document.documentElement || el == window) {
      isWindow = true;
    }
    return new Promise((resolve, reject) => {
      if (time <= 0) {
        if (isWindow) {
          document.documentElement.scrollLeft = document.body.scrollLeft = number$1$1;
        } else {
          el.scrollLeft = number$1$1;
        }
        resolve();
      } else {
        let spacingTime = 10;
        let spacingIndex = number$1.divide(time, spacingTime);
        let nowLeft = this.getScrollLeft(el);
        let everLeft = number$1.divide(number$1.subtract(number$1$1, nowLeft), spacingIndex);
        let scrollTimer = setInterval(() => {
          if (spacingIndex > 0) {
            spacingIndex--;
            if (isWindow) {
              document.documentElement.scrollLeft = document.body.scrollLeft = nowLeft = number$1.add(nowLeft, everLeft);
            } else {
              el.scrollLeft = nowLeft = number$1.add(nowLeft, everLeft);
            }
          } else {
            clearInterval(scrollTimer);
            resolve();
          }
        }, spacingTime);
      }
    });
  },
  getCssStyle(el, cssName) {
    if (!this.isElement(el)) {
      throw new TypeError("The first argument must be an element");
    }
    if (!cssName || typeof cssName != "string") {
      throw new TypeError("The second argument must be a string");
    }
    let cssText = "";
    if (document.defaultView && document.defaultView.getComputedStyle) {
      cssText = document.defaultView.getComputedStyle(el)[cssName];
    } else {
      cssText = el.currentStyle[cssName];
    }
    return cssText;
  },
  getCssSelector(selector) {
    if (!selector || typeof selector != "string") {
      throw new TypeError("The argument must be a selector string");
    }
    if (/^#{1}/.test(selector)) {
      return {
        type: "id",
        value: selector.substr(1)
      };
    }
    if (/^\./.test(selector)) {
      return {
        type: "class",
        value: selector.substr(1)
      };
    }
    if (/^\[(.+)\]$/.test(selector)) {
      let type = "attribute";
      let value = "";
      let attribute = string$1.trim(selector, true).substring(1, string$1.trim(selector, true).length - 1);
      let arry = attribute.split("=");
      if (arry.length == 1) {
        value = arry[0];
      }
      if (arry.length == 2) {
        value = {
          attributeName: arry[0],
          attributeValue: arry[1].replace(/\'/g, "").replace(/\"/g, "")
        };
      }
      return {
        type,
        value
      };
    }
    return {
      type: "tag",
      value: selector
    };
  },
  getElementBounding(el) {
    if (typeof el == "string" && el) {
      el = document.body.querySelector(el);
    }
    if (!this.isElement(el)) {
      el = document.body;
    }
    let point = el.getBoundingClientRect();
    let top = point.top;
    let bottom = number$1.subtract(document.documentElement.clientHeight || window.innerHeight, point.bottom);
    let left = point.left;
    let right = number$1.subtract(document.documentElement.clientWidth || window.innerWidth, point.right);
    return {
      top,
      bottom,
      left,
      right
    };
  },
  isElement(el) {
    return el && el instanceof Node && el.nodeType === 1;
  },
  string2dom(str, parentTag = "div") {
    if (!str || typeof str != "string") {
      throw new TypeError("The argument must be an HTML string");
    }
    let parentEle = document.createElement(parentTag);
    parentEle.innerHTML = str;
    if (parentEle.children.length == 1) {
      return parentEle.children[0];
    } else {
      return parentEle.children;
    }
  }
};
const dataName$1 = "_dap-datas";
const data$1 = {
  remove(el, key) {
    if (!(el instanceof Document) && !element$1.isElement(el) && !element$1.isWindow(el)) {
      throw new TypeError("The first argument must be an element node or window or document");
    }
    let data2 = el[dataName$1] || {};
    if (key === void 0 || key === null || key === "") {
      el[dataName$1] = {};
    } else {
      delete data2[key];
      el[dataName$1] = data2;
    }
  },
  has(el, key) {
    if (!(el instanceof Document) && !element$1.isElement(el) && !element$1.isWindow(el)) {
      throw new TypeError("The first argument must be an element node or window or document");
    }
    if (key === void 0 || key === null || key === "") {
      throw new TypeError("The second parameter must be a unique key");
    }
    let data2 = el[dataName$1] || {};
    return data2.hasOwnProperty(key);
  },
  get(el, key) {
    if (!(el instanceof Document) && !element$1.isElement(el) && !element$1.isWindow(el)) {
      throw new TypeError("The first argument must be an element node or window or document");
    }
    let data2 = el[dataName$1] || {};
    if (key === void 0 || key === null || key === "") {
      return data2;
    } else {
      return data2[key];
    }
  },
  set(el, key, value) {
    if (!(el instanceof Document) && !element$1.isElement(el) && !element$1.isWindow(el)) {
      throw new TypeError("The first argument must be an element node or window or document");
    }
    if (key === void 0 || key === null || key === "") {
      throw new TypeError("The second parameter must be a unique key");
    }
    let data2 = el[dataName$1] || {};
    data2[key] = value;
    el[dataName$1] = data2;
  }
};
const common$1 = {
  matchingText(text, params) {
    if (!text || typeof text != "string") {
      throw new TypeError("The first argument must be a string");
    }
    if (!params || typeof params != "string") {
      throw new TypeError("The second argument must be a string");
    }
    let reg = null;
    if (params == "Chinese") {
      reg = /^[\u4e00-\u9fa5]+$/;
    }
    if (params == "chinese") {
      reg = /[\u4e00-\u9fa5]/;
    }
    if (params == "email") {
      reg = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/;
    }
    if (params == "userName") {
      reg = /^[a-zA-Z0-9_]{4,16}$/;
    }
    if (params == "int+") {
      reg = /^\d+$/;
    }
    if (params == "int-") {
      reg = /^-\d+$/;
    }
    if (params == "int") {
      reg = /^-?\d+$/;
    }
    if (params == "pos") {
      reg = /^\d*\.?\d+$/;
    }
    if (params == "neg") {
      reg = /^-\d*\.?\d+$/;
    }
    if (params == "number") {
      reg = /^-?\d*\.?\d+$/;
    }
    if (params == "phone") {
      reg = /^1[0-9]\d{9}$/;
    }
    if (params == "idCard") {
      reg = /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;
    }
    if (params == "url") {
      reg = /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;
    }
    if (params == "IPv4") {
      reg = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
    }
    if (params == "hex") {
      reg = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;
    }
    if (params == "QQ") {
      reg = /^[1-9][0-9]{4,10}$/;
    }
    if (params == "weixin") {
      reg = /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/;
    }
    if (params == "plate") {
      reg = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/;
    }
    if (!reg) {
      throw new Error("The second parameter is out of scope");
    }
    return reg.test(text);
  },
  getUrlParams(name) {
    if (!name || typeof name != "string") {
      throw new TypeError("The argument must be a string");
    }
    let reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)");
    let search = window.location.search.substr(1);
    if (!search) {
      let arr = window.location.hash.split("?");
      if (arr.length == 2) {
        search = arr[1];
      }
    }
    let r = search.match(reg);
    if (r) {
      return decodeURIComponent(r[2]);
    }
    return null;
  },
  isEmptyObject(obj2) {
    if (this.isObject(obj2)) {
      if (Object.keys(obj2).length == 0) {
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  },
  equal(a, b) {
    if (typeof a !== typeof b) {
      return false;
    }
    if (this.isObject(a) && this.isObject(b)) {
      a = Object.assign({}, a);
      b = Object.assign({}, b);
      let aProps = Object.getOwnPropertyNames(a);
      let bProps = Object.getOwnPropertyNames(b);
      if (aProps.length != bProps.length) {
        return false;
      }
      let length = aProps.length;
      for (let i = 0; i < length; i++) {
        let propName = aProps[i];
        let propA = a[propName];
        let propB = b[propName];
        if (this.isObject(propA)) {
          if (this.equal(propA, propB)) {
            return true;
          } else {
            return false;
          }
        } else if (propA !== propB) {
          return false;
        }
      }
      return true;
    } else {
      return a === b;
    }
  },
  isObject(val) {
    if (typeof val === "object" && val) {
      return true;
    }
    return false;
  },
  copyText(text) {
    if (!text || typeof text != "string") {
      throw new TypeError("No text to copy is defined");
    }
    if (!navigator.clipboard) {
      throw new Error("navigator.clipboard must be obtained in a secure environment, such as localhost, 127.0.0.1, or https, so the editor's copy, paste, and cut functions cannot be used");
    }
    return navigator.clipboard.writeText(text);
  }
};
const parseEventName$1 = (eventName) => {
  let eventNames = eventName.split(/[\s]+/g);
  let result = [];
  eventNames.forEach((name) => {
    let arr = name.split(".");
    let obj2 = {
      eventName: arr[0]
    };
    if (arr.length > 1) {
      obj2.guid = arr[1];
    }
    result.push(obj2);
  });
  return result;
};
const updateEvents$1 = (events) => {
  let obj2 = {};
  let keys = Object.keys(events);
  keys.forEach((key) => {
    if (events[key]) {
      obj2[key] = events[key];
    }
  });
  return obj2;
};
const bindSingleListener$1 = (el, eventName, guid, fn, options) => {
  let events = data$1.get(el, "dap-defined-events") || {};
  if (!guid) {
    guid = data$1.get(el, "dap-event-guid") || 0;
    data$1.set(el, "dap-event-guid", guid + 1);
  }
  guid = eventName + "." + guid;
  if (events[guid] && events[guid].type == eventName) {
    el.removeEventListener(eventName, events[guid].fn, events[guid].options);
  }
  el.addEventListener(eventName, fn, options);
  events[guid] = {
    type: eventName,
    fn,
    options
  };
  data$1.set(el, "dap-defined-events", events);
};
const unbindSingleListener$1 = (el, eventName, guid) => {
  let events = data$1.get(el, "dap-defined-events") || {};
  let keys = Object.keys(events);
  let length = keys.length;
  for (let i = 0; i < length; i++) {
    let key = keys[i];
    if (events[key].type == eventName) {
      if (guid) {
        if (key == eventName + "." + guid) {
          el.removeEventListener(events[key].type, events[key].fn, events[key].options);
          events[key] = void 0;
        }
      } else {
        el.removeEventListener(events[key].type, events[key].fn, events[key].options);
        events[key] = void 0;
      }
    }
  }
  events = updateEvents$1(events);
  data$1.set(el, "dap-defined-events", events);
};
const event$1 = {
  on(el, eventName, fn, options) {
    if (!(el instanceof Document) && !element$1.isElement(el) && !element$1.isWindow(el)) {
      throw new TypeError("The first argument must be an element node or window or document");
    }
    if (!eventName || typeof eventName != "string") {
      throw new TypeError("The second argument must be a string");
    }
    if (!fn || typeof fn != "function") {
      throw new TypeError("The third argument must be a function");
    }
    if (!common$1.isObject(options)) {
      options = {};
    }
    const result = parseEventName$1(eventName);
    result.forEach((res) => {
      bindSingleListener$1(el, res.eventName, res.guid, fn.bind(el), options);
    });
  },
  off(el, eventName) {
    if (!(el instanceof Document) && !element$1.isElement(el) && !element$1.isWindow(el)) {
      throw new TypeError("The first argument must be an element node or window or document");
    }
    let events = data$1.get(el, "dap-defined-events");
    if (!events) {
      return;
    }
    if (!eventName) {
      let keys = Object.keys(events);
      let length = keys.length;
      for (let i = 0; i < length; i++) {
        let key = keys[i];
        el.removeEventListener(events[key].type, events[key].fn, events[key].options);
      }
      data$1.remove(el, "dap-defined-events");
      data$1.remove(el, "dap-event-guid");
      return;
    }
    const result = parseEventName$1(eventName);
    result.forEach((res) => {
      unbindSingleListener$1(el, res.eventName, res.guid);
    });
  },
  get(el) {
    if (!(el instanceof Document) && !element$1.isElement(el) && !element$1.isWindow(el)) {
      throw new TypeError("The first argument must be an element node or window or document");
    }
    let events = data$1.get(el, "dap-defined-events");
    if (!events) {
      return;
    }
    return events;
  }
};
const color$1 = {
  rgb2hsv(rgb) {
    if (!Array.isArray(rgb) || rgb.length != 3) {
      throw new TypeError("Invalid argument");
    }
    let h2 = 0;
    let s = 0;
    let v = 0;
    let r = rgb[0] >= 255 ? 255 : rgb[0];
    let g = rgb[1] >= 255 ? 255 : rgb[1];
    let b = rgb[2] >= 255 ? 255 : rgb[2];
    r = r <= 0 ? 0 : r;
    g = g <= 0 ? 0 : g;
    b = b <= 0 ? 0 : b;
    let max = Math.max(r, g, b);
    let min = Math.min(r, g, b);
    v = max / 255;
    if (max === 0) {
      s = 0;
    } else {
      s = 1 - min / max;
    }
    if (max === min) {
      h2 = 0;
    } else if (max === r && g >= b) {
      h2 = 60 * ((g - b) / (max - min)) + 0;
    } else if (max === r && g < b) {
      h2 = 60 * ((g - b) / (max - min)) + 360;
    } else if (max === g) {
      h2 = 60 * ((b - r) / (max - min)) + 120;
    } else if (max === b) {
      h2 = 60 * ((r - g) / (max - min)) + 240;
    }
    return [h2, s * 100, v * 100];
  },
  hsv2rgb(hsv) {
    if (!Array.isArray(hsv) || hsv.length != 3) {
      throw new TypeError("Invalid argument");
    }
    let h2 = hsv[0] >= 360 || hsv[0] <= 0 ? 0 : hsv[0];
    let s = hsv[1] >= 100 ? 100 : hsv[1];
    s = s <= 0 ? 0 : s;
    let v = hsv[2] >= 100 ? 100 : hsv[2];
    v = v <= 0 ? 0 : v;
    s = s / 100;
    v = v / 100;
    let r = 0;
    let g = 0;
    let b = 0;
    let i = parseInt(h2 / 60 % 6);
    let f = h2 / 60 - i;
    let p = v * (1 - s);
    let q = v * (1 - f * s);
    let t = v * (1 - (1 - f) * s);
    switch (i) {
      case 0:
        r = v;
        g = t;
        b = p;
        break;
      case 1:
        r = q;
        g = v;
        b = p;
        break;
      case 2:
        r = p;
        g = v;
        b = t;
        break;
      case 3:
        r = p;
        g = q;
        b = v;
        break;
      case 4:
        r = t;
        g = p;
        b = v;
        break;
      case 5:
        r = v;
        g = p;
        b = q;
        break;
    }
    r = parseInt(r * 255);
    g = parseInt(g * 255);
    b = parseInt(b * 255);
    return [r, g, b];
  },
  rgb2hex(rgb) {
    if (!Array.isArray(rgb) || rgb.length != 3) {
      throw new TypeError("Invalid argument");
    }
    let r = rgb[0];
    let g = rgb[1];
    let b = rgb[2];
    let hex = "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    return hex;
  },
  hex2rgb(hex) {
    if (!hex || typeof hex != "string") {
      throw new TypeError("The argument must be a string");
    }
    let color2 = hex.toLowerCase();
    if (!common$1.matchingText(color2, "hex")) {
      throw new TypeError("The argument must be a hexadecimal color value");
    }
    if (color2.length === 4) {
      let colorNew = "#";
      for (let i = 1; i < 4; i += 1) {
        colorNew += color2.slice(i, i + 1).concat(color2.slice(i, i + 1));
      }
      color2 = colorNew;
    }
    let colorChange = [];
    for (let i = 1; i < 7; i += 2) {
      colorChange.push(parseInt("0x" + color2.slice(i, i + 2)));
    }
    return colorChange;
  }
};
const file$1 = {
  getImageUrl(file2) {
    if (!file2 || !(file2 instanceof File)) {
      throw new TypeError("The argument must be a File object");
    }
    return window.URL.createObjectURL(file2);
  },
  dataFileToBase64(file2) {
    return new Promise((resolve, reject) => {
      if (!file2 || !(file2 instanceof File)) {
        reject(new TypeError("The argument must be a File object"));
      }
      let reader = new FileReader();
      reader.readAsDataURL(file2);
      reader.onloadend = () => {
        let dataURL = reader.result;
        resolve(dataURL);
      };
    });
  },
  dataBase64toFile(base64String, fileName) {
    if (!base64String || typeof base64String != "string") {
      throw new TypeError("The first argument must be a string");
    }
    if (!fileName || typeof fileName != "string") {
      throw new TypeError("The second argument must be a string");
    }
    let arr = base64String.split(",");
    let mime = arr[0].match(/:(.*?);/)[1];
    let bstr = atob(arr[1]);
    let n = bstr.length;
    let u8arr = new Uint8Array(n);
    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }
    return new File([u8arr], fileName, {
      type: mime
    });
  }
};
const platform$1 = {
  language() {
    return window.navigator.browserLanguage || window.navigator.language;
  },
  device() {
    const userAgent = window.navigator.userAgent;
    return {
      PC: !userAgent.match(/AppleWebKit.*Mobile.*/),
      Mobile: !!userAgent.match(/AppleWebKit.*Mobile.*/),
      iPhone: userAgent.includes("iPhone"),
      Phone: userAgent.includes("Android") && /(?:Mobile)/.test(userAgent) || userAgent.includes("iPhone") || /(?:Windows Phone)/.test(userAgent),
      iPad: userAgent.includes("iPad"),
      Tablet: userAgent.includes("iPad") || userAgent.includes("Android") && !/(?:Mobile)/.test(userAgent) || userAgent.includes("Firefox") && /(?:Tablet)/.test(userAgent),
      WindowsPhone: /(?:Windows Phone)/.test(userAgent)
    };
  },
  browser() {
    const userAgent = window.navigator.userAgent;
    return {
      Edge: !!userAgent.match(/Edg\/([\d.]+)/),
      weixin: userAgent.includes("MicroMessenger"),
      QQ: userAgent.includes("QQ"),
      QQBrowser: userAgent.includes("MQQBrowser"),
      UC: userAgent.includes("UCBrowser"),
      Chrome: userAgent.includes("Chrome"),
      Firefox: userAgent.includes("Firefox"),
      sougou: userAgent.toLocaleLowerCase().includes("se 2.x") || userAgent.toLocaleLowerCase().includes("metasr") || userAgent.toLocaleLowerCase().includes("sogou"),
      Safari: userAgent.includes("Safari") && !userAgent.includes("Chrome")
    };
  },
  browserKernel() {
    const userAgent = window.navigator.userAgent;
    if (userAgent.includes("Presto")) {
      return "opera";
    } else if (userAgent.includes("AppleWebKit")) {
      return "webkit";
    } else if (userAgent.includes("Gecko") && !userAgent.includes("KHTML")) {
      return "gecko";
    }
    return "";
  },
  os() {
    const userAgent = window.navigator.userAgent;
    return {
      Windows: userAgent.includes("Windows"),
      Windows_CPU: function() {
        if (userAgent.toLocaleLowerCase().includes("win64") || userAgent.toLocaleLowerCase().includes("wow64")) {
          return "x64";
        } else if (userAgent.toLocaleLowerCase().includes("win32") || userAgent.toLocaleLowerCase().includes("wow32")) {
          return "x32";
        }
        return "";
      }(),
      Windows_Version: function() {
        if (userAgent.includes("Windows NT 6.1") || userAgent.includes("Windows 7")) {
          return "Win7";
        } else if (userAgent.includes("Windows NT 6.3") || userAgent.includes("Windows NT 6.2") || userAgent.includes("Windows NT 8")) {
          return "Win8";
        } else if (userAgent.includes("Windows NT 10") || userAgent.includes("Windows NT 6.4")) {
          return "Win10";
        }
        return "";
      }(),
      Mac: userAgent.includes("Macintosh"),
      Mac_Version: function() {
        if (userAgent.includes("Macintosh")) {
          const matches = userAgent.match(/Mac OS X ([^\s]+)\)/);
          if (matches && matches[1]) {
            return matches[1].split(/_|\./).join(".");
          }
        }
        return "";
      }(),
      ios: !!userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),
      ios_Version: function() {
        if (!!userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/)) {
          const matches = userAgent.match(/CPU.+OS ([^\s]+) like Mac OS X/);
          if (matches && matches[1]) {
            return matches[1].split(/_|\./).join(".");
          }
        }
        return "";
      }(),
      Android: userAgent.includes("Android"),
      Android_Version: function() {
        const matches = userAgent.match(/Android ([^\s]+);/);
        if (matches && matches[1]) {
          return matches[1].split(/_|\./).join(".");
        }
        return "";
      }(),
      Linux: userAgent.includes("Linux"),
      HarmonyOS: userAgent.includes("HarmonyOS"),
      Ubuntu: userAgent.includes("Ubuntu")
    };
  }
};
const speech$1 = {
  start(text, params) {
    if (!window.SpeechSynthesisUtterance || !window.speechSynthesis) {
      throw new Error("The current browser does not support this syntax");
    }
    let defaultParams = {
      pitch: 0.8,
      rate: 1,
      volume: 1,
      start: function() {
      },
      end: function() {
      },
      pause: function() {
      },
      resume: function() {
      },
      error: function() {
      }
    };
    if (!common$1.isObject(params)) {
      params = {};
    }
    if (number$1.isNumber(params.pitch)) {
      defaultParams.pitch = params.pitch;
    }
    if (number$1.isNumber(params.rate)) {
      defaultParams.rate = params.rate;
    }
    if (number$1.isNumber(params.volume)) {
      defaultParams.volume = params.volume;
    }
    if (typeof params.start == "function") {
      defaultParams.start = params.start;
    }
    if (typeof params.end == "function") {
      defaultParams.end = params.end;
    }
    if (typeof params.pause == "function") {
      defaultParams.pause = params.pause;
    }
    if (typeof params.resume == "function") {
      defaultParams.resume = params.resume;
    }
    if (typeof params.error == "function") {
      defaultParams.error = params.error;
    }
    const speech2 = new SpeechSynthesisUtterance();
    speech2.text = text;
    speech2.pitch = defaultParams.pitch;
    speech2.rate = defaultParams.rate;
    speech2.volume = defaultParams.volume;
    speech2.lang = "zh-CN";
    speech2.onstart = (event2) => {
      defaultParams.start.apply(speech2, [
        event2,
        {
          text,
          pitch: defaultParams.pitch,
          rate: defaultParams.rate,
          volume: defaultParams.volume
        }
      ]);
    };
    speech2.onend = (event2) => {
      defaultParams.end.apply(speech2, [
        event2,
        {
          text,
          pitch: defaultParams.pitch,
          rate: defaultParams.rate,
          volume: defaultParams.volume
        }
      ]);
    };
    speech2.onpause = (event2) => {
      defaultParams.pause.apply(speech2, [
        event2,
        {
          text,
          pitch: defaultParams.pitch,
          rate: defaultParams.rate,
          volume: defaultParams.volume
        }
      ]);
    };
    speech2.onresume = (event2) => {
      defaultParams.resume.apply(speech2, [
        event2,
        {
          text,
          pitch: defaultParams.pitch,
          rate: defaultParams.rate,
          volume: defaultParams.volume
        }
      ]);
    };
    speech2.onerror = (event2) => {
      defaultParams.error.apply(speech2, [
        event2,
        {
          text,
          pitch: defaultParams.pitch,
          rate: defaultParams.rate,
          volume: defaultParams.volume
        }
      ]);
    };
    window.speechSynthesis.speak(speech2);
  },
  stop() {
    if (!window.SpeechSynthesisUtterance || !window.speechSynthesis) {
      throw new Error("The current browser does not support this syntax");
    }
    window.speechSynthesis.cancel();
  },
  pause() {
    if (!window.SpeechSynthesisUtterance || !window.speechSynthesis) {
      throw new Error("The current browser does not support this syntax");
    }
    window.speechSynthesis.pause();
  },
  resume() {
    if (!window.SpeechSynthesisUtterance || !window.speechSynthesis) {
      throw new Error("The current browser does not support this syntax");
    }
    window.speechSynthesis.resume();
  }
};
const obj$1 = { number: number$1, data: data$1, element: element$1, event: event$1, common: common$1, color: color$1, file: file$1, string: string$1, platform: platform$1, speech: speech$1 };
obj$1.install = (app) => {
  app.config.globalProperties.$dap = obj$1;
  app.provide("$dap", obj$1);
};
obj$1.event.on(window, "touchstart.ios", (e) => {
});
class Anchor {
  constructor(element2, options) {
    this.$el = element2;
    options = obj$1.common.isObject(options) ? options : {};
    this.$target = options.target;
    this.$root = options.root;
    this.callback = options.callback;
    this.time = options.time;
    this.distance = options.distance;
    this.hasInit = false;
  }
  init() {
    if (this.hasInit) {
      return;
    }
    this.hasInit = true;
    if (typeof this.$root == "string" && this.$root) {
      this.$root = document.documentElement.querySelector(this.$root);
    }
    if (typeof this.$target == "string" && this.$target) {
      this.$target = document.documentElement.querySelector(this.$target);
    }
    if (!obj$1.element.isElement(this.$el)) {
      throw new TypeError("The element you click on is not a node element");
    }
    if (!obj$1.element.isElement(this.$target)) {
      throw new TypeError("Anchor element is not a node element");
    }
    if (!obj$1.number.isNumber(this.time)) {
      this.time = 0;
    }
    if (typeof this.callback != "function") {
      this.callback = function() {
      };
    }
    if (!obj$1.number.isNumber(this.distance)) {
      this.distance = 0.1;
    }
    if (obj$1.element.isElement(this.$root)) {
      obj$1.event.on(this.$el, "click.anchor", (e) => {
        let scrollTop = obj$1.element.getElementPoint(this.$target, this.$root).top;
        obj$1.element.setScrollTop({
          el: this.$root,
          number: scrollTop - obj$1.element.rem2px(this.distance),
          time: this.time
        }).then(() => {
          let top = scrollTop - obj$1.element.rem2px(this.distance) <= 0 ? 0 : scrollTop - obj$1.element.rem2px(this.distance);
          this.callback(top);
        });
      });
    } else {
      obj$1.event.on(this.$el, "click.anchor", (e) => {
        let scrollTop = obj$1.element.getElementPoint(this.$target).top;
        obj$1.element.setScrollTop({
          number: scrollTop - obj$1.element.rem2px(this.distance),
          time: this.time
        }).then(() => {
          let top = scrollTop - obj$1.element.rem2px(this.distance) <= 0 ? 0 : scrollTop - obj$1.element.rem2px(this.distance);
          this.callback(top);
        });
      });
    }
  }
}
const Anchor$1 = Anchor;
Anchor$1.install = (app) => {
  app.directive("anchor", {
    mounted(el, binding) {
      let options = {};
      if (obj$1.common.isObject(binding.value)) {
        Object.assign(options, binding.value);
      }
      let anchor = new Anchor$1(el, options);
      anchor.init();
    }
  });
};
class Resize {
  constructor(element2, options) {
    this.$el = element2;
    options = obj$1.common.isObject(options) ? options : {};
    this.draggableX = options.draggableX;
    this.draggableY = options.draggableY;
    this.mode = options.mode;
    this.beforeResize = options.beforeResize;
    this.resize = options.resize;
    this.trigger = options.trigger;
    this.end = options.end;
    this.ready = options.ready;
    this.range = options.range;
    this.draggable = false;
    this.leftRange = {};
    this.rightRange = {};
    this.topRange = {};
    this.bottomRange = {};
    this.leftTopRange = {};
    this.rightTopRange = {};
    this.leftBottomRange = {};
    this.rightBottomRange = {};
    this.startX = 0;
    this.satrtY = 0;
    this._width = 0;
    this._height = 0;
    this._left = 0;
    this._right = 0;
    this.hasInit = false;
    this.cursor = "";
    this.guid = this.createGuid();
  }
  getIsInRange(x, y, range) {
    let conditions1 = x >= range.x[0] && x <= range.x[1];
    let conditions2 = y >= range.y[0] && y <= range.y[1];
    if (conditions1 && conditions2) {
      return true;
    } else {
      return false;
    }
  }
  down(e) {
    this._width = this.$el.offsetWidth;
    this._height = this.$el.offsetHeight;
    this._left = this.$el.offsetLeft;
    this._top = this.$el.offsetTop;
    this.cursor = obj$1.element.getCssStyle(this.$el, "cursor");
    if (this.draggableX && this.draggableY) {
      if (this.getIsInRange(this.startX, this.startY, this.leftTopRange)) {
        if (this.mode.left || this.mode.top) {
          this.draggable = true;
          this.$el.style.cursor = "nw-resize";
          this.trigger.apply(this, [
            {
              event: e,
              area: Resize.AREA.LEFTTOP
            }
          ]);
        }
      } else if (this.getIsInRange(this.startX, this.startY, this.leftBottomRange)) {
        if (this.mode.left || this.mode.bottom) {
          this.draggable = true;
          this.$el.style.cursor = "sw-resize";
          this.trigger.apply(this, [
            {
              event: e,
              area: Resize.AREA.LEFTBOTTOM
            }
          ]);
        }
      } else if (this.getIsInRange(this.startX, this.startY, this.rightTopRange)) {
        if (this.mode.right || this.mode.top) {
          this.draggable = true;
          this.$el.style.cursor = "ne-resize";
          this.trigger.apply(this, [
            {
              event: e,
              area: Resize.AREA.RIGHTTOP
            }
          ]);
        }
      } else if (this.getIsInRange(this.startX, this.startY, this.rightBottomRange)) {
        if (this.mode.right || this.mode.bottom) {
          this.draggable = true;
          this.$el.style.cursor = "se-resize";
          this.trigger.apply(this, [
            {
              event: e,
              area: Resize.AREA.RIGHTBOTTOM
            }
          ]);
        }
      } else if (this.getIsInRange(this.startX, this.startY, this.leftRange)) {
        if (this.mode.left) {
          this.draggable = true;
          this.$el.style.cursor = "w-resize";
          this.trigger.apply(this, [
            {
              event: e,
              area: Resize.AREA.LEFT
            }
          ]);
        }
      } else if (this.getIsInRange(this.startX, this.startY, this.rightRange)) {
        if (this.mode.right) {
          this.draggable = true;
          this.$el.style.cursor = "e-resize";
          this.trigger.apply(this, [
            {
              event: e,
              area: Resize.AREA.RIGHT
            }
          ]);
        }
      } else if (this.getIsInRange(this.startX, this.startY, this.topRange)) {
        if (this.mode.top) {
          this.draggable = true;
          this.$el.style.cursor = "n-resize";
          this.trigger.apply(this, [
            {
              event: e,
              area: Resize.AREA.TOP
            }
          ]);
        }
      } else if (this.getIsInRange(this.startX, this.startY, this.bottomRange)) {
        if (this.mode.bottom) {
          this.draggable = true;
          this.$el.style.cursor = "s-resize";
          this.trigger.apply(this, [
            {
              event: e,
              area: Resize.AREA.BOTTOM
            }
          ]);
        }
      }
    } else if (this.draggableX) {
      if (this.getIsInRange(this.startX, this.startY, this.leftRange)) {
        if (this.mode.left) {
          this.draggable = true;
          this.$el.style.cursor = "w-resize";
          this.trigger.apply(this, [
            {
              event: e,
              area: Resize.AREA.LEFT
            }
          ]);
        }
      } else if (this.getIsInRange(this.startX, this.startY, this.rightRange)) {
        if (this.mode.right) {
          this.draggable = true;
          this.$el.style.cursor = "e-resize";
          this.trigger.apply(this, [
            {
              event: e,
              area: Resize.AREA.RIGHT
            }
          ]);
        }
      }
    } else if (this.draggableY) {
      if (this.getIsInRange(this.startX, this.startY, this.topRange)) {
        if (this.mode.top) {
          this.draggable = true;
          this.$el.style.cursor = "n-resize";
          this.trigger.apply(this, [
            {
              event: e,
              area: Resize.AREA.TOP
            }
          ]);
        }
      } else if (this.getIsInRange(this.startX, this.startY, this.bottomRange)) {
        if (this.mode.bottom) {
          this.draggable = true;
          this.$el.style.cursor = "s-resize";
          this.trigger.apply(this, [
            {
              event: e,
              area: Resize.AREA.BOTTOM
            }
          ]);
        }
      }
    }
  }
  move(e, endX, endY) {
    if (this.draggable) {
      let moveX = endX - this.startX;
      let moveY = endY - this.startY;
      if (this.draggableX && this.draggableY) {
        if (this.getIsInRange(this.startX, this.startY, this.leftTopRange)) {
          if (this.mode.left || this.mode.top) {
            if (this.beforeResize.apply(this, [
              {
                event: e,
                area: Resize.AREA.LEFTTOP,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]) === false) {
              return;
            }
          }
          if (this.mode.left) {
            this.$el.style.width = this._width - moveX + "px";
            this.$el.style.left = this._left + moveX + "px";
          }
          if (this.mode.top) {
            this.$el.style.height = this._height - moveY + "px";
            this.$el.style.top = this._top + moveY + "px";
          }
          if (this.mode.left || this.mode.top) {
            this.resize.apply(this, [
              {
                area: Resize.AREA.LEFTTOP,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]);
          }
        } else if (this.getIsInRange(this.startX, this.startY, this.leftBottomRange)) {
          if (this.mode.left || this.mode.bottom) {
            if (this.beforeResize.apply(this, [
              {
                area: Resize.AREA.LEFTBOTTOM,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]) === false) {
              return;
            }
          }
          if (this.mode.left) {
            this.$el.style.width = this._width - moveX + "px";
            this.$el.style.left = this._left + moveX + "px";
          }
          if (this.mode.bottom) {
            this.$el.style.height = this._height + moveY + "px";
          }
          if (this.mode.left || this.mode.bottom) {
            this.resize.apply(this, [
              {
                area: Resize.AREA.LEFTBOTTOM,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]);
          }
        } else if (this.getIsInRange(this.startX, this.startY, this.rightTopRange)) {
          if (this.mode.right || this.mode.top) {
            if (this.beforeResize.apply(this, [
              {
                area: Resize.AREA.RIGHTTOP,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]) === false) {
              return;
            }
          }
          if (this.mode.right) {
            this.$el.style.width = this._width + moveX + "px";
          }
          if (this.mode.top) {
            this.$el.style.height = this._height - moveY + "px";
            this.$el.style.top = this._top + moveY + "px";
          }
          if (this.mode.top || this.mode.right) {
            this.resize.apply(this, [
              {
                area: Resize.AREA.RIGHTTOP,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]);
          }
        } else if (this.getIsInRange(this.startX, this.startY, this.rightBottomRange)) {
          if (this.mode.right || this.mode.bottom) {
            if (this.beforeResize.apply(this, [
              {
                area: Resize.AREA.RIGHTBOTTOM,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]) === false) {
              return;
            }
          }
          if (this.mode.right) {
            this.$el.style.width = this._width + moveX + "px";
          }
          if (this.mode.bottom) {
            this.$el.style.height = this._height + moveY + "px";
          }
          if (this.mode.right || this.mode.bottom) {
            this.resize.apply(this, [
              {
                area: Resize.AREA.RIGHTBOTTOM,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]);
          }
        } else if (this.getIsInRange(this.startX, this.startY, this.leftRange)) {
          if (this.mode.left) {
            if (this.beforeResize.apply(this, [
              {
                area: Resize.AREA.LEFT,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]) === false) {
              return;
            }
            this.$el.style.width = this._width - moveX + "px";
            this.$el.style.left = this._left + moveX + "px";
            this.resize.apply(this, [
              {
                area: Resize.AREA.LEFT,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]);
          }
        } else if (this.getIsInRange(this.startX, this.startY, this.rightRange)) {
          if (this.mode.right) {
            if (this.beforeResize.apply(this, [
              {
                area: Resize.AREA.RIGHT,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]) === false) {
              return;
            }
            this.$el.style.width = this._width + moveX + "px";
            this.resize.apply(this, [
              {
                area: Resize.AREA.RIGHT,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]);
          }
        } else if (this.getIsInRange(this.startX, this.startY, this.topRange)) {
          if (this.mode.top) {
            if (this.beforeResize.apply(this, [
              {
                area: Resize.AREA.TOP,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]) === false) {
              return;
            }
            this.$el.style.height = this._height - moveY + "px";
            this.$el.style.top = this._top + moveY + "px";
            this.resize.apply(this, [
              {
                area: Resize.AREA.TOP,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]);
          }
        } else if (this.getIsInRange(this.startX, this.startY, this.bottomRange)) {
          if (this.mode.bottom) {
            if (this.beforeResize.apply(this, [
              {
                area: Resize.AREA.BOTTOM,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]) === false) {
              return;
            }
            this.$el.style.height = this._height + moveY + "px";
            this.resize.apply(this, [
              {
                area: Resize.AREA.BOTTOM,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]);
          }
        }
      } else if (this.draggableX) {
        if (this.getIsInRange(this.startX, this.startY, this.leftRange)) {
          if (this.mode.left) {
            if (this.beforeResize.apply(this, [
              {
                area: Resize.AREA.LEFT,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]) === false) {
              return;
            }
            this.$el.style.width = this._width - moveX + "px";
            this.$el.style.left = this._left + moveX + "px";
            this.resize.apply(this, [
              {
                area: Resize.AREA.LEFT,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]);
          }
        } else if (this.getIsInRange(this.startX, this.startY, this.rightRange)) {
          if (this.mode.right) {
            if (this.beforeResize.apply(this, [
              {
                area: Resize.AREA.RIGHT,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]) === false) {
              return;
            }
            this.$el.style.width = this._width + moveX + "px";
            this.resize.apply(this, [
              {
                area: Resize.AREA.RIGHT,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]);
          }
        }
      } else if (this.draggableY) {
        if (this.getIsInRange(this.startX, this.startY, this.topRange)) {
          if (this.mode.top) {
            if (this.beforeResize.apply(this, [
              {
                area: Resize.AREA.TOP,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]) === false) {
              return;
            }
            this.$el.style.height = this._height - moveY + "px";
            this.$el.style.top = this._top + moveY + "px";
            this.resize.apply(this, [
              {
                area: Resize.AREA.TOP,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]);
          }
        } else if (this.getIsInRange(this.startX, this.startY, this.bottomRange)) {
          if (this.mode.bottom) {
            if (this.beforeResize.apply(this, [
              {
                area: Resize.AREA.BOTTOM,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]) === false) {
              return;
            }
            this.$el.style.height = this._height + moveY + "px";
            this.resize.apply(this, [
              {
                area: Resize.AREA.BOTTOM,
                event: e,
                width: this.$el.offsetWidth,
                height: this.$el.offsetHeight,
                moveX,
                moveY
              }
            ]);
          }
        }
      }
    }
  }
  leave(e) {
    if (this.draggable) {
      this.$el.style.cursor = this.cursor;
      this.draggable = false;
      if (this.draggableX && this.draggableY) {
        if (this.getIsInRange(this.startX, this.startY, this.leftTopRange)) {
          this.end.apply(this, [
            {
              event: e,
              area: Resize.AREA.LEFTTOP
            }
          ]);
        } else if (this.getIsInRange(this.startX, this.startY, this.leftBottomRange)) {
          this.end.apply(this, [
            {
              event: e,
              area: Resize.AREA.LEFTBOTTOM
            }
          ]);
        } else if (this.getIsInRange(this.startX, this.startY, this.rightTopRange)) {
          this.end.apply(this, [
            {
              event: e,
              area: Resize.AREA.RIGHTTOP
            }
          ]);
        } else if (this.getIsInRange(this.startX, this.startY, this.rightBottomRange)) {
          this.end.apply(this, [
            {
              event: e,
              area: Resize.AREA.RIGHTBOTTOM
            }
          ]);
        } else if (this.getIsInRange(this.startX, this.startY, this.leftRange)) {
          this.end.apply(this, [
            {
              event: e,
              area: Resize.AREA.LEFT
            }
          ]);
        } else if (this.getIsInRange(this.startX, this.startY, this.rightRange)) {
          this.end.apply(this, [
            {
              event: e,
              area: Resize.AREA.RIGHT
            }
          ]);
        } else if (this.getIsInRange(this.startX, this.startY, this.topRange)) {
          this.end.apply(this, [
            {
              event: e,
              area: Resize.AREA.TOP
            }
          ]);
        } else if (this.getIsInRange(this.startX, this.startY, this.bottomRange)) {
          this.end.apply(this, [
            {
              event: e,
              area: Resize.AREA.BOTTOM
            }
          ]);
        }
      } else if (this.draggableX) {
        if (this.getIsInRange(this.startX, this.startY, this.leftRange)) {
          this.end.apply(this, [
            {
              event: e,
              area: Resize.AREA.LEFT
            }
          ]);
        } else if (this.getIsInRange(this.startX, this.startY, this.rightRange)) {
          this.end.apply(this, [
            {
              event: e,
              area: Resize.AREA.RIGHT
            }
          ]);
        }
      } else if (this.draggableY) {
        if (this.getIsInRange(this.startX, this.startY, this.topRange)) {
          this.end.apply(this, [
            {
              event: e,
              area: Resize.AREA.TOP
            }
          ]);
        } else if (this.getIsInRange(this.startX, this.startY, this.bottomRange)) {
          this.end.apply(this, [
            {
              event: e,
              area: Resize.AREA.BOTTOM
            }
          ]);
        }
      }
      this.setRange();
    }
  }
  setOn() {
    obj$1.event.on(this.$el, "touchstart.resize", (e) => {
      this.startX = e.targetTouches[0].pageX;
      this.startY = e.targetTouches[0].pageY;
      this.down(e);
    });
    obj$1.event.on(this.$el, "touchmove.resize", (e) => {
      if (e.cancelable) {
        e.preventDefault();
      }
      let endX = e.targetTouches[0].pageX;
      let endY = e.targetTouches[0].pageY;
      this.move(e, endX, endY);
    });
    obj$1.event.on(this.$el, "touchend.resize", (e) => {
      this.leave(e);
    });
    obj$1.event.on(this.$el, "mousedown.resize", (e) => {
      this.startX = e.pageX;
      this.startY = e.pageY;
      this.down(e);
    });
    obj$1.event.on(document.documentElement, `mousemove.resize_${this.guid}`, (e) => {
      let endX = e.pageX;
      let endY = e.pageY;
      this.move(e, endX, endY);
    });
    obj$1.event.on(document.documentElement, `mouseup.resize_${this.guid}`, (e) => {
      this.leave(e);
    });
  }
  createGuid() {
    let guid = obj$1.data.get(document.body, "mvi-directives-resize-guid") || 0;
    guid++;
    obj$1.data.set(document.body, "mvi-directives-resize-guid", guid);
    return guid;
  }
  init() {
    if (this.hasInit) {
      return;
    }
    this.hasInit = true;
    if (!obj$1.element.isElement(this.$el)) {
      throw new TypeError("The element that needs to be resized is not a node element");
    }
    if (typeof this.draggableX != "boolean") {
      this.draggableX = true;
    }
    if (typeof this.draggableY != "boolean") {
      this.draggableY = true;
    }
    if (!obj$1.common.isObject(this.mode)) {
      this.mode = {
        left: Resize.MODE.LEFT,
        top: Resize.MODE.TOP,
        bottom: Resize.MODE.BOTTOM,
        right: Resize.MODE.RIGHT
      };
    } else {
      if (typeof this.mode.left != "boolean") {
        this.mode.left = Resize.MODE.LEFT;
      }
      if (typeof this.mode.top != "boolean") {
        this.mode.top = Resize.MODE.TOP;
      }
      if (typeof this.mode.bottom != "boolean") {
        this.mode.bottom = Resize.MODE.BOTTOM;
      }
      if (typeof this.mode.right != "boolean") {
        this.mode.right = Resize.MODE.RIGHT;
      }
    }
    if (typeof this.beforeResize != "function") {
      this.beforeResize = function() {
      };
    }
    if (typeof this.resize != "function") {
      this.resize = function() {
      };
    }
    if (typeof this.trigger != "function") {
      this.trigger = function() {
      };
    }
    if (typeof this.end != "function") {
      this.end = function() {
      };
    }
    if (typeof this.ready != "function") {
      this.ready = function() {
      };
    }
    if (!obj$1.number.isNumber(this.range)) {
      this.range = 0.4;
    }
    this.setRange();
    this.setOn();
    this.ready.apply(this, [this]);
  }
  setRange() {
    let range = this.$el.getBoundingClientRect();
    if (this.draggableX && this.draggableY) {
      this.leftRange = {
        x: [range.left, range.left + obj$1.element.rem2px(this.range)],
        y: [range.top + obj$1.element.rem2px(this.range), range.bottom - obj$1.element.rem2px(this.range)]
      };
      this.rightRange = {
        x: [range.right - obj$1.element.rem2px(this.range), range.right],
        y: [range.top + obj$1.element.rem2px(this.range), range.bottom - obj$1.element.rem2px(this.range)]
      };
      this.topRange = {
        x: [range.left + obj$1.element.rem2px(this.range), range.right - obj$1.element.rem2px(this.range)],
        y: [range.top, range.top + obj$1.element.rem2px(this.range)]
      };
      this.bottomRange = {
        x: [range.left + obj$1.element.rem2px(this.range), range.right - obj$1.element.rem2px(this.range)],
        y: [range.bottom - obj$1.element.rem2px(this.range), range.bottom]
      };
      this.leftTopRange = {
        x: [range.left, range.left + obj$1.element.rem2px(this.range)],
        y: [range.top, range.top + obj$1.element.rem2px(this.range)]
      };
      this.leftBottomRange = {
        x: [range.left, range.left + obj$1.element.rem2px(this.range)],
        y: [range.bottom - obj$1.element.rem2px(this.range), range.bottom]
      };
      this.rightTopRange = {
        x: [range.right - obj$1.element.rem2px(this.range), range.right],
        y: [range.top, range.top + obj$1.element.rem2px(this.range)]
      };
      this.rightBottomRange = {
        x: [range.right - obj$1.element.rem2px(this.range), range.right],
        y: [range.bottom - obj$1.element.rem2px(this.range), range.bottom]
      };
    } else if (this.draggableX) {
      this.leftRange = {
        x: [range.left, range.left + obj$1.element.rem2px(this.range)],
        y: [range.top, range.bottom]
      };
      this.rightRange = {
        x: [range.right - obj$1.element.rem2px(this.range), range.right],
        y: [range.top, range.bottom]
      };
    } else if (this.draggableY) {
      this.topRange = {
        x: [range.left, range.right],
        y: [range.top, range.top + obj$1.element.rem2px(this.range)]
      };
      this.bottomRange = {
        x: [range.left, range.right],
        y: [range.bottom - obj$1.element.rem2px(this.range), range.bottom]
      };
    }
  }
  destroy() {
    obj$1.event.off(document.documentElement, `mousemove.resize_${this.guid} mouseup.resize_${this.guid}`);
  }
  disabledDragX() {
    this.draggableX = false;
    this.setRange();
  }
  disabledDragY() {
    this.draggableY = false;
    this.setRange();
  }
  enabledDragX() {
    this.draggableX = true;
    this.setRange();
  }
  enabledDragY() {
    this.draggableY = true;
    this.setRange();
  }
}
Resize.AREA = {
  LEFT: "left",
  TOP: "top",
  RIGHT: "right",
  BOTTOM: "bottom",
  LEFTTOP: "left-top",
  LEFTBOTTOM: "left-bottom",
  RIGHTTOP: "right-top",
  RIGHTBOTTOM: "right-bottom"
};
Resize.MODE = {
  LEFT: true,
  TOP: true,
  BOTTOM: true,
  RIGHT: true
};
const Resize$1 = Resize;
Resize$1.install = (app) => {
  app.directive("resize", {
    mounted(el, binding) {
      let options = {};
      if (obj$1.common.isObject(binding.value)) {
        Object.assign(options, binding.value);
      }
      let resize = new Resize$1(el, options);
      resize.init();
      obj$1.data.set(el, "directive:resize", resize);
    },
    beforeUnmount(el) {
      let resize = obj$1.data.get(el, "directive:resize");
      if (resize) {
        resize.destroy();
      }
    }
  });
};
class Drag {
  constructor(element2, options) {
    this.$el = element2;
    options = obj$1.common.isObject(options) ? options : {};
    this.$container = options.container;
    this.draggableX = options.draggableX;
    this.draggableY = options.draggableY;
    this.mode = options.mode;
    this.cursor = options.cursor;
    this.drag = options.drag;
    this.beforeDrag = options.beforeDrag;
    this.dragged = options.dragged;
    this.ready = options.ready;
    this.draggable = false;
    this.hasInit = false;
    this.pageX = 0;
    this.pageY = 0;
    this.guid = this.createGuid();
  }
  setOn() {
    obj$1.event.on(this.$el, "touchstart.drag", (e) => {
      if (!this.draggableX && !this.draggableY) {
        return;
      }
      this.pageX = e.targetTouches[0].pageX - obj$1.element.getElementPoint(this.$el, this.$container).left;
      this.pageY = e.targetTouches[0].pageY - obj$1.element.getElementPoint(this.$el, this.$container).top;
      this.draggable = true;
      if (this.cursor) {
        this.$el.style.cursor = "move";
      }
      this.beforeDrag.apply(this, [this.$el, this.$container, obj$1.element.getElementPoint(this.$el, this.$container), e]);
    });
    obj$1.event.on(this.$el, "touchmove.drag", (e) => {
      if (this.draggable) {
        if (!this.draggableX && !this.draggableY) {
          return;
        }
        if (e.cancelable) {
          e.preventDefault();
        }
        let left = e.targetTouches[0].pageX - this.pageX;
        let top = e.targetTouches[0].pageY - this.pageY;
        if (this.draggableX) {
          this.$el.style.left = left + "px";
          this.$el.style.right = "auto";
        }
        if (this.draggableY) {
          this.$el.style.top = top + "px";
          this.$el.style.bottom = "auto";
        }
        this.resize();
        if (this.draggableX || this.draggableY) {
          this.drag.apply(this, [this.$el, this.$container, obj$1.element.getElementPoint(this.$el, this.$container), e]);
        }
      }
    });
    obj$1.event.on(this.$el, "touchend.drag", (e) => {
      if (this.draggable) {
        if (!this.draggableX && !this.draggableY) {
          return;
        }
        this.draggable = false;
        if (this.cursor) {
          this.$el.style.cursor = "";
        }
        this.dragged.apply(this, [this.$el, this.$container, obj$1.element.getElementPoint(this.$el, this.$container), e]);
      }
    });
    obj$1.event.on(this.$el, "mousedown.drag", (e) => {
      if (!this.draggableX && !this.draggableY) {
        return;
      }
      this.pageX = e.pageX - obj$1.element.getElementPoint(this.$el, this.$container).left;
      this.pageY = e.pageY - obj$1.element.getElementPoint(this.$el, this.$container).top;
      this.draggable = true;
      if (this.cursor) {
        this.$el.style.cursor = "move";
      }
      this.beforeDrag.apply(this, [this.$el, this.$container, obj$1.element.getElementPoint(this.$el, this.$container), e]);
    });
    obj$1.event.on(document.documentElement, `mousemove.drag_${this.guid}`, (e) => {
      if (this.draggable) {
        if (!this.draggableX && !this.draggableY) {
          return;
        }
        let left = e.pageX - this.pageX;
        let top = e.pageY - this.pageY;
        if (this.draggableX) {
          this.$el.style.left = left + "px";
          this.$el.style.right = "auto";
        }
        if (this.draggableY) {
          this.$el.style.top = top + "px";
          this.$el.style.bottom = "auto";
        }
        this.resize();
        if (this.draggableX || this.draggableY) {
          this.drag.apply(this, [this.$el, this.$container, obj$1.element.getElementPoint(this.$el, this.$container), e]);
        }
      }
    });
    obj$1.event.on(document.documentElement, `mouseup.drag_${this.guid}`, (e) => {
      if (this.draggable) {
        if (!this.draggableX && !this.draggableY) {
          return;
        }
        this.draggable = false;
        if (this.cursor) {
          this.$el.style.cursor = "";
        }
        this.dragged.apply(this, [this.$el, this.$container, obj$1.element.getElementPoint(this.$el, this.$container), e]);
      }
    });
  }
  resize() {
    if (this.mode == "in") {
      if (this.draggableX) {
        if (obj$1.element.getElementPoint(this.$el, this.$container).left <= 0) {
          this.$el.style.left = 0;
        }
        if (obj$1.element.getElementPoint(this.$el, this.$container).left >= this.$container.offsetWidth - this.$el.offsetWidth) {
          this.$el.style.left = this.$container.offsetWidth - this.$el.offsetWidth + "px";
        }
      }
      if (this.draggableY) {
        if (obj$1.element.getElementPoint(this.$el, this.$container).top <= 0) {
          this.$el.style.top = 0;
        }
        if (obj$1.element.getElementPoint(this.$el, this.$container).top >= this.$container.offsetHeight - this.$el.offsetHeight) {
          this.$el.style.top = this.$container.offsetHeight - this.$el.offsetHeight + "px";
        }
      }
    } else if (this.mode == "on") {
      if (this.draggableX) {
        if (obj$1.element.getElementPoint(this.$el, this.$container).left <= -this.$el.offsetWidth / 2) {
          this.$el.style.left = -this.$el.offsetWidth / 2 + "px";
        }
        if (obj$1.element.getElementPoint(this.$el, this.$container).left >= this.$container.offsetWidth - this.$el.offsetWidth / 2) {
          this.$el.style.left = this.$container.offsetWidth - this.$el.offsetWidth / 2 + "px";
        }
      }
      if (this.draggableY) {
        if (obj$1.element.getElementPoint(this.$el, this.$container).top <= -this.$el.offsetHeight / 2) {
          this.$el.style.top = -this.$el.offsetHeight / 2 + "px";
        }
        if (obj$1.element.getElementPoint(this.$el, this.$container).top >= this.$container.offsetHeight - this.$el.offsetHeight / 2) {
          this.$el.style.top = this.$container.offsetHeight - this.$el.offsetHeight / 2 + "px";
        }
      }
    } else if (this.mode == "out") {
      if (this.draggableX) {
        if (obj$1.element.getElementPoint(this.$el, this.$container).left <= -this.$el.offsetWidth) {
          this.$el.style.left = -this.$el.offsetWidth + "px";
        }
        if (obj$1.element.getElementPoint(this.$el, this.$container).left >= this.$container.offsetWidth) {
          this.$el.style.left = this.$container.offsetWidth + "px";
        }
      }
      if (this.draggableY) {
        if (obj$1.element.getElementPoint(this.$el, this.$container).top <= -this.$el.offsetHeight) {
          this.$el.style.top = -this.$el.offsetHeight + "px";
        }
        if (obj$1.element.getElementPoint(this.$el, this.$container).top >= this.$container.offsetHeight) {
          this.$el.style.top = this.$container.offsetHeight + "px";
        }
      }
    }
  }
  createGuid() {
    let guid = obj$1.data.get(document.body, "mvi-directives-drag-guid") || 0;
    guid++;
    obj$1.data.set(document.body, "mvi-directives-drag-guid", guid);
    return guid;
  }
  init() {
    if (this.hasInit) {
      return;
    }
    this.hasInit = true;
    if (!obj$1.element.isElement(this.$el)) {
      throw new TypeError("The element that needs to be dragged is not a node element");
    }
    if (typeof this.$container == "string" && this.$container) {
      this.$container = document.body.querySelector(this.$container);
    }
    if (!obj$1.element.isElement(this.$container)) {
      this.$container = document.body;
    }
    if (!obj$1.element.isContains(this.$container, this.$el)) {
      throw new Error("Elements that need to be dragged are not descendants of container elements");
    }
    if (obj$1.element.getCssStyle(this.$container, "position") == "static" && this.$container != document.body) {
      throw new Error("The container element cannot be static positioning");
    }
    if (obj$1.element.getCssStyle(this.$el, "position") == "static" || obj$1.element.getCssStyle(this.$el, "position") == "relative") {
      throw new Error("The element that need to be dragged cannot be static and relative positioning");
    }
    if (typeof this.draggableY != "boolean") {
      this.draggableY = true;
    }
    if (typeof this.draggableX != "boolean") {
      this.draggableX = true;
    }
    if (this.mode != "on" && this.mode != "in" && this.mode != "over" && this.mode != "out") {
      this.mode = "";
    }
    if (typeof this.cursor != "boolean") {
      this.cursor = true;
    }
    if (typeof this.drag != "function") {
      this.drag = function() {
      };
    }
    if (typeof this.beforeDrag != "function") {
      this.beforeDrag = function() {
      };
    }
    if (typeof this.dragged != "function") {
      this.dragged = function() {
      };
    }
    if (typeof this.ready != "function") {
      this.ready = function() {
      };
    }
    this.setOn();
    this.ready.apply(this, [this]);
  }
  destroy() {
    obj$1.event.off(document.documentElement, `mousemove.drag_${this.guid} mouseup.drag_${this.guid}`);
  }
}
const Drag$1 = Drag;
Drag$1.install = (app) => {
  app.directive("drag", {
    mounted(el, binding) {
      let options = {};
      if (obj$1.common.isObject(binding.value)) {
        Object.assign(options, binding.value);
      }
      let drag = new Drag$1(el, options);
      drag.init();
      obj$1.data.set(el, "directive:drag", drag);
    },
    beforeUnmount(el) {
      let drag = obj$1.data.get(el, "directive:drag");
      if (drag) {
        drag.destroy();
      }
    }
  });
};
class Prop {
  constructor(element2, ratio) {
    this.$el = element2;
    this.ratio = ratio;
    this.width = 0;
    this.height = 0;
    this.hasInit = false;
    this.guid = this.createGuid();
  }
  createGuid() {
    let guid = obj$1.data.get(document.body, "mvi-directives-prop-guid") || 0;
    guid++;
    obj$1.data.set(document.body, "mvi-directives-prop-guid", guid);
    return guid;
  }
  set(number2) {
    if (typeof number2 == "number" && !isNaN(number2) && number2 >= 0) {
      this.ratio = number2;
    }
    this.width = Number(parseFloat(obj$1.element.getCssStyle(this.$el, "width")).toFixed(2));
    this.height = this.width * this.ratio;
    this.$el.style.height = this.height + "px";
  }
  init() {
    if (this.hasInit) {
      return;
    }
    this.hasInit = true;
    if (!obj$1.element.isElement(this.$el)) {
      throw new TypeError("The bound element is not a node element");
    }
    if (typeof this.ratio != "number" || isNaN(this.ratio)) {
      this.ratio = 0;
    }
    this.set();
    obj$1.event.on(window, `resize.prop_${this.guid}`, (e) => {
      this.set();
    });
  }
  destroy() {
    obj$1.event.off(window, `resize.prop_${this.guid}`);
  }
}
const Prop$1 = Prop;
Prop$1.install = (app) => {
  app.directive("prop", {
    mounted(el, binding) {
      let prop = new Prop$1(el, binding.value);
      prop.init();
      obj$1.data.set(el, "directive:prop", prop);
    },
    updated(el, binding) {
      let prop = obj$1.data.get(el, "directive:prop");
      if (prop) {
        prop.set(binding.value);
      }
    },
    beforeUnmount(el) {
      let prop = obj$1.data.get(el, "directive:prop");
      if (prop) {
        prop.destroy();
      }
    }
  });
};
class Scroll {
  constructor(element2, options) {
    this.$el = element2;
    options = obj$1.common.isObject(options) ? options : {};
    this.top = options.top;
    this.bottom = options.bottom;
    this.hasInit = false;
  }
  init() {
    if (this.hasInit) {
      return;
    }
    this.hasInit = true;
    if (!obj$1.element.isElement(this.$el)) {
      this.$el = window;
    }
    if (typeof this.top != "function") {
      this.top = function() {
      };
    }
    if (typeof this.bottom != "function") {
      this.bottom = function() {
      };
    }
    obj$1.element.scrollTopBottomTrigger(this.$el, (res) => {
      if (res.state == "top") {
        this.top.apply(this, [res.target]);
      } else {
        this.bottom.apply(this, [res.target]);
      }
    });
  }
}
const Scroll$1 = Scroll;
Scroll$1.install = (app) => {
  app.directive("scroll", {
    mounted(el, binding) {
      let options = {};
      if (obj$1.common.isObject(binding.value)) {
        Object.assign(options, binding.value);
      }
      let scroll = new Scroll$1(el, options);
      scroll.init();
    }
  });
};
class Spy {
  constructor(element2, options) {
    this.$el = element2;
    options = obj$1.common.isObject(options) ? options : {};
    this.$root = options.el;
    this.beforeEnter = options.beforeEnter;
    this.enter = options.enter;
    this.beforeLeave = options.beforeLeave;
    this.leave = options.leave;
    this.hasInit = false;
    this.triggerTag = {
      before: false,
      after: false
    };
    this.guid = this.createGuid();
  }
  scrollHandle() {
    const elRect = this.$el.getBoundingClientRect();
    const rootRect = this.$root.getBoundingClientRect();
    if (elRect.right >= rootRect.left && elRect.left <= rootRect.right && elRect.bottom >= rootRect.top && elRect.top <= rootRect.bottom) {
      if (!this.triggerTag.before) {
        this.beforeEnter.apply(this, [this.$el]);
        this.triggerTag.before = true;
      }
    } else {
      if (this.triggerTag.before) {
        this.leave.apply(this, [this.$el]);
        this.triggerTag.before = false;
      }
    }
    if (elRect.left >= rootRect.left && elRect.right <= rootRect.right && elRect.top >= rootRect.top && elRect.bottom <= rootRect.bottom) {
      if (!this.triggerTag.after) {
        this.enter.apply(this, [this.$el]);
        this.triggerTag.after = true;
      }
    } else {
      if (this.triggerTag.after) {
        this.beforeLeave.apply(this, [this.$el]);
        this.triggerTag.after = false;
      }
    }
  }
  createGuid() {
    let guid = obj$1.data.get(document.body, "mvi-directives-spy-guid") || 0;
    guid++;
    obj$1.data.set(document.body, "mvi-directives-spy-guid", guid);
    return guid;
  }
  init() {
    if (this.hasInit) {
      return;
    }
    this.hasInit = true;
    if (!obj$1.element.isElement(this.$el)) {
      throw new TypeError("The bound element is not a node element");
    }
    if (typeof this.$root == "string" && this.$root) {
      this.$root = document.documentElement.querySelector(this.$root);
    }
    if (!obj$1.element.isElement(this.$root)) {
      this.$root = document.body;
    }
    if (typeof this.beforeEnter != "function") {
      this.beforeEnter = function() {
      };
    }
    if (typeof this.enter != "function") {
      this.enter = function() {
      };
    }
    if (typeof this.beforeLeave != "function") {
      this.beforeLeave = function() {
      };
    }
    if (typeof this.leave != "function") {
      this.leave = function() {
      };
    }
    this.scrollHandle();
    obj$1.event.on(this.$root, `scroll.spy_${this.guid}`, (e) => {
      this.scrollHandle();
    });
  }
  destroy() {
    obj$1.event.off(this.$root, `scroll.spy_${this.guid}`);
  }
}
const Spy$1 = Spy;
Spy$1.install = (app) => {
  app.directive("spy", {
    mounted(el, binding) {
      let options = {};
      if (obj$1.common.isObject(binding.value)) {
        Object.assign(options, binding.value);
      }
      let spy = new Spy$1(el, options);
      spy.init();
      obj$1.data.set(el, "directive:spy", spy);
    },
    beforeUnmount(el) {
      let spy = obj$1.data.get(el, "directive:spy");
      if (spy) {
        spy.destroy();
      }
    }
  });
};
class Observe {
  constructor(el, options) {
    this.$el = el;
    if (!obj$1.common.isObject(options)) {
      options = {};
    }
    this.attributes = options.attributes;
    this.childList = options.childList;
    this.subtree = options.subtree;
    this.attributeNames = options.attributeNames;
    this.attributesChange = options.attributesChange;
    this.childNodesChange = options.childNodesChange;
    this.hasInit = false;
  }
  init() {
    if (this.hasInit) {
      return;
    }
    this.hasInit = true;
    if (!obj$1.element.isElement(this.$el)) {
      throw new TypeError("The element that needs to be observed is not a node element");
    }
    try {
      if (typeof this.attributes != "boolean") {
        this.attributes = false;
      }
      if (typeof this.childList != "boolean") {
        this.childList = false;
      }
      if (typeof this.subtree != "boolean") {
        this.subtree = false;
      }
      if (!(this.attributeNames instanceof Array)) {
        this.attributeNames = [];
      }
      if (typeof this.attributesChange != "function") {
        this.attributesChange = function() {
        };
      }
      if (typeof this.childNodesChange != "function") {
        this.childNodesChange = function() {
        };
      }
      let MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
      let observer = new MutationObserver((mutationList) => {
        let length = mutationList.length;
        for (let i = 0; i < length; i++) {
          if (mutationList[i].type == "attributes" && this.attributes) {
            this.attributesChange.apply(this, [mutationList[i].attributeName, this.$el.getAttribute(mutationList[i].attributeName), mutationList[i].oldValue]);
          } else if (mutationList[i].type == "childList" && this.childList) {
            for (let node of mutationList[i].addedNodes) {
              if (obj$1.element.isElement(node)) {
                this.childNodesChange.apply(this, [node, null]);
              }
            }
            for (let node of mutationList[i].removedNodes) {
              if (obj$1.element.isElement(node)) {
                this.childNodesChange.apply(this, [null, node]);
              }
            }
          }
        }
      });
      if (this.attributes) {
        if (this.attributeNames.length > 0) {
          observer.observe(this.$el, {
            attributes: this.attributes,
            attributeFilter: this.attributeNames,
            attributeOldValue: true,
            childList: this.childList,
            subtree: this.subtree
          });
        } else {
          observer.observe(this.$el, {
            attributes: this.attributes,
            attributeOldValue: true,
            childList: this.childList,
            subtree: this.subtree
          });
        }
      } else {
        observer.observe(this.$el, {
          attributes: this.attributes,
          childList: this.childList,
          subtree: this.subtree
        });
      }
    } catch (e) {
      throw new Error("Listening failed. Your browser may not support it, or childList and attributes are false, meaning there are no objects to listen on");
    }
  }
}
const Observe$1 = Observe;
Observe$1.install = (app) => {
  app.directive("observe", {
    mounted(el, binding) {
      let options = {};
      if (obj$1.common.isObject(binding.value)) {
        Object.assign(options, binding.value);
      }
      let observe = new Observe$1(el, options);
      observe.init();
    }
  });
};
class Upload {
  constructor(element2, options) {
    this.$el = element2;
    options = obj$1.common.isObject(options) ? options : {};
    this.$selectInput = null;
    this.files = [];
    this.accept = options.accept;
    this.capture = options.capture;
    this.allowedFileType = options.allowedFileType;
    this.minSize = options.minSize;
    this.maxSize = options.maxSize;
    this.maxLength = options.maxLength;
    this.minLength = options.minLength;
    this.multiple = options.multiple;
    this.append = options.append;
    this.error = options.error;
    this.select = options.select;
    this.disabled = options.disabled;
    this.ready = options.ready;
    this.extraData = options.extraData;
    this.hasInit = false;
  }
  judgeSuffix(fileName) {
    let suffix = fileName.substr(fileName.lastIndexOf(".") + 1);
    if (this.allowedFileType.length == 0) {
      return true;
    } else {
      suffix = suffix.toLocaleLowerCase();
      for (let i = 0; i < this.allowedFileType.length; i++) {
        this.allowedFileType[i] = this.allowedFileType[i].toLocaleLowerCase();
      }
      return this.allowedFileType.includes(suffix);
    }
  }
  init() {
    if (this.hasInit) {
      return;
    }
    this.hasInit = true;
    if (!obj$1.element.isElement(this.$el)) {
      throw new TypeError("The upload element is not specified");
    }
    if (!(this.allowedFileType instanceof Array)) {
      this.allowedFileType = [];
    }
    if (!obj$1.number.isNumber(this.minSize) || this.minSize <= 0) {
      this.minSize = -1;
    }
    if (!obj$1.number.isNumber(this.maxSize) || this.maxSize <= 0) {
      this.maxSize = -1;
    }
    if (!obj$1.number.isNumber(this.maxLength) || this.maxLength <= 0) {
      this.maxLength = -1;
    }
    if (!obj$1.number.isNumber(this.minLength) || this.minLength <= 0) {
      this.minLength = -1;
    }
    if (typeof this.multiple != "boolean") {
      this.multiple = false;
    }
    if (typeof this.capture != "boolean") {
      this.capture = false;
    }
    if (typeof this.append != "boolean") {
      this.append = false;
    }
    if (typeof this.disabled != "boolean") {
      this.disabled = false;
    }
    if (typeof this.error != "function") {
      this.error = function() {
      };
    }
    if (typeof this.select != "function") {
      this.select = function() {
      };
    }
    if (typeof this.ready != "function") {
      this.ready = function() {
      };
    }
    if (!obj$1.common.isObject(this.extraData)) {
      this.extraData = {};
    }
    this.$selectInput = obj$1.element.string2dom("<input type='file' />");
    if (this.accept === "rar") {
      this.$selectInput.setAttribute("accept", "application/x-rar-compressed");
    } else if (this.accept === "zip") {
      this.$selectInput.setAttribute("accept", "application/x-zip-compressed");
    } else if (this.accept === "txt") {
      this.$selectInput.setAttribute("accept", "text/plain");
    } else if (this.accept === "image") {
      this.$selectInput.setAttribute("accept", "image/*");
      if (this.capture) {
        this.$selectInput.setAttribute("capture", "camera");
      }
    } else if (this.accept === "video") {
      this.$selectInput.setAttribute("accept", "video/*");
      if (this.capture) {
        this.$selectInput.setAttribute("capture", "camcorder");
      }
    } else if (this.accept === "audio") {
      this.$selectInput.setAttribute("accept", "aduio/*");
    } else if (this.accept === "html") {
      this.$selectInput.setAttribute("accept", "text/html");
    } else if (this.accept === "doc") {
      this.$selectInput.setAttribute("accept", "application/msword");
    } else if (this.accept === "xml") {
      this.$selectInput.setAttribute("accept", "text/xml");
    } else if (this.accept === "js") {
      this.$selectInput.setAttribute("accept", "text/javascript");
    } else if (this.accept === "json") {
      this.$selectInput.setAttribute("accept", "application/json");
    } else if (this.accept === "ppt") {
      this.$selectInput.setAttribute("accept", "application/vnd.ms-powerpoint");
    } else if (this.accept === "pdf") {
      this.$selectInput.setAttribute("accept", "application/pdf");
    }
    if (this.multiple) {
      this.$selectInput.setAttribute("multiple", "multiple");
    }
    if (this.disabled) {
      this.$el.setAttribute("disabled", "disabled");
    }
    this.$el.onclick = (e) => {
      if (this.disabled) {
        return;
      }
      this.$selectInput.click();
    };
    this.$selectInput.onchange = (e) => {
      if (this.disabled) {
        return;
      }
      let files = [...this.$selectInput.files];
      this.$selectInput.value = "";
      if (!this.append) {
        this.files = [];
      }
      let length = files.length;
      let isAllAccord = true;
      for (let i = 0; i < length; i++) {
        if (!this.judgeSuffix(files[i].name)) {
          this.error.apply(this, [Upload.ERRORTYPE.FILE_SUFFIX_ERROR, files[i]]);
          isAllAccord = false;
          break;
        }
        if (files[i].size / 1024 > this.maxSize && this.maxSize > 0) {
          this.error.apply(this, [Upload.ERRORTYPE.FILE_MAXSIZE_ERROR, files[i]]);
          isAllAccord = false;
          break;
        }
        if (files[i].size / 1024 < this.minSize && this.minSize > 0) {
          this.error.apply(this, [Upload.ERRORTYPE.FILE_MINSIZE_ERROR, files[i]]);
          isAllAccord = false;
          break;
        }
        if (this.files.length + length > this.maxLength && this.maxLength > 0) {
          this.error.apply(this, [Upload.ERRORTYPE.FILE_MAXLENGTH_ERROR]);
          isAllAccord = false;
          break;
        }
      }
      if (!isAllAccord) {
        return;
      }
      if (this.files.length + length < this.minLength && this.minLength > 0) {
        this.error.apply(this, [Upload.ERRORTYPE.FILE_MINLENGTH_ERROR]);
        return;
      }
      this.files = [...this.files, ...files];
      this.select.apply(this, [[...this.files], { ...this.extraData }]);
    };
    this.ready.apply(this, [this]);
  }
  getFiles() {
    return {
      files: [...this.files],
      extraData: { ...this.extraData }
    };
  }
  clear() {
    this.files = [];
    this.$selectInput.value = "";
    this.select.apply(this, [[...this.files], { ...this.extraData }]);
  }
  setDisabled() {
    this.disabled = true;
    this.$el.setAttribute("disabled", "disabled");
  }
  setEnabled() {
    this.disabled = false;
    this.$el.removeAttribute("disabled");
  }
}
Upload.ERRORTYPE = {
  FILE_SUFFIX_ERROR: "suffixError",
  FILE_MAXSIZE_ERROR: "maxSizeError",
  FILE_MINSIZE_ERROR: "minSizeError",
  FILE_MAXLENGTH_ERROR: "maxLengthError",
  FILE_MINLENGTH_ERROR: "minLengthError"
};
const Upload$1 = Upload;
Upload$1.install = (app) => {
  app.directive("upload", {
    mounted(el, binding) {
      let options = {};
      if (obj$1.common.isObject(binding.value)) {
        Object.assign(options, binding.value);
      }
      if (obj$1.common.isObject(binding.modifiers)) {
        Object.assign(options, binding.modifiers);
      }
      let upload = new Upload$1(el, options);
      upload.init();
    }
  });
};
class Px {
  constructor(element2, options) {
    this.$el = element2;
    options = obj$1.common.isObject(options) ? options : {};
    this.attrName = options.attrName;
    this.isAfter = options.after;
    this.isBefore = options.before;
    this.hasInit = false;
  }
  handle() {
    let dpr = Math.round(window.devicePixelRatio || 1);
    let value = Number((1 / dpr).toFixed(2));
    if (this.isBefore || this.isAfter) {
      let guid = this.createGuid();
      let className = `mvi-directives-px_${guid}`;
      obj$1.element.addClass(this.$el, className);
      let style = document.createElement("style");
      style.type = "text/css";
      if (this.isBefore) {
        style.innerHTML = `.${className}::before {${this.attrName}:${value}px !important;}`;
      }
      if (this.isAfter) {
        style.innerHTML = `.${className}::after {${this.attrName}:${value}px !important;}`;
      }
      document.querySelector("head").appendChild(style);
    } else {
      this.$el.style.setProperty(this.attrName, value + "px", "important");
    }
  }
  createGuid() {
    let guid = obj$1.data.get(document.body, "mvi-directives-px-guid") || 0;
    guid++;
    obj$1.data.set(document.body, "mvi-directives-px-guid", guid);
    return guid;
  }
  init() {
    if (this.hasInit) {
      return;
    }
    this.hasInit = true;
    if (!obj$1.element.isElement(this.$el)) {
      throw new TypeError("The bound element is not a node element");
    }
    if (typeof this.attrName != "string" || !this.attrName) {
      throw new Error("The attribute name is not set");
    }
    if (typeof this.isAfter != "boolean") {
      this.isAfter = false;
    }
    if (typeof this.isBefore != "boolean") {
      this.isBefore = false;
    }
    this.handle();
  }
}
const Px$1 = Px;
Px$1.install = (app) => {
  app.directive("px", {
    mounted(el, binding) {
      let options = {};
      if (obj$1.common.isObject(binding.value)) {
        Object.assign(options, binding.value);
      }
      if (obj$1.common.isObject(binding.modifiers)) {
        Object.assign(options, binding.modifiers);
      }
      if (binding.arg) {
        options.attrName = binding.arg;
      }
      let px = new Px$1(el, options);
      px.init();
    }
  });
};
class Ripple {
  constructor(element2, options) {
    this.$el = element2;
    options = obj$1.common.isObject(options) ? options : {};
    this.color = options.color;
    this.duration = options.duration;
    this.finalOpacity = options.finalOpacity;
    this.initialOpacity = options.initialOpacity;
    this.delay = options.delay;
    this.disabled = options.disabled;
    this.hasInit = false;
    this.guid = this.createGuid();
    this.rippleContainers = [];
  }
  endDeal(rippleContainer) {
    const rippleUp = obj$1.data.get(rippleContainer, "ripple-up");
    const rippleAnimationEnd = obj$1.data.get(rippleContainer, "ripple-animation-end");
    if (rippleUp && rippleAnimationEnd) {
      const destroyDuration = 100;
      const rippleEls = obj$1.element.children(rippleContainer);
      const rippleEl = rippleEls[0];
      rippleEl.style.transition = `opacity ${destroyDuration}ms ease-in-out`;
      rippleEl.offsetWidth;
      rippleEl.style.opacity = 0;
      setTimeout(() => {
        this.rippleContainers = this.rippleContainers.filter((el) => {
          return el != rippleContainer;
        });
        rippleContainer.remove();
      }, destroyDuration);
    }
  }
  createRippleElement(pageX, pageY) {
    const rect = obj$1.element.getElementBounding(this.$el);
    const { x1, x2, y1, y2, r } = this.getRadius(pageX, pageY, rect);
    const el = obj$1.element.string2dom("<div></div>");
    el.style.width = r * 2 + "px";
    el.style.height = r * 2 + "px";
    el.style.position = "absolute";
    el.style.background = this.color;
    el.style.top = y1 - r + "px";
    el.style.left = x1 - r + "px";
    el.style.zIndex = 1;
    el.style.borderRadius = "50%";
    el.style.transform = "scale(0)";
    el.style.opacity = this.initialOpacity;
    el.style.transition = `transform ${this.duration}ms cubic-bezier(0, 0.5, 0.25, 1), opacity ${this.duration}ms cubic-bezier(0.0, 0, 0.2, 1)`;
    return el;
  }
  createRippleContainer() {
    const el = obj$1.element.string2dom("<div></div>");
    el.style.position = "absolute";
    el.style.left = "0px";
    el.style.top = "0px";
    el.style.width = obj$1.element.getCssStyle(this.$el, "width");
    el.style.height = obj$1.element.getCssStyle(this.$el, "height");
    el.style.background = "transparent";
    el.style.borderRadius = obj$1.element.getCssStyle(this.$el, "border-radius");
    el.style.overflow = "hidden";
    el.style.pointerEvents = "none";
    el.style.transform = "rotate(0deg)";
    return el;
  }
  getRadius(pageX, pageY, rect) {
    const x1 = pageX - rect.left;
    const y1 = pageY - rect.top;
    const x2 = this.$el.offsetWidth - x1;
    const y2 = this.$el.offsetHeight - y1;
    const topLeft = Math.sqrt(x1 * x1 + y1 * y1);
    const topRight = Math.sqrt(x2 * x2 + y1 * y1);
    const bottomLeft = Math.sqrt(x1 * x1 + y2 * y2);
    const bottomRight = Math.sqrt(x2 * x2 + y2 * y2);
    return {
      r: Math.round(Math.max(topLeft, topRight, bottomLeft, bottomRight)),
      x1,
      x2,
      y1,
      y2
    };
  }
  createGuid() {
    let guid = obj$1.data.get(document.documentElement, "mvi-directives-ripple-guid") || 0;
    guid++;
    obj$1.data.set(document.documentElement, "mvi-directives-ripple-guid", guid);
    return guid;
  }
  init() {
    if (this.hasInit) {
      return;
    }
    this.hasInit = true;
    if (!obj$1.element.isElement(this.$el)) {
      throw new TypeError("The bound element is not a node element");
    }
    if (typeof this.color != "string") {
      this.color = "#9f9f9f";
    }
    if (!obj$1.number.isNumber(this.duration)) {
      this.duration = 600;
    }
    if (!obj$1.number.isNumber(this.finalOpacity)) {
      this.finalOpacity = 0.1;
    }
    if (!obj$1.number.isNumber(this.initialOpacity)) {
      this.initialOpacity = 0.1;
    }
    if (!obj$1.number.isNumber(this.delay)) {
      this.delay = 80;
    }
    if (typeof this.disabled != "boolean") {
      this.disabled = false;
    }
    if (obj$1.element.getCssStyle(this.$el, "position") != "relative" && obj$1.element.getCssStyle(this.$el, "position") != "absolute" && obj$1.element.getCssStyle(this.$el, "position") != "fixed") {
      this.$el.style.position = "relative";
    }
    const downFn = (pageX, pageY) => {
      if (this.disabled) {
        return;
      }
      const rippleContainer = this.createRippleContainer();
      const rippleEl = this.createRippleElement(pageX, pageY);
      this.$el.appendChild(rippleContainer);
      rippleContainer.appendChild(rippleEl);
      this.rippleContainers.push(rippleContainer);
      setTimeout(() => {
        rippleEl.style.transform = "scale(1)";
        rippleEl.style.opacity = this.finalOpacity;
        setTimeout(() => {
          obj$1.data.set(rippleContainer, "ripple-animation-end", true);
          this.endDeal(rippleContainer);
        }, this.duration);
      }, this.delay);
    };
    const upFn = () => {
      if (this.rippleContainers.length) {
        this.rippleContainers.forEach((rippleContainer) => {
          obj$1.data.set(rippleContainer, "ripple-up", true);
          this.endDeal(rippleContainer);
        });
      }
    };
    obj$1.event.on(this.$el, "mousedown.ripple", (e) => {
      downFn(e.pageX, e.pageY);
    });
    obj$1.event.on(this.$el, "touchstart.ripple", (e) => {
      downFn(e.targetTouches[0].pageX, e.targetTouches[0].pageY);
    });
    obj$1.event.on(document.documentElement, `mouseup.ripple_${this.guid}`, upFn);
    obj$1.event.on(this.$el, `touchend.ripple`, upFn);
  }
  destroy() {
    obj$1.event.off(document.documentElement, `mouseup.ripple_${this.guid}`);
  }
}
const Ripple$1 = Ripple;
Ripple$1.install = (app) => {
  app.directive("ripple", {
    mounted(el, binding) {
      let options = {};
      if (obj$1.common.isObject(binding.value)) {
        Object.assign(options, binding.value);
      }
      let ripple = new Ripple$1(el, options);
      ripple.init();
      obj$1.data.set(el, "directive:ripple", ripple);
    },
    beforeUnmount(el) {
      let ripple = obj$1.data.get(el, "directive:ripple");
      if (ripple) {
        ripple.destroy();
      }
    }
  });
};
const icon_vue_vue_type_style_index_0_scoped_cf01b528_lang = "";
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$17 = {
  name: "m-icon",
  props: {
    type: {
      type: String,
      default: ""
    },
    spin: {
      type: Boolean,
      default: false
    },
    url: {
      type: String,
      default: null
    },
    size: {
      type: String,
      default: null
    },
    color: {
      type: String,
      default: null
    }
  },
  computed: {
    iconStyle() {
      let style = {};
      if (this.url) {
        style.backgroundImage = "url(" + this.url + ")";
        if (this.size) {
          style.width = this.size;
          style.height = this.size;
        }
      } else {
        if (this.size) {
          style.fontSize = this.size;
        }
        if (this.color) {
          style.color = this.color;
        }
      }
      return style;
    }
  }
};
function _sfc_render$17(_ctx, _cache, $props, $setup, $data, $options) {
  return $props.url ? (openBlock(), createElementBlock("i", {
    key: 0,
    class: normalizeClass(["mvi-icon-url", $props.spin ? "spin" : ""]),
    style: normalizeStyle($options.iconStyle)
  }, null, 6)) : (openBlock(), createElementBlock("i", {
    key: 1,
    class: normalizeClass(["mvi-icon", "icon-" + $props.type, $props.spin ? "spin" : ""]),
    style: normalizeStyle($options.iconStyle)
  }, null, 6));
}
const Icon = /* @__PURE__ */ _export_sfc(_sfc_main$17, [["render", _sfc_render$17], ["__scopeId", "data-v-cf01b528"]]);
Icon.install = (app) => {
  app.component(Icon.name, Icon);
};
const button_vue_vue_type_style_index_0_scoped_5d238045_lang = "";
const _sfc_main$16 = {
  name: "m-button",
  props: {
    type: {
      type: String,
      default: "default",
      validator(value) {
        return ["default", "info", "success", "error", "warn", "primary"].includes(value);
      }
    },
    size: {
      type: String,
      default: "medium",
      validator(value) {
        return ["mini", "small", "medium", "large"].includes(value);
      }
    },
    disabled: {
      type: Boolean,
      default: false
    },
    nativeType: {
      type: String,
      default: "button"
    },
    loading: {
      type: Boolean,
      default: false
    },
    loadText: {
      type: String,
      default: "loading..."
    },
    block: {
      type: Boolean,
      default: false
    },
    tag: {
      type: String,
      default: "button"
    },
    plain: {
      type: Boolean,
      default: false
    },
    color: {
      type: String,
      default: null
    },
    subColor: {
      type: String,
      default: null
    },
    round: {
      type: Boolean,
      default: false
    },
    square: {
      type: Boolean,
      default: false
    },
    active: {
      type: Boolean,
      default: true
    },
    loadIcon: {
      type: [String, Object],
      default: function() {
        return {
          type: "load-e",
          spin: true
        };
      }
    }
  },
  computed: {
    parseIcon() {
      return (param) => {
        let icon = {
          spin: false,
          type: null,
          url: null,
          color: null,
          size: null
        };
        if (obj$1.common.isObject(param)) {
          if (typeof param.spin == "boolean") {
            icon.spin = param.spin;
          }
          if (typeof param.type == "string") {
            icon.type = param.type;
          }
          if (typeof param.url == "string") {
            icon.url = param.url;
          }
          if (typeof param.color == "string") {
            icon.color = param.color;
          }
          if (typeof param.size == "string") {
            icon.size = param.size;
          }
        } else if (typeof param == "string") {
          icon.type = param;
        }
        return icon;
      };
    },
    btnStyle() {
      let obj2 = {};
      if (this.plain) {
        if (this.color) {
          obj2.color = this.color;
          obj2.borderColor = this.color;
          obj2.background = this.subColor || "#fff";
        }
      } else {
        if (this.color) {
          obj2.background = this.color;
          obj2.borderColor = this.color;
          obj2.color = this.subColor || "#fff";
        }
      }
      return obj2;
    },
    btnClass() {
      let cls = ["mvi-button"];
      if (this.type) {
        cls.push(this.type);
      }
      if (this.size) {
        cls.push(this.size);
      }
      if (this.round) {
        cls.push("round");
      } else if (this.square) {
        cls.push("square");
      }
      if (this.block) {
        cls.push("block");
      }
      if (this.plain) {
        cls.push("plain");
      }
      if (this.active && !this.disabled) {
        cls.push("active");
      }
      if (this.loading) {
        cls.push("loading");
      }
      return cls;
    }
  },
  components: {
    Button: {
      render() {
        let attrs = {};
        if (this.$parent.tag.toLocaleUpperCase() == "BUTTON") {
          attrs.type = this.$parent.nativeType;
        }
        return h(this.$parent.tag, attrs, {
          default: this.$slots.default
        });
      }
    },
    Icon
  }
};
const _hoisted_1$P = {
  key: 0,
  class: "mvi-button-load-text"
};
function _sfc_render$16(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_Button = resolveComponent("Button", true);
  return openBlock(), createBlock(_component_Button, {
    disabled: $props.disabled || null,
    class: normalizeClass($options.btnClass),
    style: normalizeStyle($options.btnStyle)
  }, {
    default: withCtx(() => [
      $props.loading && _ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }, void 0, true) : $props.loading ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        createVNode(_component_Icon, {
          type: $options.parseIcon($props.loadIcon).type,
          color: $options.parseIcon($props.loadIcon).color,
          url: $options.parseIcon($props.loadIcon).url,
          spin: $options.parseIcon($props.loadIcon).spin,
          size: $options.parseIcon($props.loadIcon).size
        }, null, 8, ["type", "color", "url", "spin", "size"]),
        $props.loadText ? (openBlock(), createElementBlock("span", _hoisted_1$P, toDisplayString($props.loadText), 1)) : createCommentVNode("", true)
      ], 64)) : renderSlot(_ctx.$slots, "default", { key: 2 }, void 0, true)
    ]),
    _: 3
  }, 8, ["disabled", "class", "style"]);
}
const Button = /* @__PURE__ */ _export_sfc(_sfc_main$16, [["render", _sfc_render$16], ["__scopeId", "data-v-5d238045"]]);
Button.install = (app) => {
  app.component(Button.name, Button);
};
const cell_vue_vue_type_style_index_0_scoped_06d4a735_lang = "";
const _sfc_main$15 = {
  name: "m-cell",
  props: {
    icon: {
      type: [String, Object],
      default: null
    },
    title: {
      type: String,
      default: null
    },
    content: {
      type: String,
      default: null
    },
    label: {
      type: String,
      default: null
    },
    border: {
      type: Boolean,
      default: null
    },
    arrow: {
      type: [String, Object],
      default: null
    },
    active: {
      type: Boolean,
      default: null
    },
    ellipsis: {
      type: [Boolean, Number],
      default: null
    },
    noWrap: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    parseIcon() {
      return (param) => {
        let icon = {
          spin: false,
          type: null,
          url: null,
          color: null,
          size: null
        };
        if (obj$1.common.isObject(param)) {
          if (typeof param.spin == "boolean") {
            icon.spin = param.spin;
          }
          if (typeof param.type == "string") {
            icon.type = param.type;
          }
          if (typeof param.url == "string") {
            icon.url = param.url;
          }
          if (typeof param.color == "string") {
            icon.color = param.color;
          }
          if (typeof param.size == "string") {
            icon.size = param.size;
          }
        } else if (typeof param == "string") {
          icon.type = param;
        }
        return icon;
      };
    },
    cmpActive() {
      if (typeof this.active == "boolean") {
        return this.active;
      }
      if (this.$parent.$options.name == "m-cell-group" && typeof this.$parent.active == "boolean") {
        return this.$parent.active;
      }
      return true;
    },
    cmpBorder() {
      if (typeof this.border == "boolean") {
        return this.border;
      }
      if (typeof this.$parent.border == "boolean") {
        return this.$parent.border;
      }
      return false;
    },
    labelTextStyle() {
      let style = {};
      if (this.ellipsis) {
        style.display = "-webkit-box";
        style.textOverflow = "ellipsis";
        style.webkitBoxOrient = "vertical";
        style.overflow = "hidden";
        if (typeof this.ellipsis == "boolean") {
          style.webkitLineClamp = 3;
        } else {
          style.webkitLineClamp = this.ellipsis;
        }
      }
      return style;
    },
    cellClass() {
      let cls = ["mvi-cell"];
      if (this.cmpBorder) {
        cls.push("border");
      }
      if (this.cmpActive) {
        cls.push("active");
      }
      return cls;
    }
  },
  components: {
    Icon
  }
};
const _hoisted_1$O = { class: "mvi-cell-item" };
const _hoisted_2$H = ["textContent"];
const _hoisted_3$B = ["textContent"];
const _hoisted_4$r = ["textContent"];
function _sfc_render$15(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass($options.cellClass)
  }, [
    createElementVNode("div", _hoisted_1$O, [
      $options.parseIcon($props.icon).type || $options.parseIcon($props.icon).url ? (openBlock(), createBlock(_component_Icon, {
        key: 0,
        class: "mvi-cell-icon",
        type: $options.parseIcon($props.icon).type,
        url: $options.parseIcon($props.icon).url,
        spin: $options.parseIcon($props.icon).spin,
        size: $options.parseIcon($props.icon).size,
        color: $options.parseIcon($props.icon).color
      }, null, 8, ["type", "url", "spin", "size", "color"])) : createCommentVNode("", true),
      createElementVNode("div", {
        class: normalizeClass(["mvi-cell-title", $props.noWrap ? "nowrap" : ""])
      }, [
        _ctx.$slots.title ? renderSlot(_ctx.$slots, "title", { key: 0 }, void 0, true) : (openBlock(), createElementBlock("span", {
          key: 1,
          textContent: toDisplayString($props.title)
        }, null, 8, _hoisted_2$H))
      ], 2),
      _ctx.$slots.content || $props.content ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(["mvi-cell-content", $props.noWrap ? "nowrap" : ""])
      }, [
        _ctx.$slots.content ? renderSlot(_ctx.$slots, "content", { key: 0 }, void 0, true) : $props.content ? (openBlock(), createElementBlock("span", {
          key: 1,
          textContent: toDisplayString($props.content)
        }, null, 8, _hoisted_3$B)) : createCommentVNode("", true)
      ], 2)) : createCommentVNode("", true),
      $options.parseIcon($props.arrow).type || $options.parseIcon($props.arrow).url ? (openBlock(), createBlock(_component_Icon, {
        key: 2,
        class: "mvi-cell-arrow",
        type: $options.parseIcon($props.arrow).type,
        url: $options.parseIcon($props.arrow).url,
        spin: $options.parseIcon($props.arrow).spin,
        size: $options.parseIcon($props.arrow).size,
        color: $options.parseIcon($props.arrow).color
      }, null, 8, ["type", "url", "spin", "size", "color"])) : createCommentVNode("", true)
    ]),
    $props.label || _ctx.$slots.label ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "mvi-cell-label",
      style: normalizeStyle($options.labelTextStyle)
    }, [
      _ctx.$slots.label ? renderSlot(_ctx.$slots, "label", { key: 0 }, void 0, true) : $props.label ? (openBlock(), createElementBlock("span", {
        key: 1,
        textContent: toDisplayString($props.label)
      }, null, 8, _hoisted_4$r)) : createCommentVNode("", true)
    ], 4)) : createCommentVNode("", true)
  ], 2);
}
const Cell = /* @__PURE__ */ _export_sfc(_sfc_main$15, [["render", _sfc_render$15], ["__scopeId", "data-v-06d4a735"]]);
Cell.install = (app) => {
  app.component(Cell.name, Cell);
};
const cellGroup_vue_vue_type_style_index_0_scoped_bad36ebb_lang = "";
const _sfc_main$14 = {
  name: "m-cell-group",
  props: {
    title: {
      type: String,
      default: null
    },
    border: {
      type: Boolean,
      default: true
    },
    active: {
      type: Boolean,
      default: true
    }
  }
};
const _hoisted_1$N = ["textContent"];
function _sfc_render$14(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["mvi-cell-group", $props.border ? "border" : ""])
  }, [
    $props.title ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "mvi-cell-group-title",
      textContent: toDisplayString($props.title)
    }, null, 8, _hoisted_1$N)) : createCommentVNode("", true),
    renderSlot(_ctx.$slots, "default", {}, void 0, true)
  ], 2);
}
const CellGroup = /* @__PURE__ */ _export_sfc(_sfc_main$14, [["render", _sfc_render$14], ["__scopeId", "data-v-bad36ebb"]]);
CellGroup.install = (app) => {
  app.component(CellGroup.name, CellGroup);
};
const navbar_vue_vue_type_style_index_0_scoped_774307d7_lang = "";
const _sfc_main$13 = {
  name: "m-navbar",
  props: {
    title: {
      type: String,
      default: null
    },
    leftText: {
      type: String,
      default: null
    },
    rightText: {
      type: String,
      default: null
    },
    leftIcon: {
      type: [String, Object],
      default: null
    },
    rightIcon: {
      type: [String, Object],
      default: null
    },
    fixed: {
      type: Boolean,
      default: false
    },
    border: {
      type: Boolean,
      default: false
    },
    zIndex: {
      type: Number,
      default: 400
    }
  },
  emits: ["left-click", "right-click", "title-click"],
  computed: {
    showLeft() {
      return this.parseIcon(this.leftIcon).type || this.parseIcon(this.leftIcon).url || this.$slots.left || this.leftText;
    },
    showRight() {
      return this.parseIcon(this.rightIcon).type || this.parseIcon(this.rightIcon).url || this.$slots.right || this.rightText;
    },
    leftStyle() {
      let style = {};
      if (this.title || this.$slots.title) {
        style.width = "20%";
      } else if (this.showRight) {
        style.width = "50%";
      } else {
        style.width = "100%";
      }
      return style;
    },
    rightStyle() {
      let style = {};
      if (this.title || this.$slots.title) {
        style.width = "20%";
      } else if (this.showLeft) {
        style.width = "50%";
      } else {
        style.width = "100%";
      }
      return style;
    },
    parseIcon() {
      return (param) => {
        let icon = {
          spin: false,
          type: null,
          url: null,
          color: null,
          size: null
        };
        if (obj$1.common.isObject(param)) {
          if (typeof param.spin == "boolean") {
            icon.spin = param.spin;
          }
          if (typeof param.type == "string") {
            icon.type = param.type;
          }
          if (typeof param.url == "string") {
            icon.url = param.url;
          }
          if (typeof param.color == "string") {
            icon.color = param.color;
          }
          if (typeof param.size == "string") {
            icon.size = param.size;
          }
        } else if (typeof param == "string") {
          icon.type = param;
        }
        return icon;
      };
    },
    navbarClass() {
      let cls = ["mvi-navbar"];
      if (this.fixed) {
        cls.push("fixed");
      }
      if (this.border) {
        cls.push("border");
      }
      return cls;
    },
    centerStyle() {
      let style = {};
      if (this.showLeft || this.showRight) {
        style.width = "60%";
      } else {
        style.width = "100%";
      }
      return style;
    }
  },
  components: {
    Icon
  },
  methods: {
    leftClick() {
      this.$emit("left-click");
    },
    rightClick() {
      this.$emit("right-click");
    },
    titleClick() {
      this.$emit("title-click");
    }
  }
};
const _hoisted_1$M = ["textContent"];
const _hoisted_2$G = { class: "mvi-navbar-title" };
const _hoisted_3$A = ["textContent"];
const _hoisted_4$q = ["textContent"];
function _sfc_render$13(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass($options.navbarClass),
    style: normalizeStyle("z-index:" + ($props.fixed ? $props.zIndex : ""))
  }, [
    $options.showLeft ? (openBlock(), createElementBlock("div", {
      key: 0,
      onClick: _cache[0] || (_cache[0] = (...args) => $options.leftClick && $options.leftClick(...args)),
      class: "mvi-navbar-left",
      style: normalizeStyle($options.leftStyle)
    }, [
      _ctx.$slots.left ? renderSlot(_ctx.$slots, "left", { key: 0 }, void 0, true) : createCommentVNode("", true),
      ($options.parseIcon($props.leftIcon).type || $options.parseIcon($props.leftIcon).url) && !_ctx.$slots.left ? (openBlock(), createBlock(_component_Icon, {
        key: 1,
        class: normalizeClass([$props.leftText ? "mvi-navbar-left-icon" : ""]),
        type: $options.parseIcon($props.leftIcon).type,
        url: $options.parseIcon($props.leftIcon).url,
        spin: $options.parseIcon($props.leftIcon).spin,
        size: $options.parseIcon($props.leftIcon).size,
        color: $options.parseIcon($props.leftIcon).color
      }, null, 8, ["class", "type", "url", "spin", "size", "color"])) : createCommentVNode("", true),
      $props.leftText && !_ctx.$slots.left ? (openBlock(), createElementBlock("span", {
        key: 2,
        class: "mvi-navbar-left-text",
        textContent: toDisplayString($props.leftText)
      }, null, 8, _hoisted_1$M)) : createCommentVNode("", true)
    ], 4)) : createCommentVNode("", true),
    _ctx.$slots.title || $props.title ? (openBlock(), createElementBlock("div", {
      key: 1,
      onClick: _cache[1] || (_cache[1] = (...args) => $options.titleClick && $options.titleClick(...args)),
      class: "mvi-navbar-center",
      style: normalizeStyle($options.centerStyle)
    }, [
      createElementVNode("div", _hoisted_2$G, [
        _ctx.$slots.title ? renderSlot(_ctx.$slots, "title", { key: 0 }, void 0, true) : $props.title ? (openBlock(), createElementBlock("span", {
          key: 1,
          textContent: toDisplayString($props.title)
        }, null, 8, _hoisted_3$A)) : createCommentVNode("", true)
      ])
    ], 4)) : createCommentVNode("", true),
    $options.showRight ? (openBlock(), createElementBlock("div", {
      key: 2,
      onClick: _cache[2] || (_cache[2] = (...args) => $options.rightClick && $options.rightClick(...args)),
      class: "mvi-navbar-right",
      style: normalizeStyle($options.rightStyle)
    }, [
      _ctx.$slots.right ? renderSlot(_ctx.$slots, "right", { key: 0 }, void 0, true) : createCommentVNode("", true),
      $props.rightText && !_ctx.$slots.right ? (openBlock(), createElementBlock("span", {
        key: 1,
        class: "mvi-navbar-right-text",
        textContent: toDisplayString($props.rightText)
      }, null, 8, _hoisted_4$q)) : createCommentVNode("", true),
      ($options.parseIcon($props.rightIcon).type || $options.parseIcon($props.rightIcon).url) && !_ctx.$slots.right ? (openBlock(), createBlock(_component_Icon, {
        key: 2,
        class: normalizeClass([$props.rightText ? "mvi-navbar-right-icon" : ""]),
        type: $options.parseIcon($props.rightIcon).type,
        url: $options.parseIcon($props.rightIcon).url,
        spin: $options.parseIcon($props.rightIcon).spin,
        size: $options.parseIcon($props.rightIcon).size,
        color: $options.parseIcon($props.rightIcon).color
      }, null, 8, ["class", "type", "url", "spin", "size", "color"])) : createCommentVNode("", true)
    ], 4)) : createCommentVNode("", true)
  ], 6);
}
const Navbar = /* @__PURE__ */ _export_sfc(_sfc_main$13, [["render", _sfc_render$13], ["__scopeId", "data-v-774307d7"]]);
Navbar.install = (app) => {
  app.component(Navbar.name, Navbar);
};
const badge_vue_vue_type_style_index_0_scoped_094b2095_lang = "";
const _sfc_main$12 = {
  name: "m-badge",
  props: {
    content: {
      type: [String, Number],
      default: null
    },
    placement: {
      type: String,
      default: "top-right",
      validator(value) {
        return ["top-right", "top-left", "bottom-left", "bottom-right"].includes(value);
      }
    },
    dot: {
      type: Boolean,
      default: false
    },
    show: {
      type: Boolean,
      default: true
    },
    offset: {
      type: Array,
      default: function() {
        return null;
      }
    },
    background: {
      type: String,
      default: null
    },
    color: {
      type: String,
      default: null
    }
  },
  computed: {
    badgeStyle() {
      let style = {};
      if (this.background) {
        style.background = this.background;
      }
      if (this.color) {
        style.color = this.color;
      }
      if (this.offset) {
        if (this.offset[0]) {
          if (this.placement == "top-right" || this.placement == "bottom-right") {
            style.marginRight = this.offset[0];
          } else if (this.placement == "top-left" || this.placement == "bottom-left") {
            style.marginLeft = this.offset[0];
          }
        }
        if (this.offset[1]) {
          if (this.placement == "top-right" || this.placement == "top-left") {
            style.marginTop = this.offset[1];
          } else if (this.placement == "bottom-right" || this.placement == "bottom-left") {
            style.marginBottom = this.offset[1];
          }
        }
      }
      return style;
    },
    badgeShow() {
      const badgeExist = obj$1.number.isNumber(this.content) || this.content;
      if (badgeExist && this.show) {
        return true;
      }
      return false;
    }
  }
};
const _hoisted_1$L = { class: "mvi-badge" };
const _hoisted_2$F = ["data-placement"];
const _hoisted_3$z = ["data-placement"];
function _sfc_render$12(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$L, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true),
    $props.dot && $props.show ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: "mvi-badge-el mvi-badge-dot",
      "data-placement": $props.placement,
      style: normalizeStyle($options.badgeStyle)
    }, null, 12, _hoisted_2$F)) : $options.badgeShow ? (openBlock(), createElementBlock("span", {
      key: 1,
      class: "mvi-badge-el",
      "data-placement": $props.placement,
      style: normalizeStyle($options.badgeStyle)
    }, toDisplayString($props.content), 13, _hoisted_3$z)) : createCommentVNode("", true)
  ]);
}
const Badge = /* @__PURE__ */ _export_sfc(_sfc_main$12, [["render", _sfc_render$12], ["__scopeId", "data-v-094b2095"]]);
Badge.install = (app) => {
  app.component(Badge.name, Badge);
};
const tabbarItem_vue_vue_type_style_index_0_scoped_d638e245_lang = "";
const _sfc_main$11 = {
  name: "m-tabbar-item",
  inject: ["tabbar"],
  props: {
    route: {
      type: [String, Object],
      default: null
    },
    icon: {
      type: [String, Object],
      default: null
    },
    name: {
      type: String,
      default: null
    },
    value: {
      type: [Object, Number, String, Array],
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    badge: {
      type: Object,
      default: null
    }
  },
  computed: {
    parseIcon() {
      return (param) => {
        let icon = {
          spin: false,
          type: null,
          url: null,
          color: null,
          size: null
        };
        if (obj$1.common.isObject(param)) {
          if (typeof param.spin == "boolean") {
            icon.spin = param.spin;
          }
          if (typeof param.type == "string") {
            icon.type = param.type;
          }
          if (typeof param.url == "string") {
            icon.url = param.url;
          }
          if (typeof param.color == "string") {
            icon.color = param.color;
          }
          if (typeof param.size == "string") {
            icon.size = param.size;
          }
        } else if (typeof param == "string") {
          icon.type = param;
        }
        return icon;
      };
    },
    cmpClass() {
      let cls = ["mvi-tabbar-item"];
      if (obj$1.common.equal(this.value, this.tabbar.modelValue)) {
        cls.push("item-active");
      }
      if (this.tabbar.active && !this.disabled && !obj$1.common.equal(this.value, this.tabbar.modelValue)) {
        cls.push("active");
      }
      return cls;
    },
    cmpStyle() {
      let style = {};
      if (obj$1.common.equal(this.value, this.tabbar.modelValue)) {
        if (this.tabbar.activeColor) {
          style.color = this.tabbar.activeColor;
        }
      } else {
        if (this.tabbar.inactiveColor) {
          style.color = this.tabbar.inactiveColor;
        }
      }
      return style;
    },
    cmpRoute() {
      if (!this.route) {
        return null;
      }
      let route = {};
      if (typeof this.route == "string") {
        route = {
          path: this.route
        };
      } else if (obj$1.common.isObject(this.route)) {
        if (typeof this.route.path == "string" && this.route.path) {
          route.path = this.route.path;
        }
        if (typeof this.route.name == "string" && this.route.name) {
          route.name = this.route.name;
        }
        if (obj$1.common.isObject(this.route.query)) {
          route.query = this.route.query;
        } else {
          route.query = {};
        }
        if (obj$1.common.isObject(this.route.params)) {
          route.params = this.route.params;
        } else {
          route.params = {};
        }
        if (typeof this.route.replace == "boolean") {
          route.replace = this.route.replace;
        } else {
          route.replace = false;
        }
      }
      if (!route.query) {
        route.query = {};
      }
      if (!route.params) {
        route.params = {};
      }
      return route;
    }
  },
  components: {
    Icon,
    Badge
  },
  methods: {
    setActive() {
      this.tabbar.$emit("item-click", JSON.parse(JSON.stringify(this.$props)));
      if (this.disabled) {
        return;
      }
      if (obj$1.common.equal(this.tabbar.modelValue, this.value)) {
        return;
      }
      if (this.cmpRoute && this.$router && this.$router.replace && this.$router.push) {
        if (this.cmpRoute.path) {
          if (this.cmpRoute.replace) {
            this.$router.replace({
              path: this.cmpRoute.path,
              query: this.cmpRoute.query,
              params: this.cmpRoute.params
            });
          } else {
            this.$router.push({
              path: this.cmpRoute.path,
              query: this.cmpRoute.query,
              params: this.cmpRoute.params
            });
          }
        } else if (this.cmpRoute.name) {
          if (this.cmpRoute.replace) {
            this.$router.replace({
              name: this.cmpRoute.name,
              query: this.cmpRoute.query,
              params: this.cmpRoute.params
            });
          } else {
            this.$router.push({
              name: this.cmpRoute.name,
              query: this.cmpRoute.query,
              params: this.cmpRoute.params
            });
          }
        }
      }
      this.tabbar.$emit("update:modelValue", this.value);
      this.tabbar.$emit("change", JSON.parse(JSON.stringify(this.$props)));
    }
  }
};
const _hoisted_1$K = ["disabled"];
const _hoisted_2$E = { class: "mvi-tabbar-item-child" };
const _hoisted_3$y = ["textContent"];
function _sfc_render$11(_ctx, _cache, $props, $setup, $data, $options) {
  var _a, _b, _c, _d, _e, _f, _g;
  const _component_Icon = resolveComponent("Icon");
  const _component_Badge = resolveComponent("Badge");
  return openBlock(), createElementBlock("div", {
    disabled: $props.disabled || null,
    class: normalizeClass($options.cmpClass),
    style: normalizeStyle($options.cmpStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => $options.setActive && $options.setActive(...args))
  }, [
    createVNode(_component_Badge, {
      show: (_a = $props.badge) == null ? void 0 : _a.show,
      class: "mvi-tabbar-badge",
      content: (_b = $props.badge) == null ? void 0 : _b.content,
      background: (_c = $props.badge) == null ? void 0 : _c.background,
      color: (_d = $props.badge) == null ? void 0 : _d.color,
      dot: (_e = $props.badge) == null ? void 0 : _e.dot,
      placement: (_f = $props.badge) == null ? void 0 : _f.placement,
      offset: (_g = $props.badge) == null ? void 0 : _g.offset
    }, {
      default: withCtx(() => [
        createElementVNode("div", _hoisted_2$E, [
          $options.parseIcon($props.icon).type || $options.parseIcon($props.icon).url ? (openBlock(), createElementBlock("span", {
            key: 0,
            class: "mvi-tabbar-icon",
            style: normalizeStyle({ marginBottom: $props.name ? "" : "0px" })
          }, [
            createVNode(_component_Icon, {
              type: $options.parseIcon($props.icon).type,
              url: $options.parseIcon($props.icon).url,
              spin: $options.parseIcon($props.icon).spin,
              size: $options.parseIcon($props.icon).size,
              color: $options.parseIcon($props.icon).color
            }, null, 8, ["type", "url", "spin", "size", "color"])
          ], 4)) : createCommentVNode("", true),
          createElementVNode("span", {
            class: normalizeClass(["mvi-tabbar-name", $options.parseIcon($props.icon).type || $options.parseIcon($props.icon).url ? "small" : ""]),
            textContent: toDisplayString($props.name)
          }, null, 10, _hoisted_3$y)
        ])
      ]),
      _: 1
    }, 8, ["show", "content", "background", "color", "dot", "placement", "offset"])
  ], 14, _hoisted_1$K);
}
const TabbarItem = /* @__PURE__ */ _export_sfc(_sfc_main$11, [["render", _sfc_render$11], ["__scopeId", "data-v-d638e245"]]);
const tabbar_vue_vue_type_style_index_0_scoped_258fb90e_lang = "";
const _sfc_main$10 = {
  name: "m-tabbar",
  components: {
    TabbarItem
  },
  emits: ["update:modelValue", "item-click", "change"],
  provide() {
    return {
      tabbar: this
    };
  },
  props: {
    modelValue: {
      type: [Object, Number, String, Array],
      default: null
    },
    tabs: {
      type: Array,
      default: function() {
        return [];
      }
    },
    fixed: {
      type: Boolean,
      default: false
    },
    border: {
      type: Boolean,
      default: false
    },
    zIndex: {
      type: Number,
      default: 400
    },
    activeColor: {
      type: String,
      default: null
    },
    inactiveColor: {
      type: String,
      default: null
    },
    active: {
      type: Boolean,
      default: true
    },
    flex: {
      type: String,
      default: null
    },
    offset: {
      type: String,
      default: null
    }
  },
  computed: {
    tabbarItemStyle() {
      return (index) => {
        let style = {};
        if (index != 0 && this.offset) {
          style.marginLeft = this.offset;
        }
        return style;
      };
    },
    tabbarStyle() {
      let style = {};
      if (this.fixed && obj$1.number.isNumber(this.zIndex)) {
        style.zIndex = this.zIndex;
      }
      if (this.flex) {
        style.justifyContent = this.flex;
      }
      return style;
    }
  }
};
function _sfc_render$10(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TabbarItem = resolveComponent("TabbarItem");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["mvi-tabbar", $props.border ? "border" : "", $props.fixed ? "fixed" : ""]),
    style: normalizeStyle($options.tabbarStyle)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($props.tabs, (item, index) => {
      return openBlock(), createBlock(_component_TabbarItem, {
        name: item.name,
        value: item.value,
        icon: item.icon,
        disabled: item.disabled,
        badge: item.badge,
        route: item.route,
        style: normalizeStyle($options.tabbarItemStyle(index))
      }, null, 8, ["name", "value", "icon", "disabled", "badge", "route", "style"]);
    }), 256))
  ], 6);
}
const Tabbar = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["render", _sfc_render$10], ["__scopeId", "data-v-258fb90e"]]);
Tabbar.install = (app) => {
  app.component(Tabbar.name, Tabbar);
};
const image_vue_vue_type_style_index_0_scoped_b39a2f4f_lang = "";
const _sfc_main$$ = {
  name: "m-image",
  data() {
    return {
      error: false,
      loading: true,
      lazySrc: "",
      lazying: false,
      spy: null
    };
  },
  emits: ["success", "error"],
  props: {
    src: {
      type: String,
      default: ""
    },
    fit: {
      type: String,
      default: "fill",
      validator(value) {
        return ["fill", "cover", "contain", "response", "none"].includes(value);
      }
    },
    alt: {
      type: String,
      default: ""
    },
    showError: {
      type: Boolean,
      default: true
    },
    showLoading: {
      type: Boolean,
      default: true
    },
    lazyLoad: {
      type: Boolean,
      default: false
    },
    root: {
      type: String,
      default: null
    },
    loadIcon: {
      type: [String, Object],
      default: "image-alt"
    },
    errorIcon: {
      type: [String, Object],
      default: "image-error"
    },
    round: {
      type: Boolean,
      default: false
    },
    width: {
      type: String,
      default: null
    },
    height: {
      type: String,
      default: null
    }
  },
  computed: {
    parseIcon() {
      return (param) => {
        let icon = {
          spin: false,
          type: null,
          url: null,
          color: null,
          size: null
        };
        if (obj$1.common.isObject(param)) {
          if (typeof param.spin == "boolean") {
            icon.spin = param.spin;
          }
          if (typeof param.type == "string") {
            icon.type = param.type;
          }
          if (typeof param.url == "string") {
            icon.url = param.url;
          }
          if (typeof param.color == "string") {
            icon.color = param.color;
          }
          if (typeof param.size == "string") {
            icon.size = param.size;
          }
        } else if (typeof param == "string") {
          icon.type = param;
        }
        return icon;
      };
    },
    imageStyle() {
      let style = {};
      if (this.round) {
        style.borderRadius = "50%";
      }
      if (this.width) {
        style.width = this.width;
      }
      if (this.height) {
        style.height = this.height;
      }
      return style;
    },
    imgClass() {
      if (this.fit == "contain") {
        return "mvi-image-contain";
      } else if (this.fit == "cover") {
        return "mvi-image-cover";
      } else if (this.fit == "none") {
        return "mvi-image-none";
      } else if (this.fit == "response") {
        return "mvi-image-response";
      } else {
        return "mvi-image-fill";
      }
    },
    cmpSrc() {
      if (this.lazyLoad) {
        return this.lazySrc;
      } else {
        return this.src;
      }
    }
  },
  components: {
    Icon
  },
  watch: {
    cmpSrc() {
      this.loading = true;
    }
  },
  mounted() {
    if (this.lazyLoad) {
      this.lazyloadFun();
    }
  },
  methods: {
    lazyloadFun() {
      this.lazying = true;
      this.spy = new Spy$1(this.$el, {
        el: this.root,
        beforeEnter: () => {
          this.lazying = false;
          this.lazySrc = this.src;
        }
      });
      this.spy.init();
    },
    loadSuccess(e) {
      this.error = false;
      this.loading = false;
      this.$emit("success", e.target);
    },
    loadError(e) {
      this.loading = false;
      this.error = true;
      this.$emit("error", e.target);
    }
  },
  beforeUnmount() {
    if (this.spy) {
      this.spy.destroy();
    }
  }
};
const _hoisted_1$J = {
  key: 0,
  class: "mvi-image-loading"
};
const _hoisted_2$D = {
  key: 1,
  class: "mvi-image-error",
  ref: "error"
};
const _hoisted_3$x = ["src", "alt"];
function _sfc_render$$(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("div", {
    class: "mvi-image",
    style: normalizeStyle($options.imageStyle)
  }, [
    ($data.loading || $data.lazying) && $props.showLoading ? (openBlock(), createElementBlock("div", _hoisted_1$J, [
      _ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }, void 0, true) : (openBlock(), createBlock(_component_Icon, {
        key: 1,
        type: $options.parseIcon($props.loadIcon).type,
        url: $options.parseIcon($props.loadIcon).url,
        spin: $options.parseIcon($props.loadIcon).spin,
        size: $options.parseIcon($props.loadIcon).size,
        color: $options.parseIcon($props.loadIcon).color
      }, null, 8, ["type", "url", "spin", "size", "color"]))
    ])) : $data.error && $props.showError ? (openBlock(), createElementBlock("div", _hoisted_2$D, [
      _ctx.$slots.error ? renderSlot(_ctx.$slots, "error", { key: 0 }, void 0, true) : (openBlock(), createBlock(_component_Icon, {
        key: 1,
        type: $options.parseIcon($props.errorIcon).type,
        url: $options.parseIcon($props.errorIcon).url,
        spin: $options.parseIcon($props.errorIcon).spin,
        size: $options.parseIcon($props.errorIcon).size,
        color: $options.parseIcon($props.errorIcon).color
      }, null, 8, ["type", "url", "spin", "size", "color"]))
    ], 512)) : createCommentVNode("", true),
    createElementVNode("img", {
      onLoad: _cache[0] || (_cache[0] = (...args) => $options.loadSuccess && $options.loadSuccess(...args)),
      onError: _cache[1] || (_cache[1] = (...args) => $options.loadError && $options.loadError(...args)),
      src: $options.cmpSrc,
      alt: $props.showError ? "" : $props.alt,
      class: normalizeClass($options.imgClass)
    }, null, 42, _hoisted_3$x)
  ], 4);
}
const Image = /* @__PURE__ */ _export_sfc(_sfc_main$$, [["render", _sfc_render$$], ["__scopeId", "data-v-b39a2f4f"]]);
Image.install = (app) => {
  app.component(Image.name, Image);
};
const overlay_vue_vue_type_style_index_0_scoped_a0d7b0dd_lang = "";
const _sfc_main$_ = {
  name: "m-overlay",
  data() {
    return {
      overlayShow: false,
      scrollTop: 0,
      scrollLeft: 0,
      overflowX: "",
      overflowY: "",
      paddingRight: 0,
      paddingBottom: 0,
      hasHorizontalScroll: false,
      hasVerticalScroll: false,
      offsetParent: null
    };
  },
  emits: ["update:modelValue", "show", "showing", "shown", "hide", "hidding", "hidden"],
  inheritAttrs: false,
  props: {
    mountEl: {
      type: String,
      default: null
    },
    zIndex: {
      type: Number,
      default: 800
    },
    color: {
      type: String,
      default: null
    },
    modelValue: {
      type: Boolean,
      default: false
    },
    fade: {
      type: Boolean,
      default: true
    },
    timeout: {
      type: Number,
      default: 200,
      validator(value) {
        return value >= 0;
      }
    },
    closable: {
      type: Boolean,
      default: false
    },
    usePadding: {
      type: Boolean,
      default: false
    }
  },
  watch: {
    modelValue(newValue) {
      this.overlayShow = newValue;
    }
  },
  computed: {
    overlayStyle() {
      let style = {};
      if (obj$1.number.isNumber(this.zIndex)) {
        style.zIndex = this.zIndex;
      }
      if (this.color) {
        style.background = this.color;
      }
      return style;
    },
    $$el() {
      return this.$refs.overlay;
    }
  },
  mounted() {
    this.overlayShow = this.modelValue;
  },
  methods: {
    beforeEnter(el) {
      if (this.fade) {
        el.style.transition = "opacity " + this.timeout + "ms";
        el.style.webkitTransition = "opacity " + this.timeout + "ms";
      }
      this.$emit("show", el);
      if (typeof this.overlayComponentWatch == "function") {
        this.overlayComponentWatch.apply(this, ["show", el]);
      }
    },
    enter(el) {
      if (this.$$el.offsetParent) {
        this.offsetParent = this.$$el.offsetParent;
        if (obj$1.element.getScrollHeight(this.offsetParent) > this.offsetParent.clientHeight) {
          if (this.usePadding) {
            let scrollWidth = this.offsetParent.offsetWidth - this.offsetParent.clientWidth - parseFloat(obj$1.element.getCssStyle(this.offsetParent, "border-right-width")) - parseFloat(obj$1.element.getCssStyle(this.offsetParent, "border-left-width"));
            this.paddingRight = parseFloat(obj$1.element.getCssStyle(this.offsetParent, "padding-right"));
            this.offsetParent.style.setProperty("padding-right", this.paddingRight + scrollWidth + "px", "important");
          }
          this.scrollTop = obj$1.element.getScrollTop(this.offsetParent);
          this.overflowY = obj$1.element.getCssStyle(this.offsetParent, "overflow-y");
          this.offsetParent.style.setProperty("overflow-y", "hidden", "important");
          this.$$el.style.top = this.scrollTop + "px";
          this.hasVerticalScroll = true;
        }
        if (obj$1.element.getScrollWidth(this.offsetParent) > this.offsetParent.clientWidth) {
          if (this.usePadding) {
            let scrollHeight = this.offsetParent.offsetHeight - this.offsetParent.clientHeight - parseFloat(obj$1.element.getCssStyle(this.offsetParent, "border-bottom-width")) - parseFloat(obj$1.element.getCssStyle(this.offsetParent, "border-top-width"));
            this.paddingBottom = parseFloat(obj$1.element.getCssStyle(this.offsetParent, "padding-bottom"));
            this.offsetParent.style.setProperty("padding-bottom", this.paddingBottom + scrollHeight + "px", "important");
          }
          this.scrollLeft = obj$1.element.getScrollLeft(this.offsetParent);
          this.overflowX = obj$1.element.getCssStyle(this.offsetParent, "overflow-x");
          this.offsetParent.style.setProperty("overflow-x", "hidden", "important");
          this.$$el.style.left = this.scrollLeft + "px";
          this.hasHorizontalScroll = true;
        }
      }
      this.$emit("showing", el);
      if (typeof this.overlayComponentWatch == "function") {
        this.overlayComponentWatch.apply(this, ["showing", el]);
      }
    },
    afterEnter(el) {
      if (this.fade) {
        el.style.transition = "";
        el.style.webkitTransition = "";
      }
      this.$emit("shown", el);
      if (typeof this.overlayComponentWatch == "function") {
        this.overlayComponentWatch.apply(this, ["shown", el]);
      }
    },
    beforeLeave(el) {
      if (this.fade) {
        el.style.transition = "opacity " + this.timeout + "ms";
        el.style.webkitTransition = "opacity " + this.timeout + "ms";
      }
      this.$emit("hide", el);
      if (typeof this.overlayComponentWatch == "function") {
        this.overlayComponentWatch.apply(this, ["hide", el]);
      }
    },
    leave(el) {
      this.$emit("hidding", el);
      if (typeof this.overlayComponentWatch == "function") {
        this.overlayComponentWatch.apply(this, ["hidding", el]);
      }
    },
    afterLeave(el) {
      if (this.offsetParent) {
        if (this.hasVerticalScroll) {
          if (this.usePadding) {
            this.offsetParent.style.setProperty("padding-right", this.paddingRight + "px", "important");
          }
          this.offsetParent.style.setProperty("overflow-y", this.overflowY, "important");
          this.hasVerticalScroll = false;
        }
        if (this.hasHorizontalScroll) {
          if (this.usePadding) {
            this.offsetParent.style.setProperty("padding-bottom", this.paddingBottom + "px", "important");
          }
          this.offsetParent.style.setProperty("overflow-x", this.overflowX, "important");
          this.hasHorizontalScroll = false;
        }
      }
      if (this.fade) {
        el.style.transition = "";
        el.style.webkitTransition = "";
      }
      this.$emit("hidden", el);
      if (typeof this.overlayComponentWatch == "function") {
        this.overlayComponentWatch.apply(this, ["hidden", el]);
      }
    },
    closeOverlay() {
      if (this.closable) {
        this.$emit("update:modelValue", false);
      }
    }
  }
};
function _sfc_render$_(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Teleport, {
    disabled: !$props.mountEl,
    to: $props.mountEl
  }, [
    createVNode(Transition, {
      name: "mvi-overlay-fade",
      onBeforeEnter: $options.beforeEnter,
      onEnter: $options.enter,
      onAfterEnter: $options.afterEnter,
      onBeforeLeave: $options.beforeLeave,
      onLeave: $options.leave,
      onAfterLeave: $options.afterLeave
    }, {
      default: withCtx(() => [
        withDirectives(createElementVNode("div", mergeProps({
          onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.closeOverlay && $options.closeOverlay(...args), ["self"])),
          ref: "overlay",
          class: "mvi-overlay",
          style: $options.overlayStyle
        }, _ctx.$attrs), [
          renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ], 16), [
          [vShow, $data.overlayShow]
        ])
      ]),
      _: 3
    }, 8, ["onBeforeEnter", "onEnter", "onAfterEnter", "onBeforeLeave", "onLeave", "onAfterLeave"])
  ], 8, ["disabled", "to"]);
}
const Overlay = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["render", _sfc_render$_], ["__scopeId", "data-v-a0d7b0dd"]]);
Overlay.install = (app) => {
  app.component(Overlay.name, Overlay);
};
const popup_vue_vue_type_style_index_0_scoped_d8d0a44a_lang = "";
const _sfc_main$Z = {
  name: "m-popup",
  data() {
    return {
      popupShow: false,
      firstShow: false
    };
  },
  emits: ["update:modelValue", "show", "showing", "shown", "hide", "hidding", "hidden"],
  inheritAttrs: false,
  props: {
    modelValue: {
      type: Boolean,
      default: false
    },
    closable: {
      type: Boolean,
      default: false
    },
    overlayColor: {
      type: String,
      default: null
    },
    zIndex: {
      type: Number,
      default: 900
    },
    timeout: {
      type: Number,
      default: 200
    },
    placement: {
      type: String,
      default: "bottom",
      validator(value) {
        return ["left", "top", "bottom", "right"].includes(value);
      }
    },
    round: {
      type: Boolean,
      default: false
    },
    width: {
      type: String,
      default: null
    },
    showTimes: {
      type: Boolean,
      default: false
    },
    timesPlacement: {
      type: String,
      default: "top-right",
      validator(value) {
        return ["top-right", "top-left", "bottom-right", "bottom-left"].includes(value);
      }
    },
    mountEl: {
      type: String,
      default: null
    },
    usePadding: {
      type: Boolean,
      default: false
    },
    __contentPadding: {
      type: Boolean,
      default: true
    }
  },
  computed: {
    $$el() {
      return this.$refs.overlay.$$el;
    },
    show: {
      get() {
        return this.modelValue;
      },
      set(value) {
        this.$emit("update:modelValue", value);
      }
    },
    popupClass() {
      let cls = ["mvi-popup", this.placement];
      if (this.round) {
        cls.push("round");
      }
      if (this.showTimes) {
        if (this.timesPlacement == "top-right" || this.timesPlacement == "top-left") {
          cls.push("padding-top");
        } else if (this.timesPlacement == "bottom-right" || this.timesPlacement == "bottom-left") {
          cls.push("padding-bottom");
        }
      }
      return cls;
    },
    popupStyle() {
      let style = {};
      if (this.placement == "left" || this.placement == "right") {
        if (this.width) {
          style.width = this.width;
        }
      } else if (this.placement == "top" || this.placement == "bottom") {
        if (this.width) {
          style.height = this.width;
        }
      }
      if (obj$1.number.isNumber(this.zIndex)) {
        style.zIndex = this.zIndex + 10;
      }
      style.transition = "all " + this.timeout + "ms";
      return style;
    }
  },
  components: {
    Icon,
    Overlay
  },
  methods: {
    overlayShow() {
      if (!this.firstShow) {
        this.firstShow = true;
      }
      this.popupShow = true;
    },
    overlayHide() {
      this.popupShow = false;
    },
    beforeEnter(el) {
      if (obj$1.data.get(el, "mvi-popup-beforeEnter-trigger")) {
        return;
      }
      obj$1.data.set(el, "mvi-popup-beforeEnter-trigger", true);
      this.$emit("show", el);
      if (typeof this.popupComponentWatch == "function") {
        this.popupComponentWatch.apply(this, ["show", el]);
      }
    },
    enter(el) {
      if (obj$1.data.get(el, "mvi-popup-enter-trigger")) {
        return;
      }
      obj$1.data.set(el, "mvi-popup-enter-trigger", true);
      this.$emit("showing", el);
      if (typeof this.popupComponentWatch == "function") {
        this.popupComponentWatch.apply(this, ["showing", el]);
      }
    },
    afterEnter(el) {
      this.$emit("shown", el);
      if (typeof this.popupComponentWatch == "function") {
        this.popupComponentWatch.apply(this, ["shown", el]);
      }
    },
    beforeLeave(el) {
      obj$1.data.remove(el, "mvi-popup-beforeEnter-trigger");
      obj$1.data.remove(el, "mvi-popup-enter-trigger");
      this.$emit("hide", el);
      if (typeof this.popupComponentWatch == "function") {
        this.popupComponentWatch.apply(this, ["hide", el]);
      }
    },
    leave(el) {
      this.$emit("hidding", el);
      if (typeof this.popupComponentWatch == "function") {
        this.popupComponentWatch.apply(this, ["hidding", el]);
      }
    },
    afterLeave(el) {
      this.$emit("hidden", el);
      if (typeof this.popupComponentWatch == "function") {
        this.popupComponentWatch.apply(this, ["hidden", el]);
      }
    }
  }
};
function _sfc_render$Z(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_Overlay = resolveComponent("Overlay");
  return openBlock(), createBlock(_component_Overlay, {
    ref: "overlay",
    modelValue: $options.show,
    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $options.show = $event),
    onShow: $options.overlayShow,
    onHide: $options.overlayHide,
    "use-padding": $props.usePadding,
    "z-index": $props.zIndex,
    color: $props.overlayColor,
    timeout: $props.timeout,
    "mount-el": $props.mountEl,
    closable: $props.closable
  }, {
    default: withCtx(() => [
      createVNode(Transition, {
        name: "mvi-slide-" + $props.placement,
        onBeforeEnter: $options.beforeEnter,
        onEnter: $options.enter,
        onAfterEnter: $options.afterEnter,
        onBeforeLeave: $options.beforeLeave,
        onLeave: $options.leave,
        onAfterLeave: $options.afterLeave
      }, {
        default: withCtx(() => [
          $data.firstShow ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            class: $options.popupClass,
            style: $options.popupStyle
          }, _ctx.$attrs), [
            $props.showTimes ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(["mvi-popup-times", $props.timesPlacement])
            }, [
              createVNode(_component_Icon, {
                onClick: _cache[0] || (_cache[0] = ($event) => $options.show = false),
                type: "times"
              })
            ], 2)) : createCommentVNode("", true),
            createElementVNode("div", {
              class: "mvi-popup-content",
              style: normalizeStyle({ padding: $props.__contentPadding ? "" : 0 })
            }, [
              renderSlot(_ctx.$slots, "default", {}, void 0, true)
            ], 4)
          ], 16)), [
            [vShow, $data.popupShow]
          ]) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["name", "onBeforeEnter", "onEnter", "onAfterEnter", "onBeforeLeave", "onLeave", "onAfterLeave"])
    ]),
    _: 3
  }, 8, ["modelValue", "onShow", "onHide", "use-padding", "z-index", "color", "timeout", "mount-el", "closable"]);
}
const Popup = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["render", _sfc_render$Z], ["__scopeId", "data-v-d8d0a44a"]]);
Popup.install = (app) => {
  app.component(Popup.name, Popup);
};
const checkbox_vue_vue_type_style_index_0_scoped_33305a01_lang = "";
const _sfc_main$Y = {
  name: "m-checkbox",
  emits: ["update:modelValue", "change"],
  props: {
    disabled: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: [Boolean, Array],
      default: false
    },
    label: {
      type: String,
      default: null
    },
    value: {
      type: [Object, Number, String, Array],
      default: ""
    },
    round: {
      type: Boolean,
      default: false
    },
    name: {
      type: String,
      default: null
    },
    placement: {
      type: String,
      default: "right",
      validator(value) {
        return ["left", "right"].includes(value);
      }
    },
    size: {
      type: String,
      default: null
    },
    color: {
      type: String,
      default: null
    }
  },
  computed: {
    check() {
      if (typeof this.modelValue == "boolean") {
        return this.modelValue;
      } else if (Array.isArray(this.modelValue)) {
        return this.modelValue.some((item) => {
          return obj$1.common.equal(item, this.value);
        });
      } else {
        return false;
      }
    },
    itemStyle() {
      let style = {};
      if (this.color && this.check && !this.disabled) {
        style.backgroundColor = this.color;
        style.borderColor = this.color;
      }
      if (this.size) {
        style.fontSize = this.size;
      }
      return style;
    }
  },
  components: {
    Icon
  },
  methods: {
    change(event2) {
      if (Array.isArray(this.modelValue)) {
        let arr = [...this.modelValue];
        if (event2.target.checked && !this.check) {
          arr.push(this.value);
        } else if (this.check) {
          arr = arr.filter((item) => {
            return !obj$1.common.equal(item, this.value);
          });
        }
        this.$emit("update:modelValue", arr);
        this.$emit("change", arr);
      } else if (typeof this.modelValue == "boolean") {
        this.$emit("update:modelValue", event2.target.checked);
        this.$emit("change", event2.target.checked);
      }
    }
  }
};
const _hoisted_1$I = ["disabled"];
const _hoisted_2$C = ["data-placement", "textContent"];
const _hoisted_3$w = ["value", "disabled", "checked", "name"];
const _hoisted_4$p = ["data-placement", "textContent"];
function _sfc_render$Y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("label", {
    class: "mvi-checkbox",
    disabled: $props.disabled || null
  }, [
    $props.placement == "left" && $props.label ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: "mvi-checkbox-label",
      "data-placement": $props.placement,
      textContent: toDisplayString($props.label)
    }, null, 8, _hoisted_2$C)) : createCommentVNode("", true),
    createElementVNode("input", {
      onChange: _cache[0] || (_cache[0] = (...args) => $options.change && $options.change(...args)),
      value: $props.value,
      disabled: $props.disabled,
      checked: $options.check,
      type: "checkbox",
      name: $props.name
    }, null, 40, _hoisted_3$w),
    createElementVNode("span", {
      class: normalizeClass(["mvi-checkbox-item", $options.check ? "check" : "", $props.round ? "round" : ""]),
      style: normalizeStyle($options.itemStyle)
    }, [
      createVNode(_component_Icon, {
        type: "success",
        style: normalizeStyle({ opacity: this.check ? "" : 0 })
      }, null, 8, ["style"])
    ], 6),
    $props.placement == "right" && $props.label ? (openBlock(), createElementBlock("span", {
      key: 1,
      class: "mvi-checkbox-label",
      "data-placement": $props.placement,
      textContent: toDisplayString($props.label)
    }, null, 8, _hoisted_4$p)) : createCommentVNode("", true)
  ], 8, _hoisted_1$I);
}
const Checkbox = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["render", _sfc_render$Y], ["__scopeId", "data-v-33305a01"]]);
Checkbox.install = (app) => {
  app.component(Checkbox.name, Checkbox);
};
const radio_vue_vue_type_style_index_0_scoped_6d82c302_lang = "";
const _sfc_main$X = {
  name: "m-radio",
  emits: ["update:modelValue", "change"],
  props: {
    disabled: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: [Boolean, String, Number, Object],
      default: false
    },
    label: {
      type: String,
      default: null
    },
    value: {
      type: [Object, Number, String],
      default: ""
    },
    round: {
      type: Boolean,
      default: true
    },
    name: {
      type: String,
      default: null
    },
    placement: {
      type: String,
      default: "right",
      validator(value) {
        return ["left", "right"].includes(value);
      }
    },
    size: {
      type: String,
      default: null
    },
    color: {
      type: String,
      default: null
    }
  },
  computed: {
    check() {
      if (typeof this.modelValue == "boolean") {
        return this.modelValue;
      } else {
        return obj$1.common.equal(this.modelValue, this.value);
      }
    },
    itemStyle() {
      let style = {};
      if (this.color && this.check && !this.disabled) {
        style.backgroundColor = this.color;
        style.borderColor = this.color;
      }
      if (this.size) {
        style.fontSize = this.size;
      }
      return style;
    }
  },
  components: {
    Icon
  },
  methods: {
    change(event2) {
      if (typeof this.modelValue == "boolean") {
        this.$emit("update:modelValue", event2.target.checked);
        this.$emit("change", event2.target.checked);
      } else {
        if (event2.target.checked) {
          this.$emit("update:modelValue", this.value);
          this.$emit("change", this.value);
        }
      }
    }
  }
};
const _hoisted_1$H = ["disabled"];
const _hoisted_2$B = ["data-placement", "textContent"];
const _hoisted_3$v = ["value", "disabled", "checked", "name"];
const _hoisted_4$o = ["data-placement", "textContent"];
function _sfc_render$X(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("label", {
    class: "mvi-radio",
    disabled: $props.disabled || null
  }, [
    $props.placement == "left" && $props.label ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: "mvi-radio-label",
      "data-placement": $props.placement,
      textContent: toDisplayString($props.label)
    }, null, 8, _hoisted_2$B)) : createCommentVNode("", true),
    createElementVNode("input", {
      onChange: _cache[0] || (_cache[0] = (...args) => $options.change && $options.change(...args)),
      value: $props.value,
      disabled: $props.disabled,
      checked: $options.check,
      type: "radio",
      name: $props.name
    }, null, 40, _hoisted_3$v),
    createElementVNode("span", {
      class: normalizeClass(["mvi-radio-item", $options.check ? "check" : "", $props.round ? "round" : ""]),
      style: normalizeStyle($options.itemStyle)
    }, [
      createVNode(_component_Icon, {
        type: "success",
        style: normalizeStyle({ opacity: this.check ? "" : 0 })
      }, null, 8, ["style"])
    ], 6),
    $props.placement == "right" && $props.label ? (openBlock(), createElementBlock("span", {
      key: 1,
      class: "mvi-radio-label",
      "data-placement": $props.placement,
      textContent: toDisplayString($props.label)
    }, null, 8, _hoisted_4$o)) : createCommentVNode("", true)
  ], 8, _hoisted_1$H);
}
const Radio = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["render", _sfc_render$X], ["__scopeId", "data-v-6d82c302"]]);
Radio.install = (app) => {
  app.component(Radio.name, Radio);
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h2 = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
      var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
      return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
    } }, m = function(t2, e2, n2) {
      var r2 = String(t2);
      return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
    }, v = { s: m, z: function(t2) {
      var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
      return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
    }, m: function t2(e2, n2) {
      if (e2.date() < n2.date())
        return -t2(n2, e2);
      var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
      return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
    }, a: function(t2) {
      return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
    }, p: function(t2) {
      return { M: c, y: h2, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t2) {
      return void 0 === t2;
    } }, g = "en", D = {};
    D[g] = M;
    var p = function(t2) {
      return t2 instanceof b;
    }, S = function t2(e2, n2, r2) {
      var i2;
      if (!e2)
        return g;
      if ("string" == typeof e2) {
        var s2 = e2.toLowerCase();
        D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
        var u2 = e2.split("-");
        if (!i2 && u2.length > 1)
          return t2(u2[0]);
      } else {
        var a2 = e2.name;
        D[a2] = e2, i2 = a2;
      }
      return !r2 && i2 && (g = i2), i2 || !r2 && g;
    }, w = function(t2, e2) {
      if (p(t2))
        return t2.clone();
      var n2 = "object" == typeof e2 ? e2 : {};
      return n2.date = t2, n2.args = arguments, new b(n2);
    }, O = v;
    O.l = S, O.i = p, O.w = function(t2, e2) {
      return w(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
    };
    var b = function() {
      function M2(t2) {
        this.$L = S(t2.locale, null, true), this.parse(t2);
      }
      var m2 = M2.prototype;
      return m2.parse = function(t2) {
        this.$d = function(t3) {
          var e2 = t3.date, n2 = t3.utc;
          if (null === e2)
            return new Date(NaN);
          if (O.u(e2))
            return new Date();
          if (e2 instanceof Date)
            return new Date(e2);
          if ("string" == typeof e2 && !/Z$/i.test(e2)) {
            var r2 = e2.match($);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
            }
          }
          return new Date(e2);
        }(t2), this.$x = t2.x || {}, this.init();
      }, m2.init = function() {
        var t2 = this.$d;
        this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
      }, m2.$utils = function() {
        return O;
      }, m2.isValid = function() {
        return !(this.$d.toString() === l);
      }, m2.isSame = function(t2, e2) {
        var n2 = w(t2);
        return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
      }, m2.isAfter = function(t2, e2) {
        return w(t2) < this.startOf(e2);
      }, m2.isBefore = function(t2, e2) {
        return this.endOf(e2) < w(t2);
      }, m2.$g = function(t2, e2, n2) {
        return O.u(t2) ? this[e2] : this.set(n2, t2);
      }, m2.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m2.valueOf = function() {
        return this.$d.getTime();
      }, m2.startOf = function(t2, e2) {
        var n2 = this, r2 = !!O.u(e2) || e2, f2 = O.p(t2), l2 = function(t3, e3) {
          var i2 = O.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
          return r2 ? i2 : i2.endOf(a);
        }, $2 = function(t3, e3) {
          return O.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
        }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
        switch (f2) {
          case h2:
            return r2 ? l2(1, 0) : l2(31, 11);
          case c:
            return r2 ? l2(1, M3) : l2(0, M3 + 1);
          case o:
            var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
            return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
          case a:
          case d:
            return $2(v2 + "Hours", 0);
          case u:
            return $2(v2 + "Minutes", 1);
          case s:
            return $2(v2 + "Seconds", 2);
          case i:
            return $2(v2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m2.endOf = function(t2) {
        return this.startOf(t2, false);
      }, m2.$set = function(t2, e2) {
        var n2, o2 = O.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h2] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
        if (o2 === c || o2 === h2) {
          var y2 = this.clone().set(d, 1);
          y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
        } else
          l2 && this.$d[l2]($2);
        return this.init(), this;
      }, m2.set = function(t2, e2) {
        return this.clone().$set(t2, e2);
      }, m2.get = function(t2) {
        return this[O.p(t2)]();
      }, m2.add = function(r2, f2) {
        var d2, l2 = this;
        r2 = Number(r2);
        var $2 = O.p(f2), y2 = function(t2) {
          var e2 = w(l2);
          return O.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
        };
        if ($2 === c)
          return this.set(c, this.$M + r2);
        if ($2 === h2)
          return this.set(h2, this.$y + r2);
        if ($2 === a)
          return y2(1);
        if ($2 === o)
          return y2(7);
        var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
        return O.w(m3, this);
      }, m2.subtract = function(t2, e2) {
        return this.add(-1 * t2, e2);
      }, m2.format = function(t2) {
        var e2 = this, n2 = this.$locale();
        if (!this.isValid())
          return n2.invalidDate || l;
        var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h3 = function(t3, n3, i3, s3) {
          return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
        }, d2 = function(t3) {
          return O.s(s2 % 12 || 12, t3, "0");
        }, $2 = f2 || function(t3, e3, n3) {
          var r3 = t3 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        };
        return r2.replace(y, function(t3, r3) {
          return r3 || function(t4) {
            switch (t4) {
              case "YY":
                return String(e2.$y).slice(-2);
              case "YYYY":
                return O.s(e2.$y, 4, "0");
              case "M":
                return a2 + 1;
              case "MM":
                return O.s(a2 + 1, 2, "0");
              case "MMM":
                return h3(n2.monthsShort, a2, c2, 3);
              case "MMMM":
                return h3(c2, a2);
              case "D":
                return e2.$D;
              case "DD":
                return O.s(e2.$D, 2, "0");
              case "d":
                return String(e2.$W);
              case "dd":
                return h3(n2.weekdaysMin, e2.$W, o2, 2);
              case "ddd":
                return h3(n2.weekdaysShort, e2.$W, o2, 3);
              case "dddd":
                return o2[e2.$W];
              case "H":
                return String(s2);
              case "HH":
                return O.s(s2, 2, "0");
              case "h":
                return d2(1);
              case "hh":
                return d2(2);
              case "a":
                return $2(s2, u2, true);
              case "A":
                return $2(s2, u2, false);
              case "m":
                return String(u2);
              case "mm":
                return O.s(u2, 2, "0");
              case "s":
                return String(e2.$s);
              case "ss":
                return O.s(e2.$s, 2, "0");
              case "SSS":
                return O.s(e2.$ms, 3, "0");
              case "Z":
                return i2;
            }
            return null;
          }(t3) || i2.replace(":", "");
        });
      }, m2.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m2.diff = function(r2, d2, l2) {
        var $2, y2 = this, M3 = O.p(d2), m3 = w(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
          return O.m(y2, m3);
        };
        switch (M3) {
          case h2:
            $2 = D2() / 12;
            break;
          case c:
            $2 = D2();
            break;
          case f:
            $2 = D2() / 3;
            break;
          case o:
            $2 = (g2 - v2) / 6048e5;
            break;
          case a:
            $2 = (g2 - v2) / 864e5;
            break;
          case u:
            $2 = g2 / n;
            break;
          case s:
            $2 = g2 / e;
            break;
          case i:
            $2 = g2 / t;
            break;
          default:
            $2 = g2;
        }
        return l2 ? $2 : O.a($2);
      }, m2.daysInMonth = function() {
        return this.endOf(c).$D;
      }, m2.$locale = function() {
        return D[this.$L];
      }, m2.locale = function(t2, e2) {
        if (!t2)
          return this.$L;
        var n2 = this.clone(), r2 = S(t2, e2, true);
        return r2 && (n2.$L = r2), n2;
      }, m2.clone = function() {
        return O.w(this.$d, this);
      }, m2.toDate = function() {
        return new Date(this.valueOf());
      }, m2.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m2.toISOString = function() {
        return this.$d.toISOString();
      }, m2.toString = function() {
        return this.$d.toUTCString();
      }, M2;
    }(), _ = b.prototype;
    return w.prototype = _, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h2], ["$D", d]].forEach(function(t2) {
      _[t2[1]] = function(e2) {
        return this.$g(e2, t2[0], t2[1]);
      };
    }), w.extend = function(t2, e2) {
      return t2.$i || (t2(e2, b, w), t2.$i = true), w;
    }, w.locale = S, w.isDayjs = p, w.unix = function(t2) {
      return w(1e3 * t2);
    }, w.en = D[g], w.Ls = D, w.p = {}, w;
  });
})(dayjs_min);
const dayjs = dayjs_min.exports;
const loading_vue_vue_type_style_index_0_scoped_b847f63e_lang = "";
const _sfc_main$W = {
  name: "m-loading",
  props: {
    color: {
      type: String,
      default: "#bbb"
    },
    size: {
      type: String,
      default: "0.4rem"
    }
  },
  computed: {
    loadingStyle() {
      let style = {};
      style.background = this.color;
      style.width = "calc(" + this.size + "/20)";
      style.height = "calc(" + this.size + "/4)";
      style.transformOrigin = "calc(" + this.size + "/40) calc(" + this.size + "/2)";
      style.webkitTransformOrigin = "calc(" + this.size + "/40) calc(" + this.size + "/2)";
      return style;
    }
  }
};
function _sfc_render$W(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "mvi-loading",
    style: normalizeStyle({ width: $props.size, height: $props.size })
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(new Array(12), (item) => {
      return openBlock(), createElementBlock("div", {
        style: normalizeStyle($options.loadingStyle)
      }, null, 4);
    }), 256))
  ], 4);
}
const Loading = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["render", _sfc_render$W], ["__scopeId", "data-v-b847f63e"]]);
Loading.install = (app) => {
  app.component(Loading.name, Loading);
};
const picker_vue_vue_type_style_index_0_scoped_4d117a98_lang = "";
const _sfc_main$V = {
  name: "m-picker",
  data() {
    return {
      offsets: [],
      startY: 0,
      startY2: 0,
      time: 0,
      oldActives: [],
      amounts: 0,
      mouseDown: false,
      columnIndex: 0,
      StartTimeStamp: 0,
      endTimeStamp: 0,
      itemRefs: []
    };
  },
  emits: ["confirm", "cancel", "change"],
  props: {
    options: {
      type: [Array, Object],
      default: function() {
        return {
          values: [],
          defaultIndex: 0
        };
      }
    },
    showToolbar: {
      type: Boolean,
      default: true
    },
    title: {
      type: String,
      default: null
    },
    confirmText: {
      type: String,
      default: "\u786E\u5B9A"
    },
    cancelText: {
      type: String,
      default: "\u53D6\u6D88"
    },
    loading: {
      type: Boolean,
      default: false
    },
    visibleCounts: {
      type: Number,
      default: 5
    },
    selectHeight: {
      type: String,
      default: "0.88rem"
    }
  },
  watch: {
    cmpOptions() {
      this.init();
    }
  },
  computed: {
    cmpHeight() {
      if (this.selectHeight.includes("px")) {
        return parseFloat(this.selectHeight);
      } else if (this.selectHeight.includes("rem")) {
        return obj$1.element.rem2px(parseFloat(this.selectHeight));
      }
    },
    loadingStyle() {
      let style = {};
      style.height = `calc(${obj$1.number.mutiply(this.cmpHeight, this.visibleCounts)}px + 0.88rem)`;
      return style;
    },
    contentStyle() {
      let style = {};
      style.height = `${obj$1.number.mutiply(this.cmpHeight, this.visibleCounts)}px`;
      return style;
    },
    cmpOptions() {
      let op = [];
      if (Array.isArray(this.options)) {
        op = this.options;
      } else {
        op = [this.options];
      }
      return op;
    },
    columnStyle() {
      return (column, index) => {
        let style = {};
        style.transform = `translate3d(0,${this.offsets[index] || 0}px,0)`;
        style.webkitTransform = `translate3d(0,${this.offsets[index] || 0}px,0)`;
        return style;
      };
    },
    actives() {
      let arr = [];
      for (let i = 0; i < this.offsets.length; i++) {
        arr.push({
          index: this.getActive(this.offsets[i]),
          value: this.cmpOptions[i].values[this.getActive(this.offsets[i])]
        });
      }
      return arr;
    },
    maskStyle() {
      let style = {};
      if (this.selectHeight) {
        style.backgroundSize = "100% " + obj$1.number.mutiply(this.cmpHeight, obj$1.number.divide(this.visibleCounts - 1, 2)) + "px";
      }
      return style;
    }
  },
  components: {
    Loading
  },
  setup() {
    const instance = getCurrentInstance();
    return {
      uid: instance.uid
    };
  },
  mounted() {
    this.init();
    obj$1.event.on(document.documentElement, `mousemove.picker_${this.uid}`, this.mousemove);
    obj$1.event.on(document.documentElement, `mouseup.picker_${this.uid}`, this.mouseup);
  },
  methods: {
    init() {
      this.offsets = [];
      for (let i = 0; i < this.cmpOptions.length; i++) {
        this.offsets.push(this.getOffset(this.cmpOptions[i].defaultIndex || 0));
      }
    },
    crisis(index) {
      let max = obj$1.number.divide(this.visibleCounts - 1, 2);
      max = obj$1.number.mutiply(max, this.cmpHeight);
      let min = -obj$1.number.divide(this.visibleCounts - 1, 2);
      min = obj$1.number.mutiply(min, this.cmpHeight);
      min += obj$1.number.mutiply(this.visibleCounts - this.cmpOptions[index].values.length, this.cmpHeight);
      return {
        max,
        min
      };
    },
    getActive(value) {
      let num = Math.abs(obj$1.number.divide(value - obj$1.number.mutiply(obj$1.number.divide(this.visibleCounts - 1, 2), this.cmpHeight), this.cmpHeight));
      return Math.round(num);
    },
    getOffset(index) {
      return obj$1.number.mutiply(obj$1.number.subtract(obj$1.number.divide(this.visibleCounts - 1, 2), index), this.cmpHeight);
    },
    doConfirm() {
      if (this.actives.length == 1) {
        this.$emit("confirm", this.actives[0]);
      } else {
        this.$emit("confirm", this.actives);
      }
    },
    doCancel() {
      this.init();
      if (this.actives.length == 1) {
        this.$emit("cancel", this.actives[0]);
      } else {
        this.$emit("cancel", this.actives);
      }
    },
    addTransition(index, timeout) {
      return new Promise((resolve) => {
        this.itemRefs[index].style.transition = "all " + timeout + "ms ease-out";
        this.itemRefs[index].style.webkitTransition = "all " + timeout + "ms ease-out";
        setTimeout(() => {
          resolve();
        }, 0);
      });
    },
    removeTransition(index) {
      return new Promise((resolve) => {
        this.itemRefs[index].style.transition = "";
        this.itemRefs[index].style.webkitTransition = "";
        setTimeout(() => {
          resolve();
        }, 0);
      });
    },
    touchstart(event2, index) {
      this.startY = event2.targetTouches[0].pageY;
      this.startY2 = this.startY;
      this.time = Date.now();
      this.oldActives = this.actives;
      this.amounts = 0;
      this.columnIndex = index;
      this.StartTimeStamp = Date.now();
    },
    mousedown(event2, index) {
      this.startY = event2.pageY;
      this.startY2 = this.startY;
      this.time = Date.now();
      this.oldActives = this.actives;
      this.amounts = 0;
      this.mouseDown = true;
      this.columnIndex = index;
      this.StartTimeStamp = Date.now();
    },
    touchmove(event2) {
      if (event2.cancelable) {
        event2.preventDefault();
      }
      let endY = event2.targetTouches[0].pageY;
      let moveY = endY - this.startY;
      let moveY2 = endY - this.startY2;
      if (this.offsets[this.columnIndex] >= this.crisis(this.columnIndex).max && moveY2 > 0) {
        this.amounts += 5;
        this.offsets[this.columnIndex] = this.offsets[this.columnIndex] + moveY / this.amounts;
        return;
      }
      if (this.offsets[this.columnIndex] <= this.crisis(this.columnIndex).min && moveY2 < 0) {
        this.amounts += 5;
        this.offsets[this.columnIndex] = this.offsets[this.columnIndex] + moveY / this.amounts;
        return;
      }
      this.offsets[this.columnIndex] = this.offsets[this.columnIndex] + moveY / 1.6;
      this.startY = endY;
    },
    mousemove(event2) {
      if (!this.mouseDown) {
        return;
      }
      if (event2.cancelable) {
        event2.preventDefault();
      }
      let endY = event2.pageY;
      let moveY = endY - this.startY;
      let moveY2 = endY - this.startY2;
      if (this.offsets[this.columnIndex] >= this.crisis(this.columnIndex).max && moveY2 > 0) {
        this.amounts += 5;
        this.offsets[this.columnIndex] = this.offsets[this.columnIndex] + moveY / this.amounts;
        return;
      }
      if (this.offsets[this.columnIndex] <= this.crisis(this.columnIndex).min && moveY2 < 0) {
        this.amounts += 5;
        this.offsets[this.columnIndex] = this.offsets[this.columnIndex] + moveY / this.amounts;
        return;
      }
      this.offsets[this.columnIndex] = this.offsets[this.columnIndex] + moveY / 1.6;
      this.startY = endY;
    },
    touchend(event2) {
      this.endTimeStamp = Date.now();
      let moveTotal = event2.changedTouches[0].pageY - this.startY2;
      let totalTimeStamp = this.endTimeStamp - this.StartTimeStamp;
      if (totalTimeStamp < 300 && Math.abs(moveTotal) > this.cmpHeight) {
        this.addTransition(this.columnIndex, 1e3).then(() => {
          if (moveTotal > 0) {
            this.offsets[this.columnIndex] = this.offsets[this.columnIndex] + obj$1.element.rem2px(10) * totalTimeStamp / 1e3;
          } else {
            this.offsets[this.columnIndex] = this.offsets[this.columnIndex] - obj$1.element.rem2px(10) * totalTimeStamp / 1e3;
          }
          return this.addTransition(this.columnIndex, 300);
        }).then(() => {
          this.endDeal(moveTotal, 300);
        });
      } else {
        this.addTransition(this.columnIndex, 300).then(() => {
          this.endDeal(moveTotal, 300);
        });
      }
    },
    mouseup(event2) {
      if (!this.mouseDown) {
        return;
      }
      this.mouseDown = false;
      this.endTimeStamp = Date.now();
      let moveTotal = event2.pageY - this.startY2;
      let totalTimeStamp = this.endTimeStamp - this.StartTimeStamp;
      if (totalTimeStamp < 300 && Math.abs(moveTotal) > this.cmpHeight) {
        this.addTransition(this.columnIndex, 1e3).then(() => {
          if (moveTotal > 0) {
            this.offsets[this.columnIndex] = this.offsets[this.columnIndex] + obj$1.element.rem2px(10) * totalTimeStamp / 1e3;
          } else {
            this.offsets[this.columnIndex] = this.offsets[this.columnIndex] - obj$1.element.rem2px(10) * totalTimeStamp / 1e3;
          }
          return this.addTransition(this.columnIndex, 300);
        }).then(() => {
          this.endDeal(moveTotal, 300);
        });
      } else {
        this.addTransition(this.columnIndex, 300).then(() => {
          this.endDeal(moveTotal, 300);
        });
      }
    },
    endDeal(moveTotal, timeout) {
      if (moveTotal > 0) {
        if (this.offsets[this.columnIndex] >= this.crisis(this.columnIndex).max) {
          this.offsets[this.columnIndex] = this.crisis(this.columnIndex).max;
        } else {
          let order = this.getActive(this.offsets[this.columnIndex]);
          this.offsets[this.columnIndex] = this.getOffset(order);
        }
      } else {
        if (this.offsets[this.columnIndex] <= this.crisis(this.columnIndex).min) {
          this.offsets[this.columnIndex] = this.crisis(this.columnIndex).min;
        } else {
          let order = this.getActive(this.offsets[this.columnIndex]);
          this.offsets[this.columnIndex] = this.getOffset(order);
        }
      }
      if (this.actives.length == 1) {
        if (this.actives[0].index != this.oldActives[0].index) {
          this.$emit("change", this.columnIndex, this.actives[0]);
        }
      } else {
        let flag = true;
        for (let i = 0; i < this.oldActives.length; i++) {
          if (this.oldActives[i].index != this.actives[i].index) {
            flag = false;
          }
        }
        if (!flag) {
          this.$emit("change", this.columnIndex, this.actives);
        }
      }
      setTimeout(() => {
        this.removeTransition(this.columnIndex);
      }, timeout);
    },
    contentTouchMove(event2) {
      if (event2.cancelable) {
        event2.preventDefault();
      }
    }
  },
  beforeUnmount() {
    obj$1.event.off(document.documentElement, `mousemove.picker_${this.uid} mouseup.picker_${this.uid}`);
  }
};
const _hoisted_1$G = { class: "mvi-picker" };
const _hoisted_2$A = {
  key: 1,
  class: "mvi-picker-toolbar"
};
const _hoisted_3$u = ["textContent"];
const _hoisted_4$n = ["textContent"];
const _hoisted_5$g = ["textContent"];
const _hoisted_6$c = ["onTouchstart", "onMousedown"];
const _hoisted_7$b = ["textContent"];
function _sfc_render$V(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Loading = resolveComponent("Loading");
  return openBlock(), createElementBlock("div", _hoisted_1$G, [
    $props.loading ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "mvi-picker-loading",
      style: normalizeStyle($options.loadingStyle)
    }, [
      createVNode(_component_Loading, {
        size: "0.5rem",
        color: "#ddd"
      })
    ], 4)) : createCommentVNode("", true),
    $props.showToolbar && !$props.loading ? (openBlock(), createElementBlock("div", _hoisted_2$A, [
      createElementVNode("div", {
        class: "mvi-picker-toolbar-cancel",
        textContent: toDisplayString($props.cancelText),
        onClick: _cache[0] || (_cache[0] = (...args) => $options.doCancel && $options.doCancel(...args))
      }, null, 8, _hoisted_3$u),
      $props.title ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "mvi-picker-toolbar-title",
        textContent: toDisplayString($props.title)
      }, null, 8, _hoisted_4$n)) : createCommentVNode("", true),
      createElementVNode("div", {
        class: "mvi-picker-toolbar-confirm",
        textContent: toDisplayString($props.confirmText),
        onClick: _cache[1] || (_cache[1] = (...args) => $options.doConfirm && $options.doConfirm(...args))
      }, null, 8, _hoisted_5$g)
    ])) : createCommentVNode("", true),
    !$props.loading ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: "mvi-picker-content",
      style: normalizeStyle($options.contentStyle),
      ref: "content",
      onTouchmove: _cache[4] || (_cache[4] = (...args) => $options.contentTouchMove && $options.contentTouchMove(...args))
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.cmpOptions, (column, index) => {
        return openBlock(), createElementBlock("div", {
          class: "mvi-picker-items",
          ref_for: true,
          ref: (el) => $data.itemRefs[index] = el,
          style: normalizeStyle($options.columnStyle(column, index)),
          onTouchstart: ($event) => $options.touchstart($event, index),
          onTouchmove: _cache[2] || (_cache[2] = (...args) => $options.touchmove && $options.touchmove(...args)),
          onTouchend: _cache[3] || (_cache[3] = (...args) => $options.touchend && $options.touchend(...args)),
          onMousedown: ($event) => $options.mousedown($event, index)
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(column.values, (item, index2) => {
            return openBlock(), createElementBlock("div", {
              class: "mvi-picker-item",
              textContent: toDisplayString(item),
              style: normalizeStyle({ height: $props.selectHeight || "" })
            }, null, 12, _hoisted_7$b);
          }), 256))
        ], 44, _hoisted_6$c);
      }), 256)),
      createElementVNode("div", {
        class: "mvi-picker-active",
        style: normalizeStyle({ height: $props.selectHeight || "" })
      }, null, 4),
      createElementVNode("div", {
        class: "mvi-picker-mask",
        style: normalizeStyle($options.maskStyle)
      }, null, 4)
    ], 36)) : createCommentVNode("", true)
  ]);
}
const Picker = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["render", _sfc_render$V], ["__scopeId", "data-v-4d117a98"]]);
Picker.install = (app) => {
  app.component(Picker.name, Picker);
};
const datePicker_vue_vue_type_style_index_0_scoped_a1692616_lang = "";
const _sfc_main$U = {
  name: "m-date-picker",
  emits: ["update:modelValue", "confirm", "cancel", "change"],
  props: {
    modelValue: {
      type: Date,
      default: function() {
        return new Date();
      }
    },
    startDate: {
      type: Date,
      default: function() {
        return dayjs("1970-01-01 00:00:00").toDate();
      }
    },
    endDate: {
      type: Date,
      default: function() {
        return dayjs("2099-12-31 23:59:59").toDate();
      }
    },
    mode: {
      type: String,
      default: "date",
      validator(value) {
        return ["date", "datetime", "time", "month", "year"].includes(value);
      }
    },
    showToolbar: {
      type: Boolean,
      default: true
    },
    title: {
      type: String,
      default: null
    },
    confirmText: {
      type: String,
      default: "\u786E\u5B9A"
    },
    cancelText: {
      type: String,
      default: "\u53D6\u6D88"
    },
    loading: {
      type: Boolean,
      default: false
    },
    visibleCounts: {
      type: Number,
      default: 5
    },
    selectHeight: {
      type: String,
      default: "0.88rem"
    },
    formatter: {
      type: Function
    }
  },
  computed: {
    selectedDate: {
      set(value) {
        if (value instanceof Date) {
          const unit = this.getUnit();
          if (dayjs(value).isBefore(dayjs(this.startDate), unit)) {
            value = this.startDate;
          }
          if (dayjs(value).isAfter(dayjs(this.endDate), unit)) {
            value = this.endDate;
          }
        }
        this.$emit("update:modelValue", value);
        this.$emit("change", value);
      },
      get() {
        if (this.modelValue instanceof Date) {
          const unit = this.getUnit();
          if (dayjs(this.modelValue).isBefore(dayjs(this.startDate), unit)) {
            return this.startDate;
          }
          if (dayjs(this.modelValue).isAfter(dayjs(this.endDate), unit)) {
            return this.endDate;
          }
          return this.modelValue;
        }
        return new Date();
      }
    },
    years() {
      let arr = [];
      let currentYear = this.startDate.getFullYear();
      while (currentYear <= this.endDate.getFullYear()) {
        arr.push(currentYear);
        currentYear++;
      }
      return arr;
    },
    months() {
      const format = dayjs(this.selectedDate).format("YYYY");
      let arr = [];
      for (let i = 1; i <= 12; i++) {
        if (dayjs(`${format}-${i < 10 ? "0" + i : i}`).isBefore(dayjs(this.startDate), "month")) {
          continue;
        }
        if (dayjs(`${format}-${i < 10 ? "0" + i : i}`).isAfter(dayjs(this.endDate), "month")) {
          continue;
        }
        arr.push(i);
      }
      return arr;
    },
    days() {
      const format = dayjs(this.selectedDate).format("YYYY-MM");
      let arr = [];
      const total = dayjs(this.selectedDate).daysInMonth();
      for (let i = 1; i <= total; i++) {
        if (dayjs(`${format}-${i < 10 ? "0" + i : i}`).isBefore(dayjs(this.startDate), "date")) {
          continue;
        }
        if (dayjs(`${format}-${i < 10 ? "0" + i : i}`).isAfter(dayjs(this.endDate), "date")) {
          continue;
        }
        arr.push(i);
      }
      return arr;
    },
    hours() {
      const format = dayjs(this.selectedDate).format("YYYY-MM-DD");
      let arr = [];
      for (let i = 0; i < 24; i++) {
        if (dayjs(`${format} ${i < 10 ? "0" + i : i}`).isBefore(dayjs(this.startDate), "hour")) {
          continue;
        }
        if (dayjs(`${format} ${i < 10 ? "0" + i : i}`).isAfter(dayjs(this.endDate), "hour")) {
          continue;
        }
        arr.push(i);
      }
      return arr;
    },
    minutes() {
      const format = dayjs(this.selectedDate).format("YYYY-MM-DD HH");
      let arr = [];
      for (let i = 0; i < 60; i++) {
        if (dayjs(`${format}:${i < 10 ? "0" + i : i}`).isBefore(dayjs(this.startDate), "minute")) {
          continue;
        }
        if (dayjs(`${format}:${i < 10 ? "0" + i : i}`).isAfter(dayjs(this.endDate), "minute")) {
          continue;
        }
        arr.push(i);
      }
      return arr;
    },
    pickerOptions() {
      const yearColumn = {
        defaultIndex: this.years.findIndex((item) => {
          return item == this.selectedDate.getFullYear();
        }),
        values: this.years.map((item) => {
          if (typeof this.formatter == "function") {
            return this.formatter.apply(this, ["year", item]);
          }
          return `${item}\u5E74`;
        })
      };
      const monthColumn = {
        defaultIndex: this.months.findIndex((item) => {
          return item == this.selectedDate.getMonth() + 1;
        }),
        values: this.months.map((item) => {
          if (typeof this.formatter == "function") {
            return this.formatter.apply(this, ["month", item]);
          }
          return `${item}\u6708`;
        })
      };
      const dateColumn = {
        defaultIndex: this.days.findIndex((item) => {
          return item == this.selectedDate.getDate();
        }),
        values: this.days.map((item) => {
          if (typeof this.formatter == "function") {
            return this.formatter.apply(this, ["date", item]);
          }
          return `${item}\u65E5`;
        })
      };
      const hourColumn = {
        defaultIndex: this.hours.findIndex((item) => {
          return item == this.selectedDate.getHours();
        }),
        values: this.hours.map((item) => {
          if (typeof this.formatter == "function") {
            return this.formatter.apply(this, ["hour", item]);
          }
          return `${item}\u65F6`;
        })
      };
      const minuteColumn = {
        defaultIndex: this.minutes.findIndex((item) => {
          return item == this.selectedDate.getMinutes();
        }),
        values: this.minutes.map((item) => {
          if (typeof this.formatter == "function") {
            return this.formatter.apply(this, ["minute", item]);
          }
          return `${item}\u5206`;
        })
      };
      if (this.mode == "year") {
        return yearColumn;
      }
      if (this.mode == "month") {
        return [yearColumn, monthColumn];
      }
      if (this.mode == "date") {
        return [yearColumn, monthColumn, dateColumn];
      }
      if (this.mode == "datetime") {
        return [yearColumn, monthColumn, dateColumn, hourColumn, minuteColumn];
      }
      if (this.mode == "time") {
        return [hourColumn, minuteColumn];
      }
    }
  },
  components: {
    Picker
  },
  methods: {
    dateChange(column, item) {
      if (this.mode == "year") {
        this.updateYear(this.years[item.index]);
      } else if (this.mode == "month") {
        if (column == 0) {
          this.updateYear(this.years[item[column].index]);
        } else {
          this.updateMonth(this.months[item[column].index]);
        }
      } else if (this.mode == "date") {
        if (column == 0) {
          this.updateYear(this.years[item[column].index]);
        } else if (column == 1) {
          this.updateMonth(this.months[item[column].index]);
        } else {
          this.updateDay(this.days[item[column].index]);
        }
      } else if (this.mode == "time") {
        if (column == 0) {
          this.updateHour(this.hours[item[column].index]);
        } else {
          this.updateMinute(this.minutes[item[column].index]);
        }
      } else if (this.mode == "datetime") {
        if (column == 0) {
          this.updateYear(this.years[item[column].index]);
        } else if (column == 1) {
          this.updateMonth(this.months[item[column].index]);
        } else if (column == 2) {
          this.updateDay(this.days[item[column].index]);
        } else if (column == 3) {
          this.updateHour(this.hours[item[column].index]);
        } else {
          this.updateMinute(this.minutes[item[column].index]);
        }
      }
    },
    doConfirm() {
      this.$emit("confirm", this.selectedDate);
    },
    doCancel() {
      this.$emit("cancel", this.selectedDate);
    },
    updateYear(year) {
      this.selectedDate = dayjs(this.selectedDate).year(year).toDate();
    },
    updateMonth(month) {
      this.selectedDate = dayjs(this.selectedDate).month(month - 1).toDate();
    },
    updateDay(day) {
      this.selectedDate = dayjs(this.selectedDate).date(day).toDate();
    },
    updateHour(hour) {
      this.selectedDate = dayjs(this.selectedDate).hour(hour).toDate();
    },
    updateMinute(minute) {
      this.selectedDate = dayjs(this.selectedDate).minute(minute).toDate();
    },
    getUnit() {
      if (this.mode == "year") {
        return "year";
      }
      if (this.mode == "month") {
        return "month";
      }
      if (this.mode == "date") {
        return "date";
      }
      if (this.mode == "time" || this.mode == "datetime") {
        return "minute";
      }
    }
  }
};
const _hoisted_1$F = { class: "mvi-date-picker" };
function _sfc_render$U(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Picker = resolveComponent("Picker");
  return openBlock(), createElementBlock("div", _hoisted_1$F, [
    createVNode(_component_Picker, {
      options: $options.pickerOptions,
      "show-toolbar": $props.showToolbar,
      title: $props.title,
      "confirm-text": $props.confirmText,
      "cancel-text": $props.cancelText,
      loading: $props.loading,
      "visible-counts": $props.visibleCounts,
      "select-height": $props.selectHeight,
      onChange: $options.dateChange,
      onConfirm: $options.doConfirm,
      onCancel: $options.doCancel
    }, null, 8, ["options", "show-toolbar", "title", "confirm-text", "cancel-text", "loading", "visible-counts", "select-height", "onChange", "onConfirm", "onCancel"])
  ]);
}
const DatePicker = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["render", _sfc_render$U], ["__scopeId", "data-v-a1692616"]]);
DatePicker.install = (app) => {
  app.component(DatePicker.name, DatePicker);
};
const dateNativePicker_vue_vue_type_style_index_0_scoped_646ce916_lang = "";
const _sfc_main$T = {
  name: "m-date-native-picker",
  emits: ["update:modelValue", "error", "change"],
  props: {
    type: {
      type: String,
      default: "date",
      validator(value) {
        return ["date", "datetime", "month", "time"].includes(value);
      }
    },
    modelValue: {
      type: Date,
      default: null
    },
    max: {
      type: Date,
      default: null
    },
    min: {
      type: Date,
      default: null
    }
  },
  computed: {
    dateType() {
      if (this.type == "datetime") {
        return "datetime-local";
      } else {
        return this.type;
      }
    },
    defaultDate() {
      if (this.modelValue) {
        if (this.type == "date") {
          return dayjs(this.modelValue).format("YYYY-MM-DD");
        }
        if (this.type == "datetime") {
          return dayjs(this.modelValue).format("YYYY-MM-DD HH:mm");
        }
        if (this.type == "month") {
          return dayjs(this.modelValue).format("YYYY-MM");
        }
        if (this.type == "time") {
          return dayjs(this.modelValue).format("HH:mm");
        }
      }
      return "";
    }
  },
  data() {
    return {
      ios: obj$1.platform.os().ios,
      iPad: obj$1.platform.device().iPad
    };
  },
  methods: {
    trigger() {
      if (this.ios) {
        this.$el.focus();
      } else {
        this.$el.click();
      }
    },
    selectDateForIOS() {
      if (this.ios && !this.iPad) {
        this.selectDate();
      }
    },
    selectDateForAndroid() {
      if (!this.ios || this.iPad) {
        this.selectDate();
      }
    },
    selectDate() {
      if (this.$el.value) {
        const date2 = dayjs(this.$el.value);
        if (this.min && date2.isBefore(dayjs(this.min))) {
          this.$emit("error", 0, "The date is less than min");
          return;
        }
        if (this.max && dayjs(this.max).isBefore(date2)) {
          this.$emit("error", 1, "The date is greater than max");
          return;
        }
        this.$emit("update:modelValue", date2.toDate());
        this.$emit("change", date2.toDate());
      } else {
        this.$emit("update:modelValue", null);
        this.$emit("change", null);
      }
    }
  }
};
const _hoisted_1$E = ["type", "value"];
function _sfc_render$T(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("input", {
    onBlur: _cache[0] || (_cache[0] = (...args) => $options.selectDateForIOS && $options.selectDateForIOS(...args)),
    onChange: _cache[1] || (_cache[1] = (...args) => $options.selectDateForAndroid && $options.selectDateForAndroid(...args)),
    class: "mvi-date-native-picker",
    type: $options.dateType,
    value: $options.defaultDate
  }, null, 40, _hoisted_1$E);
}
const DateNativePicker = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["render", _sfc_render$T], ["__scopeId", "data-v-646ce916"]]);
DateNativePicker.install = (app) => {
  app.component(DateNativePicker.name, DateNativePicker);
};
const input_vue_vue_type_style_index_0_scoped_8664fc16_lang = "";
const _sfc_main$S = {
  name: "m-input",
  data() {
    return {
      focus: false
    };
  },
  emits: ["update:modelValue", "left-click", "right-click", "focus", "blur", "input", "clear"],
  props: {
    modelValue: {
      type: [String, Number],
      default: ""
    },
    placeholder: {
      type: String,
      default: ""
    },
    label: {
      type: String,
      default: null
    },
    labelWidth: {
      type: String,
      default: null
    },
    labelAlign: {
      type: String,
      default: "left",
      validator(value) {
        return ["left", "center", "right"].includes(value);
      }
    },
    labelOffset: {
      type: String,
      default: null
    },
    type: {
      type: String,
      default: "text",
      validator(value) {
        return ["text", "password", "number", "tel", "textarea"].includes(value);
      }
    },
    name: {
      type: String,
      default: null
    },
    maxlength: {
      type: Number,
      default: -1
    },
    size: {
      type: String,
      default: "medium",
      validator(value) {
        return ["medium", "large"].includes(value);
      }
    },
    border: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    required: {
      type: Boolean,
      default: false
    },
    clearable: {
      type: Boolean,
      default: false
    },
    autofocus: {
      type: Boolean,
      default: false
    },
    showWordLimit: {
      type: Boolean,
      default: false
    },
    left: {
      type: [String, Object],
      default: null
    },
    right: {
      type: [String, Object],
      default: null
    },
    rows: {
      type: Number,
      default: 1
    },
    autosize: {
      type: [Boolean, Object],
      default: false,
      validator(value) {
        if (obj$1.common.isObject(value)) {
          if (obj$1.number.isNumber(value.minRows) && obj$1.number.isNumber(value.maxRows)) {
            if (value.minRows > value.maxRows) {
              return false;
            }
          }
        }
        return true;
      }
    },
    align: {
      type: String,
      default: "left",
      validator(value) {
        return ["left", "center", "right"].includes(value);
      }
    },
    inputMode: {
      type: [String, Boolean],
      default: false,
      validator(value) {
        return [false, "none", "text", "decimal", "numeric", "tel", "search", "email", "url"].includes(value);
      }
    }
  },
  computed: {
    inputClass() {
      let cls = ["mvi-input-container", this.size];
      if (this.border) {
        cls.push("border");
      }
      if (this.showWordLimit && this.maxlength > 0) {
        cls.push("words");
      }
      if (this.required) {
        cls.push("required");
      }
      return cls;
    },
    showClear() {
      if (this.disabled || this.readonly) {
        return false;
      }
      if (this.realValue && this.focus) {
        return true;
      }
      return false;
    },
    parseIcon() {
      return (param) => {
        let icon = {
          spin: false,
          type: null,
          url: null,
          color: null,
          size: null
        };
        if (obj$1.common.isObject(param)) {
          if (typeof param.spin == "boolean") {
            icon.spin = param.spin;
          }
          if (typeof param.type == "string") {
            icon.type = param.type;
          }
          if (typeof param.url == "string") {
            icon.url = param.url;
          }
          if (typeof param.color == "string") {
            icon.color = param.color;
          }
          if (typeof param.size == "string") {
            icon.size = param.size;
          }
        } else if (typeof param == "string") {
          icon.type = param;
        }
        return icon;
      };
    },
    realValue: {
      set(value) {
        if (this.modelValue !== value) {
          this.$emit("update:modelValue", value);
        }
      },
      get() {
        let value = this.modelValue === null ? "" : this.modelValue.toString();
        if (this.type == "number") {
          value = value.replace(/\D/g, "");
        }
        if (this.maxlength > 0 && value.length > this.maxlength) {
          value = value.substr(0, this.maxlength);
        }
        if (this.modelValue !== value) {
          this.$emit("update:modelValue", value);
        }
        return value;
      }
    },
    cmpType() {
      if (this.type == "number") {
        return "text";
      }
      return this.type;
    },
    rowsFilter() {
      let rows = this.rows;
      if (obj$1.common.isObject(this.autosize)) {
        if (obj$1.number.isNumber(this.autosize.minRows)) {
          if (this.rows < this.autosize.minRows) {
            rows = this.autosize.minRows;
          }
        }
        if (obj$1.number.isNumber(this.autosize.maxRows)) {
          if (this.rows > this.autosize.maxRows) {
            rows = this.autosize.maxRows;
          }
        }
      }
      return rows;
    },
    labelStyle() {
      let style = {};
      if (this.labelWidth) {
        style.width = this.labelWidth;
      }
      if (this.labelAlign) {
        if (this.labelAlign == "left") {
          style.justifyContent = "flex-start";
        } else if (this.labelAlign == "right") {
          style.justifyContent = "flex-end";
        } else {
          style.justifyContent = this.labelAlign;
        }
      }
      if (this.labelOffset) {
        style.marginRight = this.labelOffset;
      }
      return style;
    },
    inputStyle() {
      return {
        textAlign: this.align ? this.align : ""
      };
    },
    showLeft() {
      return this.$slots.left || this.parseIcon(this.left).type || this.parseIcon(this.left).url;
    },
    showRight() {
      return this.$slots.right || this.parseIcon(this.right).type || this.parseIcon(this.right).url;
    }
  },
  components: {
    Icon
  },
  mounted() {
    if (this.$refs.textarea) {
      this.setMaxMinHeight();
      if (this.autosize == true || obj$1.common.isObject(this.autosize)) {
        this.autosizeSet();
      }
    }
  },
  watch: {
    realValue() {
      if (this.$refs.textarea && (this.autosize == true || obj$1.common.isObject(this.autosize))) {
        this.autosizeSet();
      }
    },
    rows() {
      if (this.$refs.textarea) {
        this.setMaxMinHeight();
      }
    },
    autosize() {
      if (this.$refs.textarea) {
        this.setMaxMinHeight();
      }
    },
    showClear(newValue) {
      this.$nextTick(() => {
        if (this.$refs.textarea && (this.autosize == true || obj$1.common.isObject(this.autosize))) {
          this.autosizeSet();
        }
      });
    }
  },
  methods: {
    autosizeSet() {
      this.$refs.textarea.style.height = "auto";
      this.$refs.textarea.scrollTop = 0;
      this.$refs.textarea.style.height = obj$1.element.getScrollHeight(this.$refs.textarea) + "px";
    },
    rows2Height(rows) {
      let lineHeight = Math.floor(parseFloat(obj$1.element.getCssStyle(this.$refs.textarea, "line-height")));
      return rows * lineHeight;
    },
    setMaxMinHeight() {
      if (obj$1.common.isObject(this.autosize)) {
        if (obj$1.number.isNumber(this.autosize.maxRows)) {
          let maxHeight = this.rows2Height(this.autosize.maxRows);
          this.$refs.textarea.style.maxHeight = maxHeight + "px";
        }
        if (obj$1.number.isNumber(this.autosize.minRows)) {
          let minHeight = this.rows2Height(this.autosize.minRows);
          this.$refs.textarea.style.minHeight = minHeight + "px";
        }
      } else {
        this.$refs.textarea.style.maxHeight = "";
        this.$refs.textarea.style.minHeight = "";
      }
    },
    inputFocus() {
      if (this.disabled) {
        return;
      }
      this.focus = true;
      this.$emit("focus", this.realValue);
    },
    inputBlur() {
      if (this.disabled) {
        return;
      }
      setTimeout(() => {
        this.focus = false;
        this.$emit("blur", this.realValue);
      }, 100);
    },
    input() {
      if (this.disabled) {
        return;
      }
      this.$emit("input", this.realValue);
    },
    leftClick() {
      if (this.disabled) {
        return;
      }
      this.$emit("left-click", this.realValue);
    },
    rightClick() {
      if (this.disabled) {
        return;
      }
      this.$emit("right-click", this.realValue);
    },
    doClear() {
      if (this.disabled) {
        return;
      }
      if (!this.clearable) {
        return;
      }
      setTimeout(() => {
        this.realValue = "";
        let el = this.$refs.input || this.$refs.textarea;
        el.focus();
        this.$emit("clear", this.realValue);
      }, 110);
    }
  }
};
const _hoisted_1$D = ["disabled", "data-type"];
const _hoisted_2$z = ["textContent"];
const _hoisted_3$t = ["placeholder", "maxlength", "disabled", "readonly", "autofocus", "rows", "name"];
const _hoisted_4$m = ["type", "inputmode", "placeholder", "maxlength", "disabled", "readonly", "autofocus", "name"];
const _hoisted_5$f = {
  key: 6,
  class: "mvi-input-words"
};
function _sfc_render$S(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("div", {
    disabled: $props.disabled || null,
    class: normalizeClass($options.inputClass),
    "data-type": $props.type
  }, [
    $options.showLeft ? (openBlock(), createElementBlock("div", {
      key: 0,
      onClick: _cache[0] || (_cache[0] = (...args) => $options.leftClick && $options.leftClick(...args)),
      class: "mvi-input-left"
    }, [
      _ctx.$slots.left ? renderSlot(_ctx.$slots, "left", { key: 0 }, void 0, true) : (openBlock(), createBlock(_component_Icon, {
        key: 1,
        type: $options.parseIcon($props.left).type,
        url: $options.parseIcon($props.left).url,
        spin: $options.parseIcon($props.left).spin,
        size: $options.parseIcon($props.left).size,
        color: $options.parseIcon($props.left).color
      }, null, 8, ["type", "url", "spin", "size", "color"]))
    ])) : createCommentVNode("", true),
    $props.label ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: "mvi-input-label",
      style: normalizeStyle($options.labelStyle)
    }, [
      createElementVNode("span", {
        textContent: toDisplayString($props.label)
      }, null, 8, _hoisted_2$z)
    ], 4)) : createCommentVNode("", true),
    $props.type == "textarea" ? withDirectives((openBlock(), createElementBlock("textarea", {
      key: 2,
      placeholder: $props.placeholder,
      maxlength: $props.maxlength,
      disabled: $props.disabled,
      readonly: $props.readonly,
      autofocus: $props.autofocus,
      class: "mvi-textarea",
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $options.realValue = $event),
      onInput: _cache[2] || (_cache[2] = (...args) => $options.input && $options.input(...args)),
      ref: "textarea",
      rows: $options.rowsFilter,
      name: $props.name,
      style: normalizeStyle($options.inputStyle),
      onFocus: _cache[3] || (_cache[3] = (...args) => $options.inputFocus && $options.inputFocus(...args)),
      onBlur: _cache[4] || (_cache[4] = (...args) => $options.inputBlur && $options.inputBlur(...args)),
      autocomplete: "off"
    }, null, 44, _hoisted_3$t)), [
      [vModelText, $options.realValue]
    ]) : withDirectives((openBlock(), createElementBlock("input", {
      key: 3,
      type: $options.cmpType,
      inputmode: $props.inputMode,
      placeholder: $props.placeholder,
      maxlength: $props.maxlength,
      disabled: $props.disabled,
      readonly: $props.readonly,
      autofocus: $props.autofocus,
      class: "mvi-input",
      "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => $options.realValue = $event),
      onInput: _cache[6] || (_cache[6] = (...args) => $options.input && $options.input(...args)),
      ref: "input",
      name: $props.name,
      style: normalizeStyle($options.inputStyle),
      onFocus: _cache[7] || (_cache[7] = (...args) => $options.inputFocus && $options.inputFocus(...args)),
      onBlur: _cache[8] || (_cache[8] = (...args) => $options.inputBlur && $options.inputBlur(...args)),
      autocomplete: "off"
    }, null, 44, _hoisted_4$m)), [
      [vModelDynamic, $options.realValue]
    ]),
    $props.clearable ? withDirectives((openBlock(), createElementBlock("div", {
      key: 4,
      onClick: _cache[9] || (_cache[9] = (...args) => $options.doClear && $options.doClear(...args)),
      class: "mvi-input-clear"
    }, [
      createVNode(_component_Icon, { type: "times-o" })
    ], 512)), [
      [vShow, $options.showClear]
    ]) : createCommentVNode("", true),
    $options.showRight ? (openBlock(), createElementBlock("div", {
      key: 5,
      onClick: _cache[10] || (_cache[10] = (...args) => $options.rightClick && $options.rightClick(...args)),
      class: "mvi-input-right"
    }, [
      _ctx.$slots.right ? renderSlot(_ctx.$slots, "right", { key: 0 }, void 0, true) : (openBlock(), createBlock(_component_Icon, {
        key: 1,
        type: $options.parseIcon($props.right).type,
        url: $options.parseIcon($props.right).url,
        spin: $options.parseIcon($props.right).spin,
        size: $options.parseIcon($props.right).size,
        color: $options.parseIcon($props.right).color
      }, null, 8, ["type", "url", "spin", "size", "color"]))
    ])) : createCommentVNode("", true),
    $props.showWordLimit && $props.maxlength > 0 ? (openBlock(), createElementBlock("div", _hoisted_5$f, toDisplayString($options.realValue.length) + "/" + toDisplayString($props.maxlength), 1)) : createCommentVNode("", true)
  ], 10, _hoisted_1$D);
}
const Input = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["render", _sfc_render$S], ["__scopeId", "data-v-8664fc16"]]);
Input.install = (app) => {
  app.component(Input.name, Input);
};
const modal_vue_vue_type_style_index_0_scoped_d29bc77e_lang = "";
const _sfc_main$R = {
  name: "m-modal",
  data() {
    return {
      modalShow: false,
      firstShow: false
    };
  },
  emits: ["update:modelValue", "show", "showing", "shown", "hide", "hidding", "hidden"],
  inheritAttrs: false,
  props: {
    modelValue: {
      type: Boolean,
      default: false
    },
    mountEl: {
      type: String,
      default: null
    },
    title: {
      type: String,
      default: ""
    },
    center: {
      type: Boolean,
      default: false
    },
    ellipsis: {
      type: Boolean,
      default: false
    },
    content: {
      type: String,
      default: ""
    },
    footer: {
      type: String,
      default: null
    },
    showTimes: {
      type: Boolean,
      default: false
    },
    timeout: {
      type: Number,
      default: 200
    },
    closable: {
      type: Boolean,
      default: false
    },
    overlayColor: {
      type: String,
      default: null
    },
    zIndex: {
      type: Number,
      default: 900
    },
    width: {
      type: String,
      default: null
    },
    radius: {
      type: String,
      default: null
    },
    animation: {
      type: String,
      default: "scale"
    },
    usePadding: {
      type: Boolean,
      default: false
    },
    fullScreen: {
      type: Boolean,
      default: false
    },
    __ignorePadding: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    $$el() {
      return this.$refs.overlay.$$el;
    },
    show: {
      get() {
        return this.modelValue;
      },
      set(value) {
        this.$emit("update:modelValue", value);
      }
    },
    wrapperStyle() {
      let style = {};
      if (this.radius) {
        style.borderRadius = this.radius;
      }
      style.transition = "all " + this.timeout + "ms";
      return style;
    },
    headerStyle() {
      let style = {};
      if (this.$slots.default || this.content) {
        style.paddingBottom = "0";
      }
      return style;
    }
  },
  components: {
    Icon,
    Overlay
  },
  watch: {
    fullScreen() {
      this.modalSize();
    }
  },
  methods: {
    modalSize() {
      if (this.fullScreen) {
        this.$refs.modal.style.width = this.$$el.offsetParent.offsetWidth + "px";
        this.$refs.wrapper.style.height = this.$$el.offsetParent.offsetHeight + "px";
        this.$refs.wrapper.style.maxHeight = "";
      } else {
        if (this.width) {
          this.$refs.modal.style.width = this.width;
        } else {
          this.$refs.modal.style.width = "";
        }
        this.$refs.wrapper.style.maxHeight = this.$$el.offsetParent.offsetHeight * 0.96 + "px";
        this.$refs.wrapper.style.height = "";
      }
    },
    overlayShow() {
      if (!this.firstShow) {
        this.firstShow = true;
      }
      this.modalShow = true;
    },
    overlayHide() {
      this.modalShow = false;
    },
    beforeEnter(el) {
      if (obj$1.data.get(el, "mvi-modal-beforeEnter-trigger")) {
        return;
      }
      obj$1.data.set(el, "mvi-modal-beforeEnter-trigger", true);
      this.$emit("show", el);
      if (typeof this.modalComponentWatch == "function") {
        this.modalComponentWatch.apply(this, ["show", el]);
      }
    },
    enter(el) {
      if (obj$1.data.get(el, "mvi-modal-enter-trigger")) {
        return;
      }
      obj$1.data.set(el, "mvi-modal-enter-trigger", true);
      this.modalSize();
      this.$emit("showing", el);
      if (typeof this.modalComponentWatch == "function") {
        this.modalComponentWatch.apply(this, ["showing", el]);
      }
    },
    afterEnter(el) {
      this.$emit("shown", el);
      if (typeof this.modalComponentWatch == "function") {
        this.modalComponentWatch.apply(this, ["shown", el]);
      }
    },
    beforeLeave(el) {
      obj$1.data.remove(el, "mvi-modal-beforeEnter-trigger");
      obj$1.data.remove(el, "mvi-modal-enter-trigger");
      this.$emit("hide", el);
      if (typeof this.modalComponentWatch == "function") {
        this.modalComponentWatch.apply(this, ["hide", el]);
      }
    },
    leave(el) {
      this.$emit("hidding", el);
      if (typeof this.modalComponentWatch == "function") {
        this.modalComponentWatch.apply(this, ["hidding", el]);
      }
    },
    afterLeave(el) {
      this.$emit("hidden", el);
      if (typeof this.modalComponentWatch == "function") {
        this.modalComponentWatch.apply(this, ["hidden", el]);
      }
    }
  }
};
const _hoisted_1$C = ["innerHTML"];
const _hoisted_2$y = {
  key: 2,
  ref: "content",
  class: "mvi-modal-content"
};
const _hoisted_3$s = ["innerHTML"];
const _hoisted_4$l = ["textContent"];
function _sfc_render$R(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_Overlay = resolveComponent("Overlay");
  return openBlock(), createBlock(_component_Overlay, {
    ref: "overlay",
    modelValue: $options.show,
    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $options.show = $event),
    onShow: $options.overlayShow,
    onHide: $options.overlayHide,
    "use-padding": $props.usePadding,
    "z-index": $props.zIndex,
    closable: $props.closable,
    color: $props.overlayColor,
    timeout: $props.timeout,
    "mount-el": $props.mountEl
  }, {
    default: withCtx(() => [
      createElementVNode("div", {
        ref: "modal",
        class: "mvi-modal",
        style: normalizeStyle({ zIndex: $props.zIndex + 10 })
      }, [
        createVNode(Transition, {
          name: "mvi-modal-" + $props.animation,
          onBeforeEnter: $options.beforeEnter,
          onEnter: $options.enter,
          onAfterEnter: $options.afterEnter,
          onBeforeLeave: $options.beforeLeave,
          onLeave: $options.leave,
          onAfterLeave: $options.afterLeave
        }, {
          default: withCtx(() => [
            $data.firstShow ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
              key: 0,
              class: "mvi-modal-wrapper",
              ref: "wrapper",
              style: $options.wrapperStyle
            }, _ctx.$attrs), [
              $props.showTimes ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "mvi-modal-times",
                onClick: _cache[0] || (_cache[0] = ($event) => $options.show = false)
              }, [
                createVNode(_component_Icon, { type: "times" })
              ])) : createCommentVNode("", true),
              _ctx.$slots.title || $props.title ? (openBlock(), createElementBlock("div", {
                key: 1,
                ref: "header",
                class: normalizeClass(["mvi-modal-title", $props.ellipsis ? "ellipsis" : "", $props.center ? "center" : ""]),
                style: normalizeStyle($options.headerStyle)
              }, [
                _ctx.$slots.title ? renderSlot(_ctx.$slots, "title", { key: 0 }, void 0, true) : $props.title ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  innerHTML: $props.title
                }, null, 8, _hoisted_1$C)) : createCommentVNode("", true)
              ], 6)) : createCommentVNode("", true),
              _ctx.$slots.default || $props.content ? (openBlock(), createElementBlock("div", _hoisted_2$y, [
                _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }, void 0, true) : $props.content ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  innerHTML: $props.content
                }, null, 8, _hoisted_3$s)) : createCommentVNode("", true)
              ], 512)) : createCommentVNode("", true),
              _ctx.$slots.footer || $props.footer ? (openBlock(), createElementBlock("div", {
                key: 3,
                ref: "footer",
                class: "mvi-modal-footer",
                style: normalizeStyle({ padding: $props.__ignorePadding ? 0 : "" })
              }, [
                _ctx.$slots.footer ? renderSlot(_ctx.$slots, "footer", { key: 0 }, void 0, true) : $props.footer ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  textContent: toDisplayString($props.footer)
                }, null, 8, _hoisted_4$l)) : createCommentVNode("", true)
              ], 4)) : createCommentVNode("", true)
            ], 16)), [
              [vShow, $data.modalShow]
            ]) : createCommentVNode("", true)
          ]),
          _: 3
        }, 8, ["name", "onBeforeEnter", "onEnter", "onAfterEnter", "onBeforeLeave", "onLeave", "onAfterLeave"])
      ], 4)
    ]),
    _: 3
  }, 8, ["modelValue", "onShow", "onHide", "use-padding", "z-index", "closable", "color", "timeout", "mount-el"]);
}
const Modal = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["render", _sfc_render$R], ["__scopeId", "data-v-d29bc77e"]]);
Modal.install = (app) => {
  app.component(Modal.name, Modal);
};
const dialog_vue_vue_type_style_index_0_scoped_b9a33bd4_lang = "";
const _sfc_main$Q = {
  name: "m-dialog",
  data() {
    return {
      ok: false,
      show: true,
      focus: false,
      value: ""
    };
  },
  props: {
    type: {
      type: String,
      default: null
    },
    title: {
      type: String,
      default: null
    },
    message: {
      default: ""
    },
    width: {
      type: String,
      default: null
    },
    zIndex: {
      type: Number,
      default: null
    },
    animation: {
      type: String,
      default: null
    },
    radius: {
      type: String,
      default: null
    },
    overlayColor: {
      type: String,
      default: null
    },
    closable: {
      type: Boolean,
      default: null
    },
    input: {
      type: Object,
      default: null
    },
    usePadding: {
      type: Boolean,
      default: null
    },
    btnText: {
      type: [String, Array],
      default: null
    },
    btnColor: {
      type: [String, Array],
      default: null
    },
    ios: {
      type: Boolean,
      default: null
    },
    mountEl: {
      type: String,
      default: null
    },
    timeout: {
      type: Number,
      default: null
    },
    __remove: {
      type: Function,
      default: function() {
        return function() {
        };
      }
    }
  },
  computed: {
    $$el() {
      return this.$refs.modal.$$el;
    },
    cmpTitle() {
      if (typeof this.title == "string") {
        return this.title;
      }
      return "\u63D0\u793A";
    },
    cmpMessage() {
      if (typeof this.message == "string") {
        return this.message;
      }
      if (obj$1.common.isObject(this.message)) {
        return JSON.stringify(this.message);
      }
      return String(this.message);
    },
    cmpBtnText() {
      let bt = null;
      if (this.type == "alert") {
        if (typeof this.btnText == "string") {
          bt = this.btnText;
        } else {
          bt = "\u786E\u5B9A";
        }
      } else {
        bt = [];
        if (this.btnText instanceof Array) {
          if (typeof this.btnText[0] == "string") {
            bt[0] = this.btnText[0];
          } else {
            bt[0] = "\u786E\u5B9A";
          }
          if (typeof this.btnText[1] == "string") {
            bt[1] = this.btnText[1];
          } else {
            bt[1] = "\u53D6\u6D88";
          }
        } else {
          bt = ["\u786E\u5B9A", "\u53D6\u6D88"];
        }
      }
      return bt;
    },
    cmpBtnColor() {
      let bt = null;
      if (this.type == "alert") {
        if (typeof this.btnColor == "string") {
          bt = this.btnColor;
        } else {
          bt = null;
        }
      } else {
        bt = [];
        if (this.btnColor instanceof Array) {
          if (typeof this.btnColor[0] == "string") {
            bt[0] = this.btnColor[0];
          } else {
            bt[0] = null;
          }
          if (typeof this.btnColor[1] == "string") {
            bt[1] = this.btnColor[1];
          } else {
            bt[1] = null;
          }
        } else {
          bt = [null, null];
        }
      }
      return bt;
    },
    cmpWidth() {
      if (typeof this.width == "string" && this.width) {
        return this.width;
      }
      return "5.6rem";
    },
    cmpInput() {
      let input = {
        placeholder: "",
        type: "text",
        autofocus: true,
        maxlength: -1,
        clearable: true,
        mode: false,
        align: "left",
        value: ""
      };
      if (obj$1.common.isObject(this.input)) {
        if (typeof this.input.placeholder == "string") {
          input.placeholder = this.input.placeholder;
        }
        if (typeof this.input.type == "string" && this.input.type) {
          input.type = this.input.type;
        }
        if (typeof this.input.autofocus == "boolean") {
          input.autofocus = this.input.autofocus;
        }
        if (obj$1.number.isNumber(this.input.maxlength)) {
          input.maxlength = this.input.maxlength;
        }
        if (typeof this.input.clearable == "boolean") {
          input.clearable = this.input.clearable;
        }
        if (typeof this.input.mode == "string") {
          input.mode = this.input.mode;
        }
        if (typeof this.input.align == "string") {
          input.align = this.input.align;
        }
        if (typeof this.input.value == "string" || obj$1.number.isNumber(this.input.value)) {
          input.value = this.input.value.toString();
        }
      }
      return input;
    },
    cmpZIndex() {
      if (obj$1.number.isNumber(this.zIndex)) {
        return this.zIndex;
      }
      return 1e3;
    },
    cmpUsePadding() {
      if (typeof this.usePadding == "boolean") {
        return this.usePadding;
      }
      return false;
    },
    cmpAnimation() {
      if (typeof this.animation == "string" && this.animation) {
        return this.animation;
      }
      return "narrow";
    },
    cmpRadius() {
      if (typeof this.radius == "string" && this.radius) {
        return this.radius;
      }
      return "0.2rem";
    },
    cmpOverlayColor() {
      if (typeof this.overlayColor == "string" && this.overlayColor) {
        return this.overlayColor;
      }
      if (this.cmpIos) {
        return "rgba(0,10,20,.3)";
      }
      return null;
    },
    cmpIos() {
      if (typeof this.ios == "boolean") {
        return this.ios;
      }
      return false;
    },
    cmpMountEl() {
      if (typeof this.mountEl == "string" && this.mountEl) {
        return this.mountEl;
      }
      return "body";
    },
    cmpClosable() {
      if (typeof this.closable == "boolean") {
        return this.closable;
      } else {
        return false;
      }
    },
    cmpTimeout() {
      if (obj$1.number.isNumber(this.timeout)) {
        return this.timeout;
      }
      return 200;
    },
    contentShow() {
      if (this.type == "alert" || this.type == "confirm") {
        if (this.cmpMessage && !this.cmpIos) {
          return true;
        }
        return false;
      }
      return true;
    },
    showClear() {
      return this.focus && this.value;
    },
    inputClass() {
      let cls = [];
      if (this.showClear && this.cmpInput.clearable) {
        cls.push("mvi-dialog-input-padding");
      }
      return cls;
    },
    inputMode() {
      let mode = false;
      if ([false, "none", "text", "decimal", "numeric", "tel", "search", "email", "url"].includes(this.cmpInput.mode)) {
        mode = this.cmpInput.mode;
      }
      return mode;
    },
    inputStyle() {
      let style = {};
      if (["left", "right", "center"].includes(this.cmpInput.align)) {
        style.textAlign = this.cmpInput.align;
      }
      return style;
    }
  },
  components: {
    Icon,
    Modal
  },
  created() {
    if (this.type == "prompt") {
      this.setDefaultValue();
    }
  },
  mounted() {
    obj$1.event.on(this.$$el, "click.dialog", this.overlayClick);
  },
  methods: {
    overlayClick(event2) {
      if (!this.cmpClosable) {
        return;
      }
      if (event2.target != event2.currentTarget) {
        return;
      }
      this.show = false;
      this.ok = false;
    },
    setDefaultValue() {
      let value = this.cmpInput.value;
      if (this.cmpInput.type == "number") {
        value = value.replace(/\D/g, "");
      }
      if (this.cmpInput.maxlength > 0 && value.length > this.cmpInput.maxlength) {
        value = value.substring(0, this.cmpInput.maxlength);
      }
      this.value = value;
    },
    inputFocus() {
      this.focus = true;
    },
    inputBlur() {
      setTimeout(() => {
        this.focus = false;
      }, 100);
    },
    inputFun() {
      let value = this.value;
      if (this.cmpInput.type == "number") {
        value = value.replace(/\D/g, "");
      }
      if (this.cmpInput.maxlength > 0 && value.length > this.cmpInput.maxlength) {
        value = value.substr(0, this.cmpInput.maxlength);
      }
      this.value = value;
    },
    doClear() {
      if (!this.cmpInput.clearable) {
        return;
      }
      setTimeout(() => {
        this.value = "";
        this.$refs.input.focus();
      }, 110);
    },
    okFun() {
      this.show = false;
      this.ok = true;
    },
    cancelFun() {
      this.show = false;
      this.ok = false;
    },
    modalHide(el) {
      if (typeof this.dialogComponentWatch == "function") {
        this.dialogComponentWatch.apply(this, ["hide", this.type, el]);
      }
    },
    modalHidding(el) {
      if (typeof this.dialogComponentWatch == "function") {
        this.dialogComponentWatch.apply(this, ["hidding", this.type, el]);
      }
    },
    modalHidden(el) {
      if (typeof this.dialogComponentWatch == "function") {
        this.dialogComponentWatch.apply(this, ["hidden", this.type, el]);
      }
      if (this.type == "alert") {
        this.__remove();
      } else if (this.type == "confirm") {
        this.__remove(this.ok);
      } else if (this.type == "prompt") {
        this.__remove(this.ok, this.value);
      }
    },
    modalShow(el) {
      if (typeof this.dialogComponentWatch == "function") {
        this.dialogComponentWatch.apply(this, ["show", this.type, el]);
      }
    },
    modalShowing(el) {
      if (typeof this.dialogComponentWatch == "function") {
        this.dialogComponentWatch.apply(this, ["showing", this.type, el]);
      }
    },
    modalShown(el) {
      if (this.type == "prompt" && this.cmpInput.autofocus && this.$refs.input) {
        this.$refs.input.focus();
      }
      if (typeof this.dialogComponentWatch == "function") {
        this.dialogComponentWatch.apply(this, ["shown", this.type, el]);
      }
    }
  }
};
const _hoisted_1$B = ["innerHTML"];
const _hoisted_2$x = ["innerHTML"];
const _hoisted_3$r = ["innerHTML"];
const _hoisted_4$k = ["type", "placeholder", "maxlength", "inputmode"];
const _hoisted_5$e = { class: "mvi-dialog-footer" };
const _hoisted_6$b = ["textContent"];
const _hoisted_7$a = ["textContent"];
function _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_Modal = resolveComponent("Modal");
  return openBlock(), createBlock(_component_Modal, {
    ref: "modal",
    modelValue: $data.show,
    "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $data.show = $event),
    onHide: $options.modalHide,
    onHidding: $options.modalHidding,
    onHidden: $options.modalHidden,
    width: $options.cmpWidth,
    "z-index": $options.cmpZIndex,
    radius: $options.cmpRadius,
    "use-padding": $options.cmpUsePadding,
    animation: $options.cmpAnimation,
    onShow: $options.modalShow,
    onShowing: $options.modalShowing,
    onShown: $options.modalShown,
    timeout: $options.cmpTimeout,
    "overlay-color": $options.cmpOverlayColor,
    "mount-el": $options.cmpMountEl,
    __ignorePadding: ""
  }, createSlots({
    footer: withCtx(() => [
      createElementVNode("div", _hoisted_5$e, [
        $props.type != "alert" ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "mvi-dialog-cancel",
          textContent: toDisplayString($options.cmpBtnText[1]),
          onClick: _cache[4] || (_cache[4] = (...args) => $options.cancelFun && $options.cancelFun(...args)),
          style: normalizeStyle({ color: $options.cmpBtnColor[1] || "" })
        }, null, 12, _hoisted_6$b)) : createCommentVNode("", true),
        createElementVNode("div", {
          class: "mvi-dialog-ok",
          textContent: toDisplayString($props.type == "alert" ? $options.cmpBtnText : $options.cmpBtnText[0]),
          onClick: _cache[5] || (_cache[5] = (...args) => $options.okFun && $options.okFun(...args)),
          style: normalizeStyle({ color: $props.type == "alert" ? $options.cmpBtnColor || "" : $options.cmpBtnColor[0] || "" })
        }, null, 12, _hoisted_7$a)
      ])
    ]),
    _: 2
  }, [
    $options.cmpTitle || $options.cmpIos && $options.cmpMessage ? {
      name: "title",
      fn: withCtx(() => [
        $options.cmpTitle ? (openBlock(), createElementBlock("div", {
          key: 0,
          innerHTML: $options.cmpTitle,
          class: "mvi-dialog-title"
        }, null, 8, _hoisted_1$B)) : createCommentVNode("", true),
        $options.cmpMessage && $options.cmpIos ? (openBlock(), createElementBlock("div", {
          key: 1,
          innerHTML: $options.cmpMessage,
          class: "mvi-dialog-ios-content"
        }, null, 8, _hoisted_2$x)) : createCommentVNode("", true)
      ]),
      key: "0"
    } : void 0,
    $options.contentShow ? {
      name: "default",
      fn: withCtx(() => [
        !$options.cmpIos && $options.cmpMessage ? (openBlock(), createElementBlock("div", {
          key: 0,
          innerHTML: $options.cmpMessage,
          class: "mvi-dialog-content"
        }, null, 8, _hoisted_3$r)) : createCommentVNode("", true),
        $props.type == "prompt" ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(["mvi-dialog-input", !$options.cmpIos && $options.cmpMessage ? "mvi-dialog-input-mt" : ""])
        }, [
          withDirectives(createElementVNode("input", {
            ref: "input",
            type: $options.cmpInput.type == "number" ? "text" : $options.cmpInput.type,
            placeholder: $options.cmpInput.placeholder,
            maxlength: $options.cmpInput.maxlength,
            class: normalizeClass($options.inputClass),
            style: normalizeStyle($options.inputStyle),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.value = $event),
            onInput: _cache[1] || (_cache[1] = (...args) => $options.inputFun && $options.inputFun(...args)),
            onFocus: _cache[2] || (_cache[2] = (...args) => $options.inputFocus && $options.inputFocus(...args)),
            onBlur: _cache[3] || (_cache[3] = (...args) => $options.inputBlur && $options.inputBlur(...args)),
            inputmode: $options.inputMode
          }, null, 46, _hoisted_4$k), [
            [
              vModelDynamic,
              $data.value,
              void 0,
              { trim: true }
            ]
          ]),
          $options.cmpInput.clearable ? withDirectives((openBlock(), createBlock(_component_Icon, {
            key: 0,
            ref: "icon",
            type: "times-o",
            class: "mvi-dialog-times",
            onClick: $options.doClear
          }, null, 8, ["onClick"])), [
            [vShow, $options.showClear]
          ]) : createCommentVNode("", true)
        ], 2)) : createCommentVNode("", true)
      ]),
      key: "1"
    } : void 0
  ]), 1032, ["modelValue", "onHide", "onHidding", "onHidden", "width", "z-index", "radius", "use-padding", "animation", "onShow", "onShowing", "onShown", "timeout", "overlay-color", "mount-el"]);
}
const dialogComponent = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["render", _sfc_render$Q], ["__scopeId", "data-v-b9a33bd4"]]);
const dialogPc_vue_vue_type_style_index_0_scoped_7537c68e_lang = "";
const _sfc_main$P = {
  name: "m-dialog-pc",
  data() {
    return {
      ok: false,
      show: true,
      focus: false,
      value: ""
    };
  },
  props: {
    type: {
      type: String,
      default: null
    },
    title: {
      type: String,
      default: null
    },
    message: {
      default: ""
    },
    width: {
      type: String,
      default: null
    },
    zIndex: {
      type: Number,
      default: null
    },
    animation: {
      type: String,
      default: null
    },
    radius: {
      type: String,
      default: null
    },
    overlayColor: {
      type: String,
      default: null
    },
    closable: {
      type: Boolean,
      default: null
    },
    input: {
      type: Object,
      default: null
    },
    center: {
      type: Boolean,
      default: false
    },
    usePadding: {
      type: Boolean,
      default: null
    },
    btns: {
      type: Object,
      default: null
    },
    showTimes: {
      type: Boolean,
      default: null
    },
    mountEl: {
      type: String,
      default: null
    },
    timeout: {
      type: Number,
      default: null
    },
    __remove: {
      type: Function,
      default: function() {
        return function() {
        };
      }
    }
  },
  computed: {
    $$el() {
      return this.$refs.modal.$$el;
    },
    cmpShowTimes() {
      if (typeof this.showTimes == "boolean") {
        return this.showTimes;
      }
      return true;
    },
    cmpTitle() {
      if (typeof this.title == "string") {
        return this.title;
      }
      return "\u63D0\u793A";
    },
    cmpMessage() {
      if (typeof this.message == "string") {
        return this.message;
      }
      if (obj$1.common.isObject(this.message)) {
        return JSON.stringify(this.message);
      }
      return String(this.message);
    },
    cmpBtns() {
      let btns = {
        ok: {
          type: "primary",
          color: null,
          subColor: null,
          plain: false,
          text: "\u786E\u5B9A",
          size: "medium",
          round: false,
          square: false,
          disabled: false,
          loading: false,
          loadText: "loading...",
          loadIcon: {
            type: "load-e",
            spin: true
          }
        },
        cancel: {
          type: "default",
          color: null,
          subColor: null,
          plain: false,
          text: "\u53D6\u6D88",
          size: "medium",
          round: false,
          square: false,
          disabled: false,
          loading: false,
          loadText: "loading...",
          loadIcon: {
            type: "load-e",
            spin: true
          }
        }
      };
      if (obj$1.common.isObject(this.btns)) {
        if (obj$1.common.isObject(this.btns.ok)) {
          if (typeof this.btns.ok.type == "string") {
            btns.ok.type = this.btns.ok.type;
          }
          if (typeof this.btns.ok.color == "string") {
            btns.ok.color = this.btns.ok.color;
          }
          if (typeof this.btns.ok.subColor == "string") {
            btns.ok.subColor = this.btns.ok.subColor;
          }
          if (typeof this.btns.ok.plain == "boolean") {
            btns.ok.plain = this.btns.ok.plain;
          }
          if (typeof this.btns.ok.text == "string") {
            btns.ok.text = this.btns.ok.text;
          }
          if (typeof this.btns.ok.size == "string") {
            btns.ok.size = this.btns.ok.size;
          }
          if (typeof this.btns.ok.round == "boolean") {
            btns.ok.round = this.btns.ok.round;
          }
          if (typeof this.btns.ok.square == "boolean") {
            btns.ok.square = this.btns.ok.square;
          }
          if (typeof this.btns.ok.disabled == "boolean") {
            btns.ok.disabled = this.btns.ok.disabled;
          }
          if (typeof this.btns.ok.loading == "boolean") {
            btns.ok.loading = this.btns.ok.loading;
          }
          if (typeof this.btns.ok.loadText == "string") {
            btns.ok.loadText = this.btns.ok.loadText;
          }
          if (typeof this.btns.ok.loadIcon == "string" || obj$1.common.isObject(this.btns.ok.loadIcon)) {
            btns.ok.loadIcon = this.btns.ok.loadIcon;
          }
        }
        if (obj$1.common.isObject(this.btns.cancel)) {
          if (typeof this.btns.cancel.type == "string") {
            btns.cancel.type = this.btns.cancel.type;
          }
          if (typeof this.btns.cancel.color == "string") {
            btns.cancel.color = this.btns.cancel.color;
          }
          if (typeof this.btns.cancel.subColor == "string") {
            btns.cancel.subColor = this.btns.cancel.subColor;
          }
          if (typeof this.btns.cancel.plain == "boolean") {
            btns.cancel.plain = this.btns.cancel.plain;
          }
          if (typeof this.btns.cancel.text == "string") {
            btns.cancel.text = this.btns.cancel.text;
          }
          if (typeof this.btns.cancel.size == "string") {
            btns.cancel.size = this.btns.cancel.size;
          }
          if (typeof this.btns.cancel.round == "boolean") {
            btns.cancel.round = this.btns.cancel.round;
          }
          if (typeof this.btns.cancel.square == "boolean") {
            btns.cancel.square = this.btns.cancel.square;
          }
          if (typeof this.btns.cancel.disabled == "boolean") {
            btns.cancel.disabled = this.btns.cancel.disabled;
          }
          if (typeof this.btns.cancel.loading == "boolean") {
            btns.cancel.loading = this.btns.cancel.loading;
          }
          if (typeof this.btns.cancel.loadText == "string") {
            btns.cancel.loadText = this.btns.cancel.loadText;
          }
          if (typeof this.btns.cancel.loadIcon == "string" || obj$1.common.isObject(this.btns.cancel.loadIcon)) {
            btns.cancel.loadIcon = this.btns.cancel.loadIcon;
          }
        }
      }
      return btns;
    },
    cmpWidth() {
      if (typeof this.width == "string" && this.width) {
        return this.width;
      }
      return "7.2rem";
    },
    cmpInput() {
      let input = {
        placeholder: "",
        type: "text",
        autofocus: true,
        maxlength: -1,
        clearable: false,
        align: "left",
        value: ""
      };
      if (obj$1.common.isObject(this.input)) {
        if (typeof this.input.placeholder == "string") {
          input.placeholder = this.input.placeholder;
        }
        if (typeof this.input.type == "string" && this.input.type) {
          input.type = this.input.type;
        }
        if (typeof this.input.autofocus == "boolean") {
          input.autofocus = this.input.autofocus;
        }
        if (obj$1.number.isNumber(this.input.maxlength)) {
          input.maxlength = this.input.maxlength;
        }
        if (typeof this.input.clearable == "boolean") {
          input.clearable = this.input.clearable;
        }
        if (typeof this.input.align == "string") {
          input.align = this.input.align;
        }
        if (typeof this.input.value == "string" || obj$1.number.isNumber(this.input.value)) {
          input.value = this.input.value.toString();
        }
      }
      return input;
    },
    cmpZIndex() {
      if (obj$1.number.isNumber(this.zIndex)) {
        return this.zIndex;
      }
      return 1e3;
    },
    cmpUsePadding() {
      if (typeof this.usePadding == "boolean") {
        return this.usePadding;
      }
      return false;
    },
    cmpAnimation() {
      if (typeof this.animation == "string" && this.animation) {
        return this.animation;
      }
      return "translate-top";
    },
    cmpRadius() {
      if (typeof this.radius == "string" && this.radius) {
        return this.radius;
      }
      return "0.12rem";
    },
    cmpOverlayColor() {
      if (typeof this.overlayColor == "string" && this.overlayColor) {
        return this.overlayColor;
      }
      return null;
    },
    cmpClosable() {
      if (typeof this.closable == "boolean") {
        return this.closable;
      }
      return false;
    },
    cmpCenter() {
      if (typeof this.center == "boolean") {
        return this.center;
      }
      return false;
    },
    cmpMountEl() {
      if (typeof this.mountEl == "string" && this.mountEl) {
        return this.mountEl;
      }
      return "body";
    },
    cmpTimeout() {
      if (obj$1.number.isNumber(this.timeout)) {
        return this.timeout;
      }
      return 200;
    },
    contentShow() {
      if (this.type == "Alert" || this.type == "Confirm") {
        if (this.cmpMessage) {
          return true;
        }
        return false;
      }
      return true;
    },
    showClear() {
      return this.focus && this.value;
    },
    inputClass() {
      let cls = [];
      if (this.showClear && this.cmpInput.clearable) {
        cls.push("mvi-dialog-input-padding");
      }
      return cls;
    },
    inputStyle() {
      let style = {};
      if (["left", "right", "center"].includes(this.cmpInput.align)) {
        style.textAlign = this.cmpInput.align;
      }
      return style;
    }
  },
  components: {
    Icon,
    Modal,
    Button
  },
  created() {
    if (this.type == "Prompt") {
      this.setDefaultValue();
    }
  },
  mounted() {
    obj$1.event.on(this.$$el, "click.dialog", this.overlayClick);
  },
  methods: {
    overlayClick(event2) {
      if (!this.cmpClosable) {
        return;
      }
      if (event2.target != event2.currentTarget) {
        return;
      }
      this.show = false;
      this.ok = false;
    },
    setDefaultValue() {
      let value = this.cmpInput.value;
      if (this.cmpInput.type == "number") {
        value = value.replace(/\D/g, "");
      }
      if (this.cmpInput.maxlength > 0 && value.length > this.cmpInput.maxlength) {
        value = value.substring(0, this.cmpInput.maxlength);
      }
      this.value = value;
    },
    inputFocus() {
      this.focus = true;
    },
    inputBlur() {
      setTimeout(() => {
        this.focus = false;
      }, 100);
    },
    inputFun() {
      let value = this.value;
      if (this.cmpInput.type == "number") {
        value = value.replace(/\D/g, "");
      }
      if (this.cmpInput.maxlength > 0 && value.length > this.cmpInput.maxlength) {
        value = value.substring(0, this.cmpInput.maxlength);
      }
      this.value = value;
    },
    doClear() {
      if (!this.cmpInput.clearable) {
        return;
      }
      setTimeout(() => {
        this.value = "";
        this.$refs.input.focus();
      }, 110);
    },
    okFun() {
      this.show = false;
      this.ok = true;
    },
    cancelFun() {
      this.show = false;
      this.ok = false;
    },
    modalHide(el) {
      if (typeof this.dialogComponentWatch == "function") {
        this.dialogComponentWatch.apply(this, ["hide", this.type, el]);
      }
    },
    modalHidding(el) {
      if (typeof this.dialogComponentWatch == "function") {
        this.dialogComponentWatch.apply(this, ["hidding", this.type, el]);
      }
    },
    modalHidden(el) {
      if (typeof this.dialogComponentWatch == "function") {
        this.dialogComponentWatch.apply(this, ["hidden", this.type, el]);
      }
      if (this.type == "Alert") {
        this.__remove();
      } else if (this.type == "Confirm") {
        this.__remove(this.ok);
      } else if (this.type == "Prompt") {
        this.__remove(this.ok, this.value);
      }
    },
    modalShow(el) {
      if (typeof this.dialogComponentWatch == "function") {
        this.dialogComponentWatch.apply(this, ["show", this.type, el]);
      }
    },
    modalShowing(el) {
      if (typeof this.dialogComponentWatch == "function") {
        this.dialogComponentWatch.apply(this, ["showing", this.type, el]);
      }
    },
    modalShown(el) {
      if (this.type == "Prompt" && this.cmpInput.autofocus && this.$refs.input) {
        this.$refs.input.focus();
      }
      if (typeof this.dialogComponentWatch == "function") {
        this.dialogComponentWatch.apply(this, ["shown", this.type, el]);
      }
    }
  }
};
const _hoisted_1$A = ["innerHTML"];
const _hoisted_2$w = ["innerHTML"];
const _hoisted_3$q = {
  key: 1,
  class: "mvi-dialog-input"
};
const _hoisted_4$j = ["type", "placeholder", "maxlength"];
function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_Button = resolveComponent("Button");
  const _component_Modal = resolveComponent("Modal");
  return openBlock(), createBlock(_component_Modal, {
    ref: "modal",
    modelValue: $data.show,
    "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => $data.show = $event),
    "show-times": $options.cmpShowTimes,
    onHide: $options.modalHide,
    onHidding: $options.modalHidding,
    onHidden: $options.modalHidden,
    width: $options.cmpWidth,
    "z-index": $options.cmpZIndex,
    radius: $options.cmpRadius,
    "use-padding": $options.cmpUsePadding,
    animation: $options.cmpAnimation,
    onShow: $options.modalShow,
    onShowing: $options.modalShowing,
    onShown: $options.modalShown,
    timeout: $options.cmpTimeout,
    "overlay-color": $options.cmpOverlayColor,
    "mount-el": $options.cmpMountEl,
    center: $options.cmpCenter
  }, createSlots({ _: 2 }, [
    $options.cmpTitle ? {
      name: "title",
      fn: withCtx(() => [
        createElementVNode("div", {
          innerHTML: $options.cmpTitle,
          class: "mvi-dialog-title"
        }, null, 8, _hoisted_1$A)
      ]),
      key: "0"
    } : void 0,
    $options.contentShow ? {
      name: "default",
      fn: withCtx(() => [
        $options.cmpMessage ? (openBlock(), createElementBlock("div", {
          key: 0,
          innerHTML: $options.cmpMessage,
          class: normalizeClass(["mvi-dialog-content", $props.center ? "center" : ""])
        }, null, 10, _hoisted_2$w)) : createCommentVNode("", true),
        $props.type == "Prompt" ? (openBlock(), createElementBlock("div", _hoisted_3$q, [
          withDirectives(createElementVNode("input", {
            ref: "input",
            type: $options.cmpInput.type == "number" ? "text" : $options.cmpInput.type,
            placeholder: $options.cmpInput.placeholder,
            maxlength: $options.cmpInput.maxlength,
            class: normalizeClass($options.inputClass),
            style: normalizeStyle($options.inputStyle),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.value = $event),
            onInput: _cache[1] || (_cache[1] = (...args) => $options.inputFun && $options.inputFun(...args)),
            onFocus: _cache[2] || (_cache[2] = (...args) => $options.inputFocus && $options.inputFocus(...args)),
            onBlur: _cache[3] || (_cache[3] = (...args) => $options.inputBlur && $options.inputBlur(...args)),
            onKeyup: _cache[4] || (_cache[4] = withKeys((...args) => $options.okFun && $options.okFun(...args), ["enter"]))
          }, null, 46, _hoisted_4$j), [
            [
              vModelDynamic,
              $data.value,
              void 0,
              { trim: true }
            ]
          ]),
          $options.cmpInput.clearable ? withDirectives((openBlock(), createBlock(_component_Icon, {
            key: 0,
            ref: "icon",
            type: "times-o",
            class: "mvi-dialog-times",
            onClick: $options.doClear
          }, null, 8, ["onClick"])), [
            [vShow, $options.showClear]
          ]) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        createElementVNode("div", {
          class: normalizeClass(["mvi-dialog-footer", $props.center ? "center" : ""])
        }, [
          $props.type != "Alert" ? (openBlock(), createBlock(_component_Button, {
            key: 0,
            type: $options.cmpBtns.cancel.type,
            color: $options.cmpBtns.cancel.color,
            "sub-color": $options.cmpBtns.cancel.subColor,
            plain: $options.cmpBtns.cancel.plain,
            class: "mvi-dialog-cancel",
            onClick: $options.cancelFun,
            size: $options.cmpBtns.cancel.size,
            round: $options.cmpBtns.cancel.round,
            square: $options.cmpBtns.cancel.square,
            loading: $options.cmpBtns.cancel.loading,
            "load-text": $options.cmpBtns.cancel.loadText,
            "load-icon": $options.cmpBtns.cancel.loadIcon,
            disabled: $options.cmpBtns.cancel.disabled
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString($options.cmpBtns.cancel.text), 1)
            ]),
            _: 1
          }, 8, ["type", "color", "sub-color", "plain", "onClick", "size", "round", "square", "loading", "load-text", "load-icon", "disabled"])) : createCommentVNode("", true),
          createVNode(_component_Button, {
            type: $options.cmpBtns.ok.type,
            color: $options.cmpBtns.ok.color,
            "sub-color": $options.cmpBtns.ok.subColor,
            plain: $options.cmpBtns.ok.plain,
            onClick: $options.okFun,
            size: $options.cmpBtns.ok.size,
            round: $options.cmpBtns.ok.round,
            square: $options.cmpBtns.ok.square,
            loading: $options.cmpBtns.ok.loading,
            "load-text": $options.cmpBtns.ok.loadText,
            "load-icon": $options.cmpBtns.ok.loadIcon,
            disabled: $options.cmpBtns.ok.disabled
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString($options.cmpBtns.ok.text), 1)
            ]),
            _: 1
          }, 8, ["type", "color", "sub-color", "plain", "onClick", "size", "round", "square", "loading", "load-text", "load-icon", "disabled"])
        ], 2)
      ]),
      key: "1"
    } : void 0
  ]), 1032, ["modelValue", "show-times", "onHide", "onHidding", "onHidden", "width", "z-index", "radius", "use-padding", "animation", "onShow", "onShowing", "onShown", "timeout", "overlay-color", "mount-el", "center"]);
}
const dialogPcComponent = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["render", _sfc_render$P], ["__scopeId", "data-v-7537c68e"]]);
const Dialog = {
  initParams: (type, options) => {
    let opts = {};
    if (obj$1.common.isObject(options)) {
      opts.title = options.title;
      opts.message = options.message;
      opts.width = options.width;
      opts.zIndex = options.zIndex;
      opts.animation = options.animation;
      opts.radius = options.radius;
      opts.overlayColor = options.overlayColor;
      opts.closable = options.closable;
      opts.input = options.input;
      opts.usePadding = options.usePadding;
      opts.mountEl = options.mountEl;
      opts.timeout = options.timeout;
      if (type == "alert" || type == "confirm" || type == "prompt") {
        opts.btnText = options.btnText;
        opts.btnColor = options.btnColor;
        opts.ios = options.ios;
      } else if (type == "Alert" || type == "Confirm" || type == "Prompt") {
        opts.center = options.center;
        opts.btns = options.btns;
        opts.showTimes = options.showTimes;
      }
    } else {
      opts.message = options;
    }
    opts.type = type;
    return opts;
  },
  alert: function(options) {
    return new Promise((resolve) => {
      let opts = Dialog.initParams("alert", options);
      let mountNode = obj$1.element.string2dom("<div></div>");
      document.body.appendChild(mountNode);
      const instance = createApp(dialogComponent, {
        ...opts,
        __remove: () => {
          instance.unmount();
          mountNode.remove();
          resolve();
        }
      });
      if (this && this.config && this.config.globalProperties && typeof this.config.globalProperties.dialogComponentWatch == "function") {
        instance.config.globalProperties.dialogComponentWatch = this.config.globalProperties.dialogComponentWatch;
      }
      instance.mount(mountNode);
    });
  },
  confirm: function(options) {
    return new Promise((resolve) => {
      let opts = Dialog.initParams("confirm", options);
      let mountNode = obj$1.element.string2dom("<div></div>");
      document.body.appendChild(mountNode);
      const instance = createApp(dialogComponent, {
        ...opts,
        __remove: (ok) => {
          instance.unmount();
          mountNode.remove();
          resolve(ok);
        }
      });
      if (this && this.config && this.config.globalProperties && typeof this.config.globalProperties.dialogComponentWatch == "function") {
        instance.config.globalProperties.dialogComponentWatch = this.config.globalProperties.dialogComponentWatch;
      }
      instance.mount(mountNode);
    });
  },
  prompt: function(options) {
    return new Promise((resolve) => {
      let opts = Dialog.initParams("prompt", options);
      let mountNode = obj$1.element.string2dom("<div></div>");
      document.body.appendChild(mountNode);
      const instance = createApp(dialogComponent, {
        ...opts,
        __remove: (ok, value) => {
          instance.unmount();
          mountNode.remove();
          resolve({
            ok,
            value
          });
        }
      });
      if (this && this.config && this.config.globalProperties && typeof this.config.globalProperties.dialogComponentWatch == "function") {
        instance.config.globalProperties.dialogComponentWatch = this.config.globalProperties.dialogComponentWatch;
      }
      instance.mount(mountNode);
    });
  },
  Alert: function(options) {
    return new Promise((resolve) => {
      let opts = Dialog.initParams("Alert", options);
      let mountNode = obj$1.element.string2dom("<div></div>");
      document.body.appendChild(mountNode);
      const instance = createApp(dialogPcComponent, {
        ...opts,
        __remove: () => {
          instance.unmount();
          mountNode.remove();
          resolve();
        }
      });
      if (this && this.config && this.config.globalProperties && typeof this.config.globalProperties.dialogComponentWatch == "function") {
        instance.config.globalProperties.dialogComponentWatch = this.config.globalProperties.dialogComponentWatch;
      }
      instance.mount(mountNode);
    });
  },
  Confirm: function(options) {
    return new Promise((resolve) => {
      let opts = Dialog.initParams("Confirm", options);
      let mountNode = obj$1.element.string2dom("<div></div>");
      document.body.appendChild(mountNode);
      const instance = createApp(dialogPcComponent, {
        ...opts,
        __remove: (ok) => {
          instance.unmount();
          mountNode.remove();
          resolve(ok);
        }
      });
      if (this && this.config && this.config.globalProperties && typeof this.config.globalProperties.dialogComponentWatch == "function") {
        instance.config.globalProperties.dialogComponentWatch = this.config.globalProperties.dialogComponentWatch;
      }
      instance.mount(mountNode);
    });
  },
  Prompt: function(options) {
    return new Promise((resolve) => {
      let opts = Dialog.initParams("Prompt", options);
      let mountNode = obj$1.element.string2dom("<div></div>");
      document.body.appendChild(mountNode);
      const instance = createApp(dialogPcComponent, {
        ...opts,
        __remove: (ok, value) => {
          instance.unmount();
          mountNode.remove();
          resolve({
            ok,
            value
          });
        }
      });
      if (this && this.config && this.config.globalProperties && typeof this.config.globalProperties.dialogComponentWatch == "function") {
        instance.config.globalProperties.dialogComponentWatch = this.config.globalProperties.dialogComponentWatch;
      }
      instance.mount(mountNode);
    });
  },
  install: (app) => {
    app.config.globalProperties.$alert = Dialog.alert.bind(app);
    app.provide("$alert", Dialog.alert.bind(app));
    app.config.globalProperties.$confirm = Dialog.confirm.bind(app);
    app.provide("$confirm", Dialog.confirm.bind(app));
    app.config.globalProperties.$prompt = Dialog.prompt.bind(app);
    app.provide("$prompt", Dialog.prompt.bind(app));
    app.config.globalProperties.$Alert = Dialog.Alert.bind(app);
    app.provide("$Alert", Dialog.Alert.bind(app));
    app.config.globalProperties.$Confirm = Dialog.Confirm.bind(app);
    app.provide("$Confirm", Dialog.Confirm.bind(app));
    app.config.globalProperties.$Prompt = Dialog.Prompt.bind(app);
    app.provide("$Prompt", Dialog.Prompt.bind(app));
  }
};
const toast_vue_vue_type_style_index_0_scoped_ff635be3_lang = "";
const _sfc_main$O = {
  name: "m-toast",
  data() {
    return {
      show: true,
      timer: null
    };
  },
  inheritAttrs: false,
  props: {
    type: {
      type: String,
      default: null
    },
    message: {
      default: null
    },
    timeout: {
      type: Number,
      default: null
    },
    overlayColor: {
      type: String,
      default: null
    },
    background: {
      type: String,
      default: null
    },
    color: {
      type: String,
      default: null
    },
    zIndex: {
      type: Number,
      default: null
    },
    usePadding: {
      type: Boolean,
      default: null
    },
    icon: {
      type: [String, Object],
      default: null
    },
    mountEl: {
      type: String,
      default: null
    },
    shadow: {
      type: Boolean,
      default: null
    },
    __remove: {
      type: Function,
      default: function() {
        return function() {
        };
      }
    },
    __init: {
      type: Function,
      default: function() {
        return function() {
        };
      }
    }
  },
  computed: {
    $$el() {
      return this.$refs.overlay.$$el;
    },
    cmpUsePadding() {
      if (typeof this.usePadding == "boolean") {
        return this.usePadding;
      }
      return false;
    },
    cmpType() {
      if (["success", "error", "loading", "info"].includes(this.type)) {
        return this.type;
      }
      return "info";
    },
    defaultIconType() {
      if (this.cmpType == "success") {
        return "success";
      }
      if (this.cmpType == "error") {
        return "error-o";
      }
      if (this.cmpType == "info") {
        return "info-o";
      }
      if (this.cmpType == "loading") {
        return null;
      }
    },
    cmpIcon() {
      let icon = {
        type: this.defaultIconType,
        url: null,
        spin: false,
        size: "0.72rem",
        color: null
      };
      if (typeof this.icon == "string" && this.icon) {
        icon.type = this.icon;
      } else if (obj$1.common.isObject(this.icon)) {
        if (typeof this.icon.type == "string" && this.icon.type) {
          icon.type = this.icon.type;
        }
        if (typeof this.icon.url == "string" && this.icon.url) {
          icon.url = this.icon.url;
        }
        if (typeof this.icon.spin == "boolean") {
          icon.spin = this.icon.spin;
        }
        if (typeof this.icon.size == "string" && this.icon.size) {
          icon.size = this.icon.size;
        }
        if (typeof this.icon.color == "string" && this.icon.color) {
          icon.color = this.icon.color;
        }
      }
      return icon;
    },
    cmpMessage() {
      if (typeof this.message == "string" && this.message) {
        return this.message;
      }
      if (obj$1.common.isObject(this.message)) {
        return JSON.stringify(this.message);
      }
      if (this.message == void 0 || this.message == null) {
        return "";
      }
      return String(this.message);
    },
    cmpTimeout() {
      if (obj$1.number.isNumber(this.timeout) && this.timeout > 0) {
        return this.timeout;
      }
      return 0;
    },
    cmpZIndex() {
      if (obj$1.number.isNumber(this.zIndex)) {
        return this.zIndex;
      }
      return 1100;
    },
    cmpOverlayColor() {
      if (typeof this.overlayColor == "string" && this.overlayColor) {
        return this.overlayColor;
      }
      return "rgba(0, 10, 20, .05)";
    },
    cmpBackground() {
      if (typeof this.background == "string" && this.background) {
        return this.background;
      }
      return null;
    },
    cmpColor() {
      if (typeof this.color == "string" && this.color) {
        return this.color;
      }
      return "#fff";
    },
    cmpMountEl() {
      if (typeof this.mountEl == "string" && this.mountEl) {
        return this.mountEl;
      }
      return "body";
    },
    cmpShadow() {
      if (typeof this.shadow == "boolean") {
        return this.shadow;
      }
      return true;
    },
    toastStyle() {
      let style = {
        zIndex: this.cmpZIndex
      };
      if (this.cmpBackground) {
        style.backgroundColor = this.cmpBackground;
      }
      if (this.cmpColor) {
        style.color = this.cmpColor;
      }
      return style;
    }
  },
  components: {
    Icon,
    Loading,
    Overlay
  },
  mounted() {
    this.__init(this);
  },
  methods: {
    toastShown() {
      if (this.cmpTimeout > 0) {
        this.timer = setTimeout(() => {
          this.show = false;
        }, this.cmpTimeout);
      }
    },
    toastHidden() {
      this.clearTimer();
      this.__remove();
    },
    clearTimer() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
    }
  }
};
const _hoisted_1$z = { class: "mvi-toast-icon" };
const _hoisted_2$v = ["innerHTML"];
function _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Loading = resolveComponent("Loading");
  const _component_Icon = resolveComponent("Icon");
  const _component_Overlay = resolveComponent("Overlay");
  return openBlock(), createBlock(_component_Overlay, {
    ref: "overlay",
    color: $options.cmpOverlayColor,
    onHidden: $options.toastHidden,
    modelValue: $data.show,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.show = $event),
    "use-padding": $options.cmpUsePadding,
    zIndex: $options.cmpZIndex,
    fade: "",
    "mount-el": $options.cmpMountEl,
    onShown: $options.toastShown
  }, {
    default: withCtx(() => [
      createElementVNode("div", mergeProps({
        class: ["mvi-toast", $options.cmpMessage ? "" : "iconless", $options.cmpShadow ? "shadow" : ""],
        style: $options.toastStyle
      }, _ctx.$attrs), [
        createElementVNode("div", _hoisted_1$z, [
          $options.cmpType == "loading" && !$options.cmpIcon.type && !$options.cmpIcon.url ? (openBlock(), createBlock(_component_Loading, {
            key: 0,
            color: $options.cmpColor,
            size: $options.cmpIcon.size
          }, null, 8, ["color", "size"])) : (openBlock(), createBlock(_component_Icon, {
            key: 1,
            type: $options.cmpIcon.type,
            url: $options.cmpIcon.url,
            spin: $options.cmpIcon.spin,
            size: $options.cmpIcon.size,
            color: $options.cmpIcon.color
          }, null, 8, ["type", "url", "spin", "size", "color"]))
        ]),
        $options.cmpMessage ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "mvi-toast-message",
          innerHTML: $options.cmpMessage
        }, null, 8, _hoisted_2$v)) : createCommentVNode("", true)
      ], 16)
    ]),
    _: 1
  }, 8, ["color", "onHidden", "modelValue", "use-padding", "zIndex", "mount-el", "onShown"]);
}
const ToastComponent = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["render", _sfc_render$O], ["__scopeId", "data-v-ff635be3"]]);
const Toast = {
  initParams: (options) => {
    let opts = {};
    if (obj$1.common.isObject(options)) {
      opts.type = options.type;
      opts.message = options.message;
      opts.timeout = options.timeout;
      opts.overlayColor = options.overlayColor;
      opts.background = options.background;
      opts.color = options.color;
      opts.zIndex = options.zIndex;
      opts.usePadding = options.usePadding;
      opts.icon = options.icon;
      opts.mountEl = options.mountEl;
      opts.shadow = options.shadow;
    } else {
      opts.message = options;
      opts.timeout = 1500;
    }
    return opts;
  },
  showToast: (options) => {
    return new Promise((resolve, reject) => {
      if (Toast.$el && Toast.$instance) {
        Toast.$instance.unmount();
        Toast.$el.remove();
      }
      let opts = Toast.initParams(options);
      let mountNode = obj$1.element.string2dom("<div></div>");
      document.body.appendChild(mountNode);
      const instance = createApp(ToastComponent, {
        ...opts,
        __init: (vm) => {
          Toast.$vm = vm;
        },
        __remove: () => {
          instance.unmount();
          mountNode.remove();
          resolve();
        }
      });
      instance.mount(mountNode);
      Toast.$el = mountNode;
      Toast.$instance = instance;
    });
  },
  hideToast: () => {
    if (Toast.$vm) {
      Toast.$vm.show = false;
    }
  },
  install: (app) => {
    app.config.globalProperties.$showToast = Toast.showToast;
    app.provide("$showToast", Toast.showToast);
    app.config.globalProperties.$hideToast = Toast.hideToast;
    app.provide("$hideToast", Toast.hideToast);
  }
};
const msgbox_vue_vue_type_style_index_0_scoped_4d410ae1_lang = "";
const _sfc_main$N = {
  name: "m-msgbox",
  data() {
    return {
      show: false
    };
  },
  inheritAttrs: false,
  props: {
    message: {
      default: null
    },
    animation: {
      type: String,
      default: null
    },
    timeout: {
      type: Number,
      default: null
    },
    zIndex: {
      type: Number,
      default: null
    },
    background: {
      type: String,
      default: null
    },
    color: {
      type: String,
      default: null
    },
    __remove: {
      type: Function,
      default: function() {
        return function() {
        };
      }
    }
  },
  computed: {
    cpmMessage() {
      if (typeof this.message == "string") {
        return this.message;
      }
      if (obj$1.common.isObject(this.message)) {
        return JSON.stringify(this.message);
      }
      return String(this.message);
    },
    cmpAnimation() {
      if (typeof this.animation == "string" && this.animation) {
        return this.animation;
      }
      return "fade";
    },
    cmpTimeout() {
      if (obj$1.number.isNumber(this.timeout)) {
        return this.timeout;
      }
      return 1500;
    },
    cmpZIndex() {
      if (obj$1.number.isNumber(this.zIndex)) {
        return this.zIndex;
      }
      return 1100;
    },
    cmpBackground() {
      if (typeof this.background == "string" && this.background) {
        return this.background;
      }
      return null;
    },
    cmpColor() {
      if (typeof this.color == "string" && this.color) {
        return this.color;
      }
      return null;
    },
    msgboxStyle() {
      let style = {
        zIndex: this.cmpZIndex
      };
      if (this.cmpBackground) {
        style.backgroundColor = this.cmpBackground;
      }
      if (this.cmpColor) {
        style.color = this.cmpColor;
      }
      return style;
    },
    msgboxClass() {
      let cls = ["mvi-msgbox"];
      if (this.cmpAnimation == "translate") {
        cls.push("mvi-msgbox-translate");
      }
      return cls;
    }
  },
  mounted() {
    this.show = true;
  },
  methods: {
    afterEnter() {
      if (this.cmpTimeout > 0) {
        setTimeout(() => {
          this.show = false;
        }, this.cmpTimeout);
      }
    },
    afterLeave() {
      this.__remove();
    }
  }
};
const _hoisted_1$y = ["textContent"];
function _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Teleport, { to: "body" }, [
    createVNode(Transition, {
      name: "mvi-msgbox-" + $options.cmpAnimation,
      onAfterEnter: $options.afterEnter,
      onAfterLeave: $options.afterLeave
    }, {
      default: withCtx(() => [
        withDirectives(createElementVNode("div", mergeProps(_ctx.$attrs, {
          class: $options.msgboxClass,
          textContent: toDisplayString($options.cpmMessage),
          style: $options.msgboxStyle
        }), null, 16, _hoisted_1$y), [
          [vShow, $data.show]
        ])
      ]),
      _: 1
    }, 8, ["name", "onAfterEnter", "onAfterLeave"])
  ]);
}
const MsgboxComponent = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["render", _sfc_render$N], ["__scopeId", "data-v-4d410ae1"]]);
const Msgbox = {
  initParams: (options) => {
    let opts = {};
    if (obj$1.common.isObject(options)) {
      opts.message = options.message;
      opts.timeout = options.timeout;
      opts.animation = options.animation;
      opts.zIndex = options.zIndex;
      opts.color = options.color;
      opts.background = options.background;
    } else {
      opts.message = options;
    }
    return opts;
  },
  msgbox: (options) => {
    return new Promise((resolve) => {
      let opts = Msgbox.initParams(options);
      let mountNode = obj$1.element.string2dom("<div></div>");
      document.body.appendChild(mountNode);
      const instance = createApp(MsgboxComponent, {
        ...opts,
        __remove: () => {
          instance.unmount();
          mountNode.remove();
          resolve();
        }
      });
      instance.mount(mountNode);
    });
  },
  install: (app) => {
    app.config.globalProperties.$msgbox = Msgbox.msgbox;
    app.provide("$msgbox", Msgbox.msgbox);
  }
};
const numberKeyboard_vue_vue_type_style_index_0_scoped_96ebe1e8_lang = "";
const _sfc_main$M = {
  name: "m-number-keyboard",
  data() {
    return {
      firstShow: false,
      keyboardShow: false,
      numbers: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "X", ".", "0"]
    };
  },
  emits: ["update:modelValue", "update:show", "input", "delete", "complete", "show", "showing", "shown", "hide", "hidding", "hidden"],
  inheritAttrs: false,
  props: {
    showDecimal: {
      type: Boolean,
      default: true
    },
    showDelete: {
      type: Boolean,
      default: true
    },
    showComplete: {
      type: Boolean,
      default: true
    },
    show: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: [String, Number],
      default: ""
    },
    zIndex: {
      type: Number,
      default: 850
    },
    timeout: {
      type: Number,
      default: 200
    },
    closable: {
      type: Boolean,
      default: false
    },
    maxlength: {
      type: Number,
      default: -1
    },
    deleteText: {
      type: String,
      default: "\u5220\u9664"
    },
    completeText: {
      type: String,
      default: "\u5B8C\u6210"
    },
    promiseEmpty: {
      type: Boolean,
      default: false
    },
    active: {
      type: Boolean,
      default: true
    },
    mountEl: {
      type: String,
      default: null
    },
    overlayColor: {
      type: String,
      default: "rgba(0,10,20,0.2)"
    },
    usePadding: {
      type: Boolean,
      default: false
    },
    calibration: {
      type: Boolean,
      default: false
    },
    showX: {
      type: Boolean,
      default: false
    },
    random: {
      type: Boolean,
      default: false
    },
    title: {
      type: String,
      default: null
    },
    border: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    $$el() {
      return this.$refs.overlay.$$el;
    },
    cmpShow: {
      set(value) {
        this.$emit("update:show", value);
      },
      get() {
        return this.show;
      }
    },
    cmpValue: {
      set(value) {
        this.$emit("update:modelValue", value);
      },
      get() {
        if (obj$1.number.isNumber(this.modelValue)) {
          return this.modelValue.toString();
        }
        return this.modelValue;
      }
    },
    boardStyle() {
      return {
        transition: "all " + this.timeout + "ms",
        zIndex: this.zIndex + 10
      };
    },
    deleteDisabeld() {
      if (this.modelValue === "") {
        return true;
      }
      return false;
    },
    completeDisabled() {
      if (this.modelValue === "") {
        return true;
      }
      return false;
    },
    leftNumberClass() {
      return (item, index) => {
        let cls = ["mvi-number-keyboard-left-number"];
        if (index == this.cpmNumbers.length - 1) {
          if (this.showX || this.showDecimal) {
            cls.push("half");
          } else {
            cls.push("full");
          }
        }
        if (this.border) {
          cls.push("border");
        }
        return cls;
      };
    },
    leftNumberElClass() {
      return () => {
        let cls = ["mvi-number-keyboard-left-number-el"];
        if (this.active) {
          cls.push("active");
        }
        return cls;
      };
    },
    deleteBtnClass() {
      let cls = ["mvi-number-keyboard-delete"];
      if (this.border) {
        cls.push("border");
      }
      return cls;
    },
    deleteBtnElClass() {
      let cls = ["mvi-number-keyboard-delete-el"];
      if (this.active && !this.deleteDisabeld) {
        cls.push("active");
      }
      return cls;
    },
    completeBtnClass() {
      let cls = ["mvi-number-keyboard-complete"];
      if (this.border) {
        cls.push("border");
      }
      return cls;
    },
    completeBtnElClass() {
      let cls = ["mvi-number-keyboard-complete-el"];
      if (this.active && !(this.promiseEmpty ? false : this.completeDisabled)) {
        cls.push("active");
      }
      return cls;
    },
    showKeyBoard() {
      return (item) => {
        if (item == "X") {
          return this.showX;
        }
        if (item == ".") {
          return this.showDecimal && !this.showX;
        }
        return true;
      };
    },
    cpmNumbers() {
      if (this.show) {
        let numbers = this.numbers.filter((item) => {
          return this.showKeyBoard(item);
        });
        if (this.random) {
          let arr = [];
          let length = numbers.length;
          for (let i = 0; i < length; i++) {
            arr.push(this.getRandomNumber(arr));
          }
          return arr;
        }
        return numbers;
      }
      return this.numbers;
    }
  },
  components: {
    Overlay
  },
  methods: {
    getRandomNumber(arr) {
      let numbers = this.numbers.filter((item) => {
        return this.showKeyBoard(item);
      });
      let index = Math.floor(Math.random() * numbers.length);
      if (arr.includes(numbers[index])) {
        return this.getRandomNumber(arr);
      }
      return numbers[index];
    },
    overlayShow() {
      if (!this.firstShow) {
        this.firstShow = true;
      }
      this.keyboardShow = true;
    },
    overlayHide() {
      this.keyboardShow = false;
    },
    numberClick(item) {
      if (this.cmpValue.length >= this.maxlength && this.maxlength > 0) {
        return;
      }
      this.cmpValue += item;
      this.$emit("input", item);
    },
    deleteClick() {
      if (this.deleteDisabeld) {
        return;
      }
      let value = obj$1.string.delete(this.cmpValue, this.cmpValue.length - 1, 1);
      this.cmpValue = value;
      this.$emit("delete", value);
    },
    completeClick() {
      if (this.completeDisabled && !this.promiseEmpty) {
        return;
      }
      if (this.calibration) {
        this.cmpValue = parseFloat(this.cmpValue) || "";
      }
      this.$emit("complete", this.cmpValue);
      this.cmpShow = false;
    },
    beforeEnter(el) {
      if (obj$1.data.get(el, "mvi-keyboard-beforeEnter-trigger")) {
        return;
      }
      obj$1.data.set(el, "mvi-keyboard-beforeEnter-trigger", true);
      this.$emit("show", el);
      if (typeof this.keyboardComponentWatch == "function") {
        this.keyboardComponentWatch.apply(this, ["show", el]);
      }
    },
    enter(el) {
      if (obj$1.data.get(el, "mvi-keyboard-enter-trigger")) {
        return;
      }
      obj$1.data.set(el, "mvi-keyboard-enter-trigger", true);
      this.$emit("showing", el);
      if (typeof this.keyboardComponentWatch == "function") {
        this.keyboardComponentWatch.apply(this, ["showing", el]);
      }
    },
    afterEnter(el) {
      this.$emit("shown", el);
      if (typeof this.keyboardComponentWatch == "function") {
        this.keyboardComponentWatch.apply(this, ["shown", el]);
      }
    },
    beforeLeave(el) {
      obj$1.data.remove(el, "mvi-keyboard-beforeEnter-trigger");
      obj$1.data.remove(el, "mvi-keyboard-enter-trigger");
      this.$emit("hide", el);
      if (typeof this.keyboardComponentWatch == "function") {
        this.keyboardComponentWatch.apply(this, ["hide", el]);
      }
    },
    leave(el) {
      this.$emit("hidding", el);
      if (typeof this.keyboardComponentWatch == "function") {
        this.keyboardComponentWatch.apply(this, ["hidding", el]);
      }
    },
    afterLeave(el) {
      this.$emit("hidden", el);
      if (typeof this.keyboardComponentWatch == "function") {
        this.keyboardComponentWatch.apply(this, ["hidden", el]);
      }
    }
  }
};
const _hoisted_1$x = {
  key: 0,
  class: "mvi-number-keyboard-title"
};
const _hoisted_2$u = { key: 1 };
const _hoisted_3$p = { class: "mvi-number-keyboard-left" };
const _hoisted_4$i = ["onClick"];
const _hoisted_5$d = {
  key: 0,
  class: "mvi-number-keyboard-right"
};
const _hoisted_6$a = ["disabled"];
const _hoisted_7$9 = ["textContent"];
const _hoisted_8$8 = ["disabled"];
const _hoisted_9$5 = ["textContent"];
function _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Overlay = resolveComponent("Overlay");
  return openBlock(), createBlock(_component_Overlay, {
    ref: "overlay",
    modelValue: $options.cmpShow,
    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $options.cmpShow = $event),
    onShow: $options.overlayShow,
    onHide: $options.overlayHide,
    "z-index": $props.zIndex,
    color: $props.overlayColor,
    closable: $props.closable,
    timeout: $props.timeout,
    "mount-el": $props.mountEl,
    "use-padding": $props.usePadding
  }, {
    default: withCtx(() => [
      createVNode(Transition, {
        name: "mvi-keyboard",
        onBeforeEnter: $options.beforeEnter,
        onAfterEnter: $options.afterEnter,
        onBeforeLeave: $options.beforeLeave,
        onAfterLeave: $options.afterLeave,
        onLeave: $options.leave,
        onEnter: $options.enter
      }, {
        default: withCtx(() => [
          $data.firstShow ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: "keyboard",
            class: "mvi-number-keyboard",
            style: $options.boardStyle
          }, _ctx.$attrs), [
            !$props.border && ($props.title || _ctx.$slots.title) ? (openBlock(), createElementBlock("div", _hoisted_1$x, [
              _ctx.$slots.title ? renderSlot(_ctx.$slots, "default", { key: 0 }, void 0, true) : (openBlock(), createElementBlock("span", _hoisted_2$u, toDisplayString($props.title), 1))
            ])) : createCommentVNode("", true),
            createElementVNode("div", {
              class: normalizeClass(["mvi-number-keyboard-wrapper", $props.border ? "" : "border"])
            }, [
              createElementVNode("div", _hoisted_3$p, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($options.cpmNumbers, (item, index) => {
                  return openBlock(), createElementBlock("div", {
                    class: normalizeClass($options.leftNumberClass(item, index))
                  }, [
                    createElementVNode("div", {
                      onClick: ($event) => $options.numberClick(item),
                      class: normalizeClass($options.leftNumberElClass(item, index))
                    }, toDisplayString(item), 11, _hoisted_4$i)
                  ], 2);
                }), 256))
              ]),
              $props.showComplete || $props.showDelete ? (openBlock(), createElementBlock("div", _hoisted_5$d, [
                $props.showDelete ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass($options.deleteBtnClass)
                }, [
                  createElementVNode("div", {
                    disabled: $options.deleteDisabeld || null,
                    class: normalizeClass($options.deleteBtnElClass),
                    onClick: _cache[0] || (_cache[0] = (...args) => $options.deleteClick && $options.deleteClick(...args))
                  }, [
                    _ctx.$slots.delete ? renderSlot(_ctx.$slots, "delete", { key: 0 }, void 0, true) : (openBlock(), createElementBlock("span", {
                      key: 1,
                      textContent: toDisplayString($props.deleteText)
                    }, null, 8, _hoisted_7$9))
                  ], 10, _hoisted_6$a)
                ], 2)) : createCommentVNode("", true),
                $props.showComplete ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass($options.completeBtnClass)
                }, [
                  createElementVNode("div", {
                    disabled: $props.promiseEmpty ? null : $options.completeDisabled || null,
                    class: normalizeClass($options.completeBtnElClass),
                    onClick: _cache[1] || (_cache[1] = (...args) => $options.completeClick && $options.completeClick(...args))
                  }, [
                    _ctx.$slots.complete ? renderSlot(_ctx.$slots, "complete", { key: 0 }, void 0, true) : createCommentVNode("", true),
                    createElementVNode("span", {
                      textContent: toDisplayString($props.completeText)
                    }, null, 8, _hoisted_9$5)
                  ], 10, _hoisted_8$8)
                ], 2)) : createCommentVNode("", true)
              ])) : createCommentVNode("", true)
            ], 2)
          ], 16)), [
            [vShow, $data.keyboardShow]
          ]) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["onBeforeEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave", "onLeave", "onEnter"])
    ]),
    _: 3
  }, 8, ["modelValue", "onShow", "onHide", "z-index", "color", "closable", "timeout", "mount-el", "use-padding"]);
}
const NumberKeyboard = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", _sfc_render$M], ["__scopeId", "data-v-96ebe1e8"]]);
NumberKeyboard.install = (app) => {
  app.component(NumberKeyboard.name, NumberKeyboard);
};
const search_vue_vue_type_style_index_0_scoped_4635809b_lang = "";
const _sfc_main$L = {
  name: "m-search",
  emits: ["update:modelValue", "search", "cancel", "left-click", "right-click", "focus", "blur", "input", "clear"],
  data() {
    return {
      focus: false
    };
  },
  props: {
    modelValue: {
      type: [String, Number],
      default: ""
    },
    type: {
      type: String,
      default: "text",
      validator(value) {
        return ["text", "password", "number", "tel", "textarea"].includes(value);
      }
    },
    placeholder: {
      type: String,
      default: ""
    },
    label: {
      type: String,
      default: null
    },
    round: {
      type: Boolean,
      default: false
    },
    maxlength: {
      type: Number,
      default: -1
    },
    autofocus: {
      type: Boolean,
      default: false
    },
    showCancel: {
      type: Boolean,
      default: false
    },
    cancelText: {
      type: String,
      default: "\u53D6\u6D88"
    },
    disabled: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    align: {
      type: String,
      default: "left",
      validator(value) {
        return ["left", "center", "right"].includes(value);
      }
    },
    leftIcon: {
      type: [String, Object],
      default: null
    },
    rightIcon: {
      type: [String, Object],
      default: null
    },
    clearable: {
      type: Boolean,
      default: false
    },
    inputMode: {
      type: [String, Boolean],
      default: false,
      validator(value) {
        return [false, "none", "text", "decimal", "numeric", "tel", "search", "email", "url"].includes(value);
      }
    }
  },
  computed: {
    parseIcon() {
      return (param) => {
        let icon = {
          spin: false,
          type: null,
          url: null,
          color: null,
          size: null
        };
        if (obj$1.common.isObject(param)) {
          if (typeof param.spin == "boolean") {
            icon.spin = param.spin;
          }
          if (typeof param.type == "string") {
            icon.type = param.type;
          }
          if (typeof param.url == "string") {
            icon.url = param.url;
          }
          if (typeof param.color == "string") {
            icon.color = param.color;
          }
          if (typeof param.size == "string") {
            icon.size = param.size;
          }
        } else if (typeof param == "string") {
          icon.type = param;
        }
        return icon;
      };
    },
    showClear() {
      if (this.disabled || this.readonly) {
        return false;
      }
      if (this.focus) {
        if (this.realValue === "") {
          return false;
        }
        return true;
      }
      return false;
    },
    cmpType() {
      if (this.type == "number") {
        return "text";
      } else {
        return this.type;
      }
    },
    cmpInputMode() {
      let mode = false;
      if (typeof this.inputMode == "string") {
        mode = this.inputMode;
      }
      return mode;
    },
    inputStyle() {
      let style = {};
      if (this.align) {
        style.textAlign = this.align;
      }
      if (this.parseIcon(this.leftIcon).type || this.parseIcon(this.leftIcon).url) {
        style.paddingLeft = 0;
      }
      if (this.clearable && this.showClear || this.parseIcon(this.rightIcon).type || this.parseIcon(this.rightIcon).url) {
        style.paddingRight = 0;
      }
      return style;
    },
    realValue: {
      set(value) {
        if (this.modelValue !== value) {
          this.$emit("update:modelValue", value);
        }
      },
      get() {
        let value = this.modelValue === null ? "" : this.modelValue.toString();
        if (this.type == "number") {
          value = value.replace(/\D/g, "");
        }
        if (this.maxlength > 0 && value.length > this.maxlength) {
          value = value.substr(0, this.maxlength);
        }
        if (this.modelValue !== value) {
          this.$emit("update:modelValue", value);
        }
        return value;
      }
    }
  },
  components: {
    Icon
  },
  methods: {
    inputFocus() {
      if (this.disabled) {
        return;
      }
      this.focus = true;
      this.$emit("focus", this.realValue);
    },
    inputBlur() {
      if (this.disabled) {
        return;
      }
      setTimeout(() => {
        this.focus = false;
        this.$emit("blur", this.realValue);
      }, 100);
    },
    searchInput() {
      if (this.disabled) {
        return;
      }
      this.$emit("input", this.realValue);
    },
    doSearch() {
      if (this.disabled) {
        return;
      }
      this.$emit("search", this.realValue);
    },
    doCancel() {
      if (this.disabled) {
        return;
      }
      this.$emit("cancel", this.realValue);
    },
    leftClick() {
      if (this.disabled) {
        return;
      }
      this.$emit("left-click", this.realValue);
    },
    rightClick() {
      if (this.disabled) {
        return;
      }
      this.$emit("right-click", this.realValue);
    },
    clearInput() {
      if (this.disabled) {
        return;
      }
      if (!this.clearable) {
        return;
      }
      setTimeout(() => {
        this.realValue = "";
        this.$refs.input.focus();
        this.$emit("clear", this.realValue);
      }, 110);
    }
  }
};
const _hoisted_1$w = ["disabled"];
const _hoisted_2$t = ["textContent"];
const _hoisted_3$o = ["type", "placeholder", "maxlength", "autofocus", "disabled", "readonly", "inputmode"];
const _hoisted_4$h = ["textContent"];
function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("div", {
    class: "mvi-search",
    disabled: $props.disabled || null
  }, [
    $props.label ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "mvi-search-label",
      textContent: toDisplayString($props.label)
    }, null, 8, _hoisted_2$t)) : createCommentVNode("", true),
    createElementVNode("div", {
      class: normalizeClass(["mvi-search-input-container", $props.round ? "round" : ""])
    }, [
      $options.parseIcon($props.leftIcon).type || $options.parseIcon($props.leftIcon).url ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "mvi-search-left-icon",
        onClick: _cache[0] || (_cache[0] = (...args) => $options.leftClick && $options.leftClick(...args))
      }, [
        createVNode(_component_Icon, {
          type: $options.parseIcon($props.leftIcon).type,
          url: $options.parseIcon($props.leftIcon).url,
          spin: $options.parseIcon($props.leftIcon).spin,
          size: $options.parseIcon($props.leftIcon).size,
          color: $options.parseIcon($props.leftIcon).color
        }, null, 8, ["type", "url", "spin", "size", "color"])
      ])) : createCommentVNode("", true),
      withDirectives(createElementVNode("input", {
        ref: "input",
        class: "mvi-search-input",
        type: $options.cmpType,
        onKeypress: _cache[1] || (_cache[1] = withKeys((...args) => $options.doSearch && $options.doSearch(...args), ["enter"])),
        autocomplete: "off",
        placeholder: $props.placeholder,
        maxlength: $props.maxlength,
        autofocus: $props.autofocus,
        disabled: $props.disabled,
        readonly: $props.readonly,
        inputmode: $options.cmpInputMode,
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $options.realValue = $event),
        onInput: _cache[3] || (_cache[3] = (...args) => $options.searchInput && $options.searchInput(...args)),
        onFocus: _cache[4] || (_cache[4] = (...args) => $options.inputFocus && $options.inputFocus(...args)),
        onBlur: _cache[5] || (_cache[5] = (...args) => $options.inputBlur && $options.inputBlur(...args)),
        style: normalizeStyle($options.inputStyle)
      }, null, 44, _hoisted_3$o), [
        [vModelDynamic, $options.realValue]
      ]),
      $props.clearable ? withDirectives((openBlock(), createElementBlock("div", {
        key: 1,
        class: "mvi-search-clear",
        onClick: _cache[6] || (_cache[6] = (...args) => $options.clearInput && $options.clearInput(...args))
      }, [
        createVNode(_component_Icon, { type: "times-o" })
      ], 512)), [
        [vShow, $options.showClear]
      ]) : createCommentVNode("", true),
      $options.parseIcon($props.rightIcon).type || $options.parseIcon($props.rightIcon).url ? (openBlock(), createElementBlock("div", {
        key: 2,
        class: "mvi-search-right-icon",
        onClick: _cache[7] || (_cache[7] = (...args) => $options.rightClick && $options.rightClick(...args))
      }, [
        createVNode(_component_Icon, {
          type: $options.parseIcon($props.rightIcon).type,
          url: $options.parseIcon($props.rightIcon).url,
          spin: $options.parseIcon($props.rightIcon).spin,
          size: $options.parseIcon($props.rightIcon).size,
          color: $options.parseIcon($props.rightIcon).color
        }, null, 8, ["type", "url", "spin", "size", "color"])
      ])) : createCommentVNode("", true)
    ], 2),
    $props.showCancel ? (openBlock(), createElementBlock("div", {
      key: 1,
      textContent: toDisplayString($props.cancelText),
      class: "mvi-search-cancel",
      onClick: _cache[8] || (_cache[8] = (...args) => $options.doCancel && $options.doCancel(...args))
    }, null, 8, _hoisted_4$h)) : createCommentVNode("", true)
  ], 8, _hoisted_1$w);
}
const Search = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["render", _sfc_render$L], ["__scopeId", "data-v-4635809b"]]);
Search.install = (app) => {
  app.component(Search.name, Search);
};
const progress_vue_vue_type_style_index_0_scoped_b4862679_lang = "";
const _sfc_main$K = {
  name: "m-progress",
  props: {
    value: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    min: {
      type: Number,
      default: 0
    },
    strokeWidth: {
      type: String,
      default: null
    },
    showTip: {
      type: Boolean,
      default: false
    },
    color: {
      type: String,
      default: null
    },
    tipColor: {
      type: String,
      default: null
    },
    trackColor: {
      type: String,
      default: null
    },
    tipText: {
      type: [String, Number],
      default: null
    },
    round: {
      type: Boolean,
      default: false
    },
    square: {
      type: Boolean,
      default: false
    },
    animation: {
      type: Boolean,
      default: false
    },
    timeout: {
      type: Number,
      default: 400
    }
  },
  computed: {
    progressStyle() {
      let style = {};
      if (this.strokeWidth) {
        style.height = this.strokeWidth;
      }
      if (this.trackColor) {
        style.backgroundColor = this.trackColor;
      }
      return style;
    },
    progressBarStyle() {
      let style = {};
      if (this.animation) {
        style.transition = "width " + this.timeout + "ms,border-radius " + this.timeout + "ms";
        style.webkitTransition = "width " + this.timeout + "ms,border-radius " + this.timeout + "ms";
      }
      if (this.color) {
        style.backgroundColor = this.color;
      }
      if (this.value == this.max) {
        style.borderRadius = "inherit";
      }
      style.width = `calc(${(this.value - this.min < 0 ? 0 : this.value - this.min) / (this.max - this.min)} * 100%)`;
      return style;
    },
    cmpText() {
      if (this.tipText) {
        return this.tipText;
      } else {
        return Math.round((this.value - this.min < 0 ? 0 : this.value - this.min) / (this.max - this.min) * 100) + "%";
      }
    },
    tipStyle() {
      let style = {};
      if (this.tipColor) {
        style.color = this.tipColor;
      }
      return style;
    },
    progressClass() {
      let cls = ["mvi-progress"];
      if (this.round) {
        cls.push("round");
      } else if (this.square) {
        cls.push("square");
      }
      return cls;
    }
  }
};
const _hoisted_1$v = ["textContent"];
function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass($options.progressClass),
    style: normalizeStyle($options.progressStyle)
  }, [
    createElementVNode("div", {
      class: "mvi-progress-bar",
      style: normalizeStyle($options.progressBarStyle)
    }, [
      $props.showTip ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "mvi-progress-tooltip",
        style: normalizeStyle($options.tipStyle)
      }, [
        _ctx.$slots.tip ? renderSlot(_ctx.$slots, "tip", {
          key: 0,
          value: $props.value
        }, void 0, true) : (openBlock(), createElementBlock("span", {
          key: 1,
          textContent: toDisplayString($options.cmpText)
        }, null, 8, _hoisted_1$v))
      ], 4)) : createCommentVNode("", true)
    ], 4)
  ], 6);
}
const Progress = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["render", _sfc_render$K], ["__scopeId", "data-v-b4862679"]]);
Progress.install = (app) => {
  app.component(Progress.name, Progress);
};
const slider_vue_vue_type_style_index_0_scoped_bb4c2168_lang = "";
const _sfc_main$J = {
  name: "m-slider",
  data() {
    return {
      drag: null,
      isdrag: false
    };
  },
  emits: ["update:modelValue", "change"],
  props: {
    modelValue: {
      type: Number,
      default: 0
    },
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    strokeWidth: {
      type: String,
      default: "0.2rem"
    },
    color: {
      type: String,
      default: null
    },
    trackColor: {
      type: String,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    vertical: {
      type: Boolean,
      default: false
    },
    round: {
      type: Boolean,
      default: false
    },
    square: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    sliderStyle() {
      let style = {};
      if (this.trackColor) {
        style.background = this.trackColor;
      }
      if (this.strokeWidth) {
        if (this.vertical) {
          style.width = this.strokeWidth;
        } else {
          style.height = this.strokeWidth;
        }
      }
      return style;
    },
    sliderBarStyle() {
      let style = {};
      if (this.color) {
        style.background = this.color;
      }
      let percent = obj$1.number.divide(obj$1.number.subtract(this.modelValue, this.min), obj$1.number.subtract(this.max, this.min));
      if (this.vertical) {
        style.height = `calc(${percent} * 100%)`;
      } else {
        style.width = `calc(${percent} * 100%)`;
      }
      return style;
    },
    buttonElStyle() {
      let style = {};
      if (this.strokeWidth) {
        style.width = `calc(${this.strokeWidth} * 2)`;
        style.height = `calc(${this.strokeWidth} * 2)`;
      }
      return style;
    },
    sliderClass() {
      let cls = ["mvi-slider"];
      if (this.round) {
        cls.push("round");
      } else if (this.square) {
        cls.push("square");
      }
      if (this.vertical) {
        cls.push("vertical");
      }
      return cls;
    }
  },
  mounted() {
    this.setBtnOffset();
    this.drag = new Drag$1(this.$refs.btn, {
      container: this.$el,
      mode: "on",
      draggableY: this.vertical && !this.disabled,
      draggableX: !this.vertical && !this.disabled,
      cursor: false,
      drag: this.onDrag,
      dragged: () => {
        this.$nextTick(() => {
          setTimeout(() => {
            this.isdrag = false;
          }, 10);
        });
      }
    });
    this.drag.init();
  },
  watch: {
    disabled(newValue) {
      if (this.drag) {
        if (newValue) {
          if (this.vertical) {
            this.drag.draggableY = false;
          } else {
            this.drag.draggableX = false;
          }
        } else {
          if (this.vertical) {
            this.drag.draggableY = true;
          } else {
            this.drag.draggableX = true;
          }
        }
      }
    },
    vertical() {
      this.$nextTick(() => {
        this.setBtnOffset();
      });
    },
    modelValue() {
      if (!this.isdrag) {
        this.setBtnOffset();
      }
    }
  },
  methods: {
    onDrag(el, container, placement) {
      this.isdrag = true;
      if (this.vertical) {
        let value = obj$1.number.add(obj$1.number.mutiply(obj$1.number.divide(obj$1.number.add(placement.top, obj$1.number.divide(this.$refs.btn.offsetHeight, 2)), this.$el.offsetHeight), obj$1.number.subtract(this.max, this.min)), this.min);
        this.$emit("update:modelValue", value);
        this.$emit("change", value);
      } else {
        let value = obj$1.number.add(obj$1.number.mutiply(obj$1.number.divide(obj$1.number.add(placement.left, obj$1.number.divide(this.$refs.btn.offsetWidth, 2)), this.$el.offsetWidth), obj$1.number.subtract(this.max - this.min)), this.min);
        this.$emit("update:modelValue", value);
        this.$emit("change", value);
      }
    },
    setBtnOffset() {
      if (this.vertical) {
        this.$refs.btn.style.left = "50%";
        this.$refs.btn.style.top = obj$1.number.subtract(obj$1.number.mutiply(obj$1.number.divide(obj$1.number.subtract(this.modelValue, this.min), obj$1.number.subtract(this.max - this.min)), this.$el.offsetHeight), obj$1.number.divide(this.$refs.btn.offsetHeight, 2)) + "px";
      } else {
        this.$refs.btn.style.top = "50%";
        this.$refs.btn.style.left = obj$1.number.subtract(obj$1.number.mutiply(obj$1.number.divide(obj$1.number.subtract(this.modelValue, this.min), obj$1.number.subtract(this.max - this.min)), this.$el.offsetWidth), obj$1.number.divide(this.$refs.btn.offsetWidth, 2)) + "px";
      }
    },
    dragTo(event2) {
      if (this.disabled) {
        return;
      }
      if (this.isdrag) {
        return;
      }
      if (obj$1.element.isContains(this.$refs.btn, event2.target)) {
        return;
      }
      if (this.vertical) {
        let top = event2.offsetY;
        let value = obj$1.number.add(obj$1.number.mutiply(obj$1.number.divide(top, this.$el.offsetHeight), obj$1.number.subtract(this.max, this.min)), this.min);
        this.$emit("update:modelValue", value);
        this.$emit("change", value);
      } else {
        let left = event2.offsetX;
        let value = obj$1.number.add(obj$1.number.mutiply(obj$1.number.divide(left, this.$el.offsetWidth), obj$1.number.subtract(this.max, this.min)), this.min);
        this.$emit("update:modelValue", value);
        this.$emit("change", value);
      }
    }
  },
  beforeUnmount() {
    if (this.drag) {
      this.drag.destroy();
    }
  }
};
const _hoisted_1$u = ["disabled"];
const _hoisted_2$s = {
  class: "mvi-slider-button",
  ref: "btn"
};
function _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    disabled: $props.disabled || null,
    class: normalizeClass($options.sliderClass),
    style: normalizeStyle($options.sliderStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => $options.dragTo && $options.dragTo(...args))
  }, [
    createElementVNode("div", {
      ref: "bar",
      class: "mvi-slider-bar",
      style: normalizeStyle($options.sliderBarStyle)
    }, null, 4),
    createElementVNode("div", _hoisted_2$s, [
      _ctx.$slots.button ? renderSlot(_ctx.$slots, "button", { key: 0 }, void 0, true) : (openBlock(), createElementBlock("div", {
        key: 1,
        class: "mvi-slider-button-el",
        style: normalizeStyle($options.buttonElStyle)
      }, null, 4))
    ], 512)
  ], 14, _hoisted_1$u);
}
const Slider = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["render", _sfc_render$J], ["__scopeId", "data-v-bb4c2168"]]);
Slider.install = (app) => {
  app.component(Slider.name, Slider);
};
const stepper_vue_vue_type_style_index_0_scoped_d4efe9c9_lang = "";
const _sfc_main$I = {
  name: "m-stepper",
  emits: ["update:modelValue", "change"],
  props: {
    modelValue: {
      type: [String, Number],
      default: 0
    },
    step: {
      type: Number,
      default: 1
    },
    size: {
      type: String,
      default: "medium",
      validator(value) {
        return ["small", "medium", "large"].includes(value);
      }
    },
    min: {
      type: Number,
      default: null
    },
    max: {
      type: Number,
      default: null
    },
    digit: {
      type: Number,
      default: 0
    },
    disabled: {
      type: Boolean,
      default: false
    },
    disabledPlus: {
      type: Boolean,
      default: false
    },
    disabledMinus: {
      type: Boolean,
      default: false
    },
    disabledInput: {
      type: Boolean,
      default: false
    },
    showPlus: {
      type: Boolean,
      default: true
    },
    showMinus: {
      type: Boolean,
      default: true
    },
    showInput: {
      type: Boolean,
      default: true
    },
    inputWidth: {
      type: String,
      default: null
    },
    active: {
      type: Boolean,
      default: true
    },
    inputAlign: {
      type: String,
      default: "center",
      validator(value) {
        return ["left", "center", "right"].includes(value);
      }
    },
    border: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    arrivalMin() {
      if (this.min != null) {
        return this.realValue <= this.min;
      }
      return false;
    },
    arrivalMax() {
      if (this.max != null) {
        return this.realValue >= this.max;
      }
      return false;
    },
    inputStyle() {
      let style = {};
      if (this.inputWidth) {
        style.width = this.inputWidth;
      }
      return style;
    },
    inputElStyle() {
      let style = {};
      if (this.inputAlign) {
        style.textAlign = this.inputAlign;
      }
      return style;
    },
    minusClass() {
      let cls = ["mvi-stepper-minus"];
      if (!(this.disabledMinus || this.arrivalMin || this.disabled) && this.active) {
        cls.push("active");
      }
      if (this.border) {
        cls.push("border");
      }
      return cls;
    },
    plusClass() {
      let cls = ["mvi-stepper-plus"];
      if (!(this.disabledPlus || this.arrivalMax || this.disabled) && this.active) {
        cls.push("active");
      }
      if (this.border) {
        cls.push("border");
      }
      return cls;
    },
    realValue: {
      set(value) {
        let val = this.updateValue(value);
        if (this.modelValue !== val) {
          this.$emit("update:modelValue", val);
          this.$emit("change", val);
        }
      },
      get() {
        return this.modelValue;
      }
    }
  },
  components: {
    Icon
  },
  methods: {
    doMinus() {
      if (this.disabled) {
        return;
      }
      if (this.disabledMinus) {
        return;
      }
      if (this.arrivalMin) {
        return;
      }
      this.realValue = obj$1.number.subtract(this.realValue, this.step);
    },
    doPlus() {
      if (this.disabled) {
        return;
      }
      if (this.disabledPlus) {
        return;
      }
      if (this.arrivalMax) {
        return;
      }
      this.realValue = obj$1.number.add(this.realValue, this.step);
    },
    changeValue() {
      if (this.disabled) {
        return;
      }
      if (this.disabledInput) {
        return;
      }
      this.$refs.input.value = this.realValue;
    },
    updateValue(value) {
      let val = parseFloat(value);
      if (isNaN(val)) {
        val = 0;
      }
      val = Number(val.toFixed(this.digit));
      if (val <= this.min && this.min != null) {
        val = this.min;
      }
      if (val >= this.max && this.max != null) {
        val = this.max;
      }
      return val;
    }
  }
};
const _hoisted_1$t = ["disabled"];
const _hoisted_2$r = ["disabled"];
const _hoisted_3$n = ["disabled"];
const _hoisted_4$g = ["disabled"];
function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["mvi-stepper", $props.size])
  }, [
    $props.showMinus ? (openBlock(), createElementBlock("div", {
      key: 0,
      disabled: $props.disabledMinus || $options.arrivalMin || $props.disabled || null,
      class: normalizeClass($options.minusClass),
      onClick: _cache[0] || (_cache[0] = (...args) => $options.doMinus && $options.doMinus(...args))
    }, [
      createVNode(_component_Icon, { type: "minus" })
    ], 10, _hoisted_1$t)) : createCommentVNode("", true),
    $props.showInput ? (openBlock(), createElementBlock("div", {
      key: 1,
      disabled: $props.disabled || $props.disabledInput || null,
      class: normalizeClass(["mvi-stepper-input", $props.border ? "border" : ""]),
      style: normalizeStyle($options.inputStyle)
    }, [
      withDirectives(createElementVNode("input", {
        ref: "input",
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $options.realValue = $event),
        disabled: $props.disabled || $props.disabledInput || null,
        type: "text",
        onBlur: _cache[2] || (_cache[2] = (...args) => $options.changeValue && $options.changeValue(...args)),
        onKeyup: _cache[3] || (_cache[3] = withKeys((...args) => $options.changeValue && $options.changeValue(...args), ["enter"])),
        style: normalizeStyle($options.inputElStyle),
        inputmode: "numeric"
      }, null, 44, _hoisted_3$n), [
        [vModelText, $options.realValue]
      ])
    ], 14, _hoisted_2$r)) : createCommentVNode("", true),
    $props.showPlus ? (openBlock(), createElementBlock("div", {
      key: 2,
      disabled: $props.disabledPlus || $options.arrivalMax || $props.disabled || null,
      class: normalizeClass($options.plusClass),
      onClick: _cache[4] || (_cache[4] = (...args) => $options.doPlus && $options.doPlus(...args))
    }, [
      createVNode(_component_Icon, { type: "plus" })
    ], 10, _hoisted_4$g)) : createCommentVNode("", true)
  ], 2);
}
const Stepper = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["render", _sfc_render$I], ["__scopeId", "data-v-d4efe9c9"]]);
Stepper.install = (app) => {
  app.component(Stepper.name, Stepper);
};
const switch_vue_vue_type_style_index_0_scoped_836d8024_lang = "";
const _sfc_main$H = {
  name: "m-switch",
  emits: ["update:modelValue", "change"],
  props: {
    modelValue: {
      type: Boolean,
      default: false
    },
    loading: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: "0.4rem"
    },
    activeColor: {
      type: String,
      default: null
    },
    inactiveColor: {
      type: String,
      default: null
    }
  },
  components: {
    Icon
  },
  methods: {
    change(event2) {
      let check = event2.target.checked;
      this.$emit("update:modelValue", check);
      this.$emit("change", check);
    }
  },
  computed: {
    switchStyle() {
      let style = {};
      if (this.inactiveColor && !this.modelValue) {
        style.backgroundColor = this.inactiveColor;
      }
      if (this.activeColor && this.modelValue) {
        style.backgroundColor = this.activeColor;
      }
      if (this.size) {
        style.width = `calc(${this.size} * 2)`;
      }
      return style;
    },
    elStyle() {
      let style = {};
      if (this.activeColor) {
        style.color = this.activeColor;
      }
      if (this.size) {
        style.width = this.size;
        style.height = this.size;
        style.fontSize = this.size;
      }
      return style;
    }
  }
};
const _hoisted_1$s = ["disabled"];
const _hoisted_2$q = ["checked", "disabled"];
function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("label", {
    class: normalizeClass(["mvi-switch", $props.modelValue ? "checked" : ""]),
    style: normalizeStyle($options.switchStyle),
    disabled: $props.disabled || null
  }, [
    createElementVNode("span", {
      class: normalizeClass(["mvi-switch-el", $props.modelValue ? "checked" : ""]),
      style: normalizeStyle($options.elStyle)
    }, [
      $props.loading && !$props.disabled ? (openBlock(), createBlock(_component_Icon, {
        key: 0,
        type: "load-e",
        spin: "",
        size: "0.8em"
      })) : createCommentVNode("", true)
    ], 6),
    createElementVNode("input", {
      onChange: _cache[0] || (_cache[0] = (...args) => $options.change && $options.change(...args)),
      type: "checkbox",
      checked: $props.modelValue,
      disabled: $props.disabled || $props.loading
    }, null, 40, _hoisted_2$q)
  ], 14, _hoisted_1$s);
}
const Switch = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["render", _sfc_render$H], ["__scopeId", "data-v-836d8024"]]);
Switch.install = (app) => {
  app.component(Switch.name, Switch);
};
const actionsheet_vue_vue_type_style_index_0_scoped_9262c92f_lang = "";
const _sfc_main$G = {
  name: "m-actionsheet",
  emits: ["update:modelValue", "select"],
  props: {
    modelValue: {
      type: Boolean,
      default: false
    },
    overlayColor: {
      type: String,
      default: null
    },
    zIndex: {
      type: Number,
      default: 900
    },
    timeout: {
      type: Number,
      default: 200
    },
    round: {
      type: Boolean,
      default: false
    },
    title: {
      type: String,
      default: null
    },
    closable: {
      type: Boolean,
      default: false
    },
    options: {
      type: Array,
      default: function() {
        return [];
      }
    },
    showCancel: {
      type: Boolean,
      default: true
    },
    cancelText: {
      type: String,
      default: "\u53D6\u6D88"
    },
    active: {
      type: Boolean,
      default: true
    },
    mountEl: {
      type: String,
      default: null
    },
    selectClose: {
      type: Boolean,
      default: true
    },
    usePadding: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: "medium",
      validator(value) {
        return ["medium", "large"].includes(value);
      }
    }
  },
  computed: {
    $$el() {
      return this.$refs.popup.$$el;
    },
    show: {
      get() {
        return this.modelValue;
      },
      set(value) {
        this.$emit("update:modelValue", value);
      }
    },
    parseIcon() {
      return (param) => {
        let icon = {
          spin: false,
          type: null,
          url: null,
          color: null,
          size: null
        };
        if (obj$1.common.isObject(param)) {
          if (typeof param.spin == "boolean") {
            icon.spin = param.spin;
          }
          if (typeof param.type == "string") {
            icon.type = param.type;
          }
          if (typeof param.url == "string") {
            icon.url = param.url;
          }
          if (typeof param.color == "string") {
            icon.color = param.color;
          }
          if (typeof param.size == "string") {
            icon.size = param.size;
          }
        } else if (typeof param == "string") {
          icon.type = param;
        }
        return icon;
      };
    },
    itemClass() {
      return (item) => {
        let cls = ["mvi-actionsheet-item", this.size];
        if (this.active && !item.loading && !item.disabled) {
          cls.push("active");
        }
        return cls;
      };
    },
    itemDisabled() {
      return (item) => {
        if (typeof item.disabled == "boolean") {
          return item.disabled;
        } else {
          return false;
        }
      };
    }
  },
  components: {
    Icon,
    Loading,
    Popup
  },
  methods: {
    doSelect(item, index) {
      if (item.disabled || item.loading) {
        return;
      }
      if (this.selectClose) {
        this.show = false;
      }
      this.$emit("select", { ...item }, index);
    }
  }
};
const _withScopeId$3 = (n) => (pushScopeId("data-v-9262c92f"), n = n(), popScopeId(), n);
const _hoisted_1$r = { class: "mvi-actionsheet" };
const _hoisted_2$p = ["textContent"];
const _hoisted_3$m = { class: "mvi-actionsheet-list" };
const _hoisted_4$f = ["disabled", "onClick"];
const _hoisted_5$c = {
  key: 1,
  class: "mvi-actionsheet-content"
};
const _hoisted_6$9 = ["textContent"];
const _hoisted_7$8 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("div", { class: "mvi-actionsheet-divider" }, null, -1));
const _hoisted_8$7 = ["textContent"];
function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Loading = resolveComponent("Loading");
  const _component_Icon = resolveComponent("Icon");
  const _component_Popup = resolveComponent("Popup");
  return openBlock(), createBlock(_component_Popup, {
    ref: "popup",
    modelValue: $options.show,
    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $options.show = $event),
    "overlay-color": $props.overlayColor,
    "z-index": $props.zIndex,
    timeout: $props.timeout,
    placement: "bottom",
    round: $props.round,
    "use-padding": $props.usePadding,
    "mount-el": $props.mountEl,
    closable: $props.closable
  }, {
    default: withCtx(() => [
      createElementVNode("div", _hoisted_1$r, [
        $props.title ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["mvi-actionsheet-title", $props.size]),
          textContent: toDisplayString($props.title)
        }, null, 10, _hoisted_2$p)) : createCommentVNode("", true),
        createElementVNode("div", _hoisted_3$m, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.options, (item, index) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass($options.itemClass(item)),
              disabled: $options.itemDisabled(item) || null,
              onClick: ($event) => $options.doSelect(item, index)
            }, [
              item.loading || false ? (openBlock(), createBlock(_component_Loading, {
                key: 0,
                size: $props.size == "large" ? "0.4rem" : "0.36rem",
                color: "#bbb"
              }, null, 8, ["size"])) : item.label || $options.parseIcon(item.icon).type || $options.parseIcon(item.icon).url ? (openBlock(), createElementBlock("div", _hoisted_5$c, [
                ($options.parseIcon(item.icon).type || $options.parseIcon(item.icon).url) && item.placement != "right" ? (openBlock(), createBlock(_component_Icon, {
                  key: 0,
                  "data-placement": "left",
                  type: $options.parseIcon(item.icon).type,
                  url: $options.parseIcon(item.icon).url,
                  spin: $options.parseIcon(item.icon).spin,
                  size: $options.parseIcon(item.icon).size,
                  color: $options.parseIcon(item.icon).color
                }, null, 8, ["type", "url", "spin", "size", "color"])) : createCommentVNode("", true),
                item.label ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  class: "mvi-actionsheet-item-label",
                  textContent: toDisplayString(item.label)
                }, null, 8, _hoisted_6$9)) : createCommentVNode("", true),
                ($options.parseIcon(item.icon).type || $options.parseIcon(item.icon).url) && item.placement == "right" ? (openBlock(), createBlock(_component_Icon, {
                  key: 2,
                  "data-placement": "right",
                  type: $options.parseIcon(item.icon).type,
                  url: $options.parseIcon(item.icon).url,
                  spin: $options.parseIcon(item.icon).spin,
                  size: $options.parseIcon(item.icon).size,
                  color: $options.parseIcon(item.icon).color
                }, null, 8, ["type", "url", "spin", "size", "color"])) : createCommentVNode("", true)
              ])) : createCommentVNode("", true)
            ], 10, _hoisted_4$f);
          }), 256))
        ]),
        _hoisted_7$8,
        $props.showCancel ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(["mvi-actionsheet-button", $props.size, $props.active ? "active" : ""]),
          textContent: toDisplayString($props.cancelText),
          onClick: _cache[0] || (_cache[0] = ($event) => $options.show = false)
        }, null, 10, _hoisted_8$7)) : createCommentVNode("", true)
      ])
    ]),
    _: 1
  }, 8, ["modelValue", "overlay-color", "z-index", "timeout", "round", "use-padding", "mount-el", "closable"]);
}
const Actionsheet = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["render", _sfc_render$G], ["__scopeId", "data-v-9262c92f"]]);
Actionsheet.install = (app) => {
  app.component(Actionsheet.name, Actionsheet);
};
const dropdown_vue_vue_type_style_index_0_scoped_d29335df_lang = "";
const _sfc_main$F = {
  name: "m-dropdown",
  emits: ["update:modelValue", "update:show", "select"],
  props: {
    modelValue: {
      type: [Object, Number, String, Array],
      default: null
    },
    activeColor: {
      type: String,
      default: null
    },
    options: {
      type: Array,
      default: function() {
        return [];
      }
    },
    selectedClose: {
      type: Boolean,
      default: true
    },
    selectedIcon: {
      type: [String, Object],
      default: "success"
    },
    show: {
      type: Boolean,
      default: false
    },
    overlayColor: {
      type: String,
      default: null
    },
    zIndex: {
      type: Number,
      default: 900
    },
    timeout: {
      type: Number,
      default: 200
    },
    round: {
      type: Boolean,
      default: false
    },
    placement: {
      type: String,
      default: "top"
    },
    closable: {
      type: Boolean,
      default: true
    },
    mountEl: {
      type: String,
      default: null
    },
    active: {
      type: Boolean,
      default: true
    },
    usePadding: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    $$el() {
      return this.$refs.popup.$$el;
    },
    cmpShow: {
      set(value) {
        this.$emit("update:show", value);
      },
      get() {
        return this.show;
      }
    },
    parseIcon() {
      return (param) => {
        let icon = {
          spin: false,
          type: null,
          url: null,
          color: null,
          size: null
        };
        if (obj$1.common.isObject(param)) {
          if (typeof param.spin == "boolean") {
            icon.spin = param.spin;
          }
          if (typeof param.type == "string") {
            icon.type = param.type;
          }
          if (typeof param.url == "string") {
            icon.url = param.url;
          }
          if (typeof param.color == "string") {
            icon.color = param.color;
          }
          if (typeof param.size == "string") {
            icon.size = param.size;
          }
        } else if (typeof param == "string") {
          icon.type = param;
        }
        return icon;
      };
    },
    equalValue() {
      return (item, index) => {
        if (item.value === void 0 || item.value === null) {
          return this.modelValue === index;
        }
        return obj$1.common.equal(this.modelValue, item.value);
      };
    },
    itemDisabled() {
      return (item) => {
        if (typeof item.disabled == "boolean") {
          return item.disabled;
        }
        return false;
      };
    },
    dropdownItemStyle() {
      return (item, index) => {
        let style = {};
        if (!this.itemDisabled(item) && this.equalValue(item, index) && this.activeColor) {
          style.color = this.activeColor;
        }
        return style;
      };
    },
    dropdownItemClass() {
      return (item, index) => {
        let cls = ["mvi-dropdown-item"];
        if (this.equalValue(item, index) && !item.disabled) {
          cls.push("checked");
        }
        if (this.active && !item.disabled) {
          cls.push("active");
        }
        return cls;
      };
    }
  },
  components: {
    Icon,
    Popup
  },
  methods: {
    doSelect(item, index) {
      if (item.disabled) {
        return;
      }
      this.$emit("select", JSON.parse(JSON.stringify(item)), index);
      if (!obj$1.common.equal(item.value, this.modelValue)) {
        this.$emit("update:modelValue", item.value);
      }
      if (this.selectedClose) {
        this.cmpShow = false;
      }
    }
  }
};
const _hoisted_1$q = { class: "mvi-dropdown" };
const _hoisted_2$o = ["disabled", "onClick"];
const _hoisted_3$l = { class: "mvi-dropdown-label" };
const _hoisted_4$e = ["textContent"];
const _hoisted_5$b = ["data-placement"];
function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_Popup = resolveComponent("Popup");
  return openBlock(), createBlock(_component_Popup, {
    ref: "popup",
    modelValue: $options.cmpShow,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.cmpShow = $event),
    "overlay-color": $props.overlayColor,
    "z-index": $props.zIndex,
    timeout: $props.timeout,
    placement: $props.placement,
    round: $props.round,
    "use-padding": $props.usePadding,
    "mount-el": $props.mountEl,
    closable: $props.closable,
    __contentPadding: false
  }, {
    default: withCtx(() => [
      createElementVNode("div", _hoisted_1$q, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($props.options, (item, index) => {
          return openBlock(), createElementBlock("div", {
            disabled: $options.itemDisabled(item) || null,
            class: normalizeClass($options.dropdownItemClass(item, index)),
            onClick: ($event) => $options.doSelect(item, index),
            style: normalizeStyle($options.dropdownItemStyle(item, index))
          }, [
            createElementVNode("div", _hoisted_3$l, [
              item.icon ? (openBlock(), createBlock(_component_Icon, {
                key: 0,
                type: $options.parseIcon(item.icon).type,
                url: $options.parseIcon(item.icon).url,
                spin: $options.parseIcon(item.icon).spin,
                class: "mvi-dropdown-label-icon",
                size: $options.parseIcon(item.icon).size,
                color: $options.parseIcon(item.icon).color
              }, null, 8, ["type", "url", "spin", "size", "color"])) : createCommentVNode("", true),
              createElementVNode("span", {
                class: "mvi-dropdown-label-text",
                textContent: toDisplayString(item.label || "")
              }, null, 8, _hoisted_4$e)
            ]),
            createElementVNode("div", {
              class: normalizeClass(["mvi-dropdown-icon", $options.equalValue(item, index) ? "checked" : ""]),
              "data-placement": $props.placement
            }, [
              createVNode(_component_Icon, {
                type: $options.parseIcon($props.selectedIcon).type,
                url: $options.parseIcon($props.selectedIcon).url,
                spin: $options.parseIcon($props.selectedIcon).spin,
                size: $options.parseIcon($props.selectedIcon).size,
                color: $options.parseIcon($props.selectedIcon).color
              }, null, 8, ["type", "url", "spin", "size", "color"])
            ], 10, _hoisted_5$b)
          ], 14, _hoisted_2$o);
        }), 256))
      ])
    ]),
    _: 1
  }, 8, ["modelValue", "overlay-color", "z-index", "timeout", "placement", "round", "use-padding", "mount-el", "closable"]);
}
const Dropdown = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$F], ["__scopeId", "data-v-d29335df"]]);
Dropdown.install = (app) => {
  app.component(Dropdown.name, Dropdown);
};
const notify_vue_vue_type_style_index_0_scoped_80ba439a_lang = "";
const _sfc_main$E = {
  name: "m-notify",
  data() {
    return {
      timer: null,
      show: false
    };
  },
  props: {
    type: {
      type: String,
      default: null
    },
    message: {
      type: String,
      default: null
    },
    color: {
      type: String,
      default: null
    },
    background: {
      type: String,
      default: null
    },
    zIndex: {
      type: Number,
      default: null
    },
    timeout: {
      type: Number,
      default: null
    },
    icon: {
      type: [String, Object],
      default: null
    },
    __remove: {
      type: Function,
      default: function() {
        return function() {
        };
      }
    },
    __init: {
      type: Function,
      default: function() {
        return function() {
        };
      }
    }
  },
  computed: {
    cmpType() {
      let arr = ["success", "info", "primary", "error", "warn"];
      if (arr.includes(this.type)) {
        return this.type;
      }
      return "success";
    },
    cmpMessage() {
      if (typeof this.message == "string") {
        return this.message;
      }
      if (obj$1.common.isObject(this.message)) {
        return JSON.stringify(this.message);
      }
      return String(this.message);
    },
    cmpColor() {
      if (typeof this.color == "string") {
        return this.color;
      }
      return null;
    },
    cmpBackground() {
      if (typeof this.background == "string") {
        return this.background;
      }
      return null;
    },
    cmpZIndex() {
      if (obj$1.number.isNumber(this.zIndex)) {
        return this.zIndex;
      }
      return 1100;
    },
    cmpTimeout() {
      if (obj$1.number.isNumber(this.timeout)) {
        return this.timeout;
      }
      return 1500;
    },
    parseIcon() {
      return (param) => {
        let icon = {
          spin: false,
          type: null,
          url: null,
          color: null,
          size: null
        };
        if (obj$1.common.isObject(param)) {
          if (typeof param.spin == "boolean") {
            icon.spin = param.spin;
          }
          if (typeof param.type == "string") {
            icon.type = param.type;
          }
          if (typeof param.url == "string") {
            icon.url = param.url;
          }
          if (typeof param.color == "string") {
            icon.color = param.color;
          }
          if (typeof param.size == "string") {
            icon.size = param.size;
          }
        } else if (typeof param == "string") {
          icon.type = param;
        }
        return icon;
      };
    },
    notifyStyle() {
      let style = {
        zIndex: this.cmpZIndex
      };
      if (this.cmpBackground) {
        style.backgroundColor = this.cmpBackground;
      }
      if (this.cmpColor) {
        style.color = this.cmpColor;
      }
      return style;
    }
  },
  components: {
    Icon
  },
  mounted() {
    this.show = true;
    this.__init(this);
  },
  methods: {
    afterEnter() {
      if (this.cmpTimeout > 0) {
        this.timer = setTimeout(() => {
          this.show = false;
        }, this.cmpTimeout);
      }
    },
    afterLeave() {
      this.clearTimer();
      this.__remove();
    },
    clearTimer() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
    }
  }
};
const _hoisted_1$p = { class: "mvi-notify-content" };
const _hoisted_2$n = ["textContent"];
function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createBlock(Teleport, { to: "body" }, [
    createVNode(Transition, {
      name: "mvi-notify",
      onAfterLeave: $options.afterLeave,
      onAfterEnter: $options.afterEnter
    }, {
      default: withCtx(() => [
        withDirectives(createElementVNode("div", {
          class: normalizeClass(["mvi-notify", $options.cmpType]),
          style: normalizeStyle($options.notifyStyle)
        }, [
          createElementVNode("div", _hoisted_1$p, [
            $options.parseIcon($props.icon).type || $options.parseIcon($props.icon).url ? (openBlock(), createBlock(_component_Icon, {
              key: 0,
              type: $options.parseIcon($props.icon).type,
              url: $options.parseIcon($props.icon).url,
              spin: $options.parseIcon($props.icon).spin,
              size: $options.parseIcon($props.icon).size,
              color: $options.parseIcon($props.icon).color
            }, null, 8, ["type", "url", "spin", "size", "color"])) : createCommentVNode("", true),
            createElementVNode("span", {
              textContent: toDisplayString($options.cmpMessage)
            }, null, 8, _hoisted_2$n)
          ])
        ], 6), [
          [vShow, $data.show]
        ])
      ]),
      _: 1
    }, 8, ["onAfterLeave", "onAfterEnter"])
  ]);
}
const NotifyComponent = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$E], ["__scopeId", "data-v-80ba439a"]]);
const Notify = {
  initParams: (options) => {
    let opts = {};
    if (obj$1.common.isObject(options)) {
      opts.type = options.type;
      opts.message = options.message;
      opts.timeout = options.timeout;
      opts.background = options.background;
      opts.color = options.color;
      opts.zIndex = options.zIndex;
      opts.icon = options.icon;
    } else {
      opts.message = options;
    }
    return opts;
  },
  showNotify: (options) => {
    return new Promise((resolve) => {
      if (Notify.$el && Notify.$instance) {
        Notify.$instance.unmount();
        Notify.$el.remove();
      }
      let opts = Notify.initParams(options);
      let mountNode = obj$1.element.string2dom("<div></div>");
      document.body.appendChild(mountNode);
      const instance = createApp(NotifyComponent, {
        ...opts,
        __init: (vm) => {
          Notify.$vm = vm;
        },
        __remove: () => {
          instance.unmount();
          mountNode.remove();
          resolve();
        }
      });
      instance.mount(mountNode);
      Notify.$el = mountNode;
      Notify.$instance = instance;
    });
  },
  hideNotify: () => {
    if (Notify.$vm) {
      Notify.$vm.show = false;
    }
  },
  install: (app) => {
    app.config.globalProperties.$showNotify = Notify.showNotify;
    app.provide("$showNotify", Notify.showNotify);
    app.config.globalProperties.$hideNotify = Notify.hideNotify;
    app.provide("$hideNotify", Notify.hideNotify);
  }
};
const pullRefresh_vue_vue_type_style_index_0_scoped_56b35aa0_lang = "";
const _sfc_main$D = {
  name: "m-pull-refresh",
  data() {
    return {
      elHeight: 0,
      rootHeight: 0,
      amount: 0,
      amountMax: 4,
      startY: 0,
      firstStartY: 0,
      status: 0,
      translateY: 0,
      hasTouch: false,
      mouseDown: false,
      disableScroll: false
    };
  },
  emits: ["update:modelValue", "refresh"],
  props: {
    pullingText: {
      type: String,
      default: "\u4E0B\u62C9\u5237\u65B0"
    },
    loosingText: {
      type: String,
      default: "\u91CA\u653E\u5237\u65B0"
    },
    loadingText: {
      type: String,
      default: "\u6B63\u5728\u5237\u65B0"
    },
    modelValue: {
      type: Boolean,
      default: false
    },
    pullingIcon: {
      type: [String, Object],
      default: "arrow-down"
    },
    loosingIcon: {
      type: [String, Object],
      default: "arrow-up"
    },
    loadingIcon: {
      type: [String, Object],
      default: function() {
        return {
          type: "load-e",
          spin: true
        };
      }
    },
    disabled: {
      type: Boolean,
      default: false
    },
    distance: {
      type: Number,
      default: 1.4
    }
  },
  computed: {
    containerStyle() {
      let style = {
        height: `calc(100% + ${this.elHeight}px)`,
        transform: `translateY(${this.translateY}px)`
      };
      return style;
    },
    wrapperStyle() {
      let style = {
        height: this.rootHeight + "px"
      };
      if (this.disableScroll) {
        style.overflowY = "hidden";
      }
      return style;
    },
    icon() {
      if (this.status == 0) {
        return this.parseIcon(this.pullingIcon);
      }
      if (this.status == 1) {
        return this.parseIcon(this.loosingIcon);
      }
      if (this.status == 2) {
        return this.parseIcon(this.loadingIcon);
      }
    },
    message() {
      if (this.status == 0) {
        return this.pullingText;
      }
      if (this.status == 1) {
        return this.loosingText;
      }
      if (this.status == 2) {
        return this.loadingText;
      }
    },
    parseIcon() {
      return (param) => {
        let icon = {
          spin: false,
          type: null,
          url: null,
          color: null,
          size: null
        };
        if (obj$1.common.isObject(param)) {
          if (typeof param.spin == "boolean") {
            icon.spin = param.spin;
          }
          if (typeof param.type == "string") {
            icon.type = param.type;
          }
          if (typeof param.url == "string") {
            icon.url = param.url;
          }
          if (typeof param.color == "string") {
            icon.color = param.color;
          }
          if (typeof param.size == "string") {
            icon.size = param.size;
          }
        } else if (typeof param == "string") {
          icon.type = param;
        }
        return icon;
      };
    }
  },
  components: {
    Icon
  },
  setup() {
    const instance = getCurrentInstance();
    return {
      uid: instance.uid
    };
  },
  mounted() {
    this.initHeight();
    obj$1.event.on(document.documentElement, `mousemove.pullRefresh_${this.uid}`, this.onPull2);
    obj$1.event.on(document.documentElement, `mouseup.pullRefresh_${this.uid}`, this.pulled2);
  },
  watch: {
    modelValue() {
      this.changeStatus();
    }
  },
  methods: {
    initHeight() {
      this.elHeight = this.$refs.el.offsetHeight;
      this.rootHeight = this.$el.offsetHeight;
      this.translateY = -this.elHeight;
    },
    startPull(event2) {
      if (this.disabled) {
        return;
      }
      if (this.status == 0) {
        this.startY = event2.targetTouches[0].pageY;
        this.firstStartY = this.startY;
      }
    },
    startPull2(event2) {
      if (this.disabled) {
        return;
      }
      if (this.status == 0) {
        this.mouseDown = true;
        this.startY = event2.pageY;
        this.firstStartY = this.startY;
      }
    },
    onPull(event2) {
      if (this.disabled) {
        return;
      }
      if (this.status == 2) {
        return;
      }
      let endY = event2.targetTouches[0].pageY;
      let move = endY - this.startY;
      let totalMove = endY - this.firstStartY;
      this.startY = endY;
      if (totalMove <= 0) {
        this.firstStartY = this.startY;
        return;
      }
      if (obj$1.element.getScrollTop(this.$refs.wrapper) > 0) {
        this.firstStartY = this.startY;
        return;
      }
      let el = this.getScrollEl(event2.target);
      if (!el.isEqualNode(this.$refs.wrapper) && obj$1.element.getScrollTop(el) > 0) {
        this.firstStartY = this.startY;
        return;
      }
      this.hasTouch = true;
      if (event2.cancelable) {
        event2.preventDefault();
      }
      if (this.amount < this.amountMax) {
        this.amount++;
      }
      let y = this.translateY + move / this.amount;
      if (y > obj$1.element.rem2px(this.distance) - this.elHeight) {
        this.status = 1;
      } else {
        this.status = 0;
      }
      this.translateY = y;
    },
    onPull2(event2) {
      if (!this.mouseDown || this.disabled) {
        return;
      }
      if (this.status == 2) {
        return;
      }
      let endY = event2.pageY;
      let move = endY - this.startY;
      let totalMove = endY - this.firstStartY;
      this.startY = endY;
      if (totalMove <= 0) {
        this.firstStartY = this.startY;
        return;
      }
      if (obj$1.element.getScrollTop(this.$refs.wrapper) > 0) {
        this.firstStartY = this.startY;
        return;
      }
      let el = this.getScrollEl(event2.target);
      if (!el.isEqualNode(this.$refs.wrapper) && obj$1.element.getScrollTop(el) > 0) {
        this.firstStartY = this.startY;
        return;
      }
      this.hasTouch = true;
      if (event2.cancelable) {
        event2.preventDefault();
      }
      if (this.amount < this.amountMax) {
        this.amount++;
      }
      let y = this.translateY + move / this.amount;
      if (y > obj$1.element.rem2px(this.distance) - this.elHeight) {
        this.status = 1;
      } else {
        this.status = 0;
      }
      this.translateY = y;
    },
    pulled() {
      if (this.disabled) {
        return;
      }
      if (this.status == 1 && this.modelValue == false) {
        this.$emit("update:modelValue", true);
      } else if (this.status == 0) {
        this.changeStatus();
      }
    },
    pulled2() {
      if (!this.mouseDown || this.disabled) {
        return;
      }
      this.mouseDown = false;
      if (this.status == 1 && this.modelValue === false) {
        this.$emit("update:modelValue", true);
      } else if (this.status == 0) {
        this.changeStatus();
      }
    },
    changeStatus() {
      if (this.disabled) {
        return;
      }
      if (this.modelValue) {
        this.status = 2;
        this.disableScroll = true;
        this.$emit("refresh");
        if (!this.hasTouch) {
          this.$refs.container.style.transition = "transform 300ms";
          this.$refs.container.style.webkitTransition = "transform 300ms";
          this.$refs.container.offsetWidth;
          this.translateY = obj$1.element.rem2px(this.distance) - this.elHeight;
          setTimeout(() => {
            if (this.$refs.container) {
              this.$refs.container.style.transition = "";
              this.$refs.container.style.webkitTransition = "";
            }
          }, 300);
        }
      } else {
        this.amount = 0;
        this.hasTouch = false;
        this.$refs.container.style.transition = "transform 300ms";
        this.$refs.container.style.webkitTransition = "transform 300ms";
        this.$refs.container.offsetWidth;
        this.translateY = -this.elHeight;
        setTimeout(() => {
          if (this.$refs.container) {
            this.$refs.container.style.transition = "";
            this.$refs.container.style.webkitTransition = "";
          }
          this.status = 0;
          this.disableScroll = false;
        }, 300);
      }
    },
    getScrollEl(el) {
      if (el.isEqualNode(this.$refs.wrapper) || !obj$1.element.isContains(this.$refs.wrapper, el)) {
        return this.$refs.wrapper;
      }
      if (obj$1.element.getScrollHeight(el) > el.clientHeight) {
        return el;
      }
      return this.getScrollEl(el.parentNode);
    }
  },
  beforeUnmount() {
    obj$1.event.off(document.documentElement, `mousemove.pullRefresh_${this.uid} mouseup.pullRefresh_${this.uid}`);
  }
};
const _hoisted_1$o = { class: "mvi-pull-refresh" };
const _hoisted_2$m = {
  ref: "el",
  class: "mvi-pull-refresh-el"
};
const _hoisted_3$k = ["textContent"];
function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("div", _hoisted_1$o, [
    createElementVNode("div", {
      ref: "container",
      class: "mvi-pull-refresh-container",
      style: normalizeStyle($options.containerStyle)
    }, [
      createElementVNode("div", _hoisted_2$m, [
        _ctx.$slots.el ? renderSlot(_ctx.$slots, "el", {
          key: 0,
          status: $data.status
        }, void 0, true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createVNode(_component_Icon, {
            type: $options.icon.type,
            spin: $options.icon.spin,
            url: $options.icon.url,
            size: $options.icon.size,
            color: $options.icon.color
          }, null, 8, ["type", "spin", "url", "size", "color"]),
          createElementVNode("span", {
            class: "mvi-pull-refresh-text",
            textContent: toDisplayString($options.message)
          }, null, 8, _hoisted_3$k)
        ], 64))
      ], 512),
      createElementVNode("div", {
        ref: "wrapper",
        class: "mvi-pull-refresh-wrapper",
        onTouchstart: _cache[0] || (_cache[0] = (...args) => $options.startPull && $options.startPull(...args)),
        onTouchmove: _cache[1] || (_cache[1] = (...args) => $options.onPull && $options.onPull(...args)),
        onTouchend: _cache[2] || (_cache[2] = (...args) => $options.pulled && $options.pulled(...args)),
        onMousedown: _cache[3] || (_cache[3] = (...args) => $options.startPull2 && $options.startPull2(...args)),
        style: normalizeStyle($options.wrapperStyle)
      }, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 36)
    ], 4)
  ]);
}
const PullRefresh = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$D], ["__scopeId", "data-v-56b35aa0"]]);
PullRefresh.install = (app) => {
  app.component(PullRefresh.name, PullRefresh);
};
const swipeCell_vue_vue_type_style_index_0_scoped_1e12e6ca_lang = "";
const _sfc_main$C = {
  name: "m-swipe-cell",
  data() {
    return {
      startX: 0,
      startX2: 0,
      transformX: 0,
      leftShow: false,
      rightShow: false,
      amounts: 0,
      mouseDown: false,
      isDrag: false
    };
  },
  props: {
    disabled: {
      type: Boolean,
      default: false
    },
    centerClose: {
      type: Boolean,
      default: true
    }
  },
  emits: ["open", "close"],
  watch: {
    disabled() {
      this.close(true);
    }
  },
  computed: {
    cellStyle() {
      return {
        transform: `translateX(${this.transformX}px)`
      };
    }
  },
  setup() {
    const instance = getCurrentInstance();
    return {
      uid: instance.uid
    };
  },
  mounted() {
    obj$1.event.on(document.documentElement, `mousemove.swipeCell_${this.uid}`, this.cellMouseMove);
    obj$1.event.on(document.documentElement, `mouseup.swipeCell_${this.uid}`, this.cellMouseUp);
  },
  methods: {
    cellTouchStart(event2) {
      if (this.disabled) {
        return;
      }
      this.startX = event2.touches[0].pageX;
      this.startX2 = this.startX;
      this.amounts = 0;
    },
    cellTouchMove(event2) {
      if (this.disabled) {
        return;
      }
      let endX = event2.touches[0].pageX;
      let moveX = endX - this.startX;
      let moveX2 = endX - this.startX2;
      this.startX = endX;
      if (Math.abs(moveX2) <= obj$1.element.rem2px(1)) {
        return;
      }
      if (event2.cancelable) {
        event2.preventDefault();
      }
      if (moveX2 > 0) {
        if (this.leftShow && this.transformX == this.$refs.left.offsetWidth) {
          return;
        }
        this.leftShow = true;
        this.$nextTick(() => {
          if (this.transformX >= this.$refs.left.offsetWidth) {
            this.amounts += 8;
            this.transformX += moveX / this.amounts;
          } else {
            this.transformX += moveX;
          }
        });
      } else if (moveX2 < 0) {
        if (this.rightShow && this.transformX == -this.$refs.right.offsetWidth) {
          return;
        }
        this.rightShow = true;
        this.$nextTick(() => {
          if (this.transformX <= -this.$refs.right.offsetWidth) {
            this.amounts += 8;
            this.transformX += moveX / this.amounts;
          } else {
            this.transformX += moveX;
          }
        });
      }
    },
    cellTouchEnd(event2) {
      if (this.disabled) {
        return;
      }
      let moveX = event2.changedTouches[0].pageX - this.startX2;
      if (moveX == 0) {
        return;
      }
      if (moveX > 0) {
        if (this.transformX > 0) {
          this.open("left");
        } else {
          this.close();
        }
      } else {
        if (this.transformX < 0) {
          this.open("right");
        } else {
          this.close();
        }
      }
    },
    cellMouseDown(event2) {
      if (this.disabled) {
        return;
      }
      this.startX = event2.pageX;
      this.startX2 = this.startX;
      this.amounts = 0;
      this.mouseDown = true;
    },
    cellMouseMove(event2) {
      if (this.disabled) {
        return;
      }
      if (!this.mouseDown) {
        return;
      }
      this.isDrag = true;
      let endX = event2.pageX;
      let moveX = endX - this.startX;
      let moveX2 = endX - this.startX2;
      this.startX = endX;
      if (Math.abs(moveX2) <= obj$1.element.rem2px(1)) {
        return;
      }
      if (event2.cancelable) {
        event2.preventDefault();
      }
      if (moveX2 > 0) {
        if (this.leftShow && this.transformX == this.$refs.left.offsetWidth) {
          return;
        }
        this.leftShow = true;
        this.$nextTick(() => {
          if (this.transformX >= this.$refs.left.offsetWidth) {
            this.amounts += 3;
            this.transformX += moveX / this.amounts;
          } else {
            this.transformX += moveX;
          }
        });
      } else if (moveX2 < 0) {
        if (this.rightShow && this.transformX == -this.$refs.right.offsetWidth) {
          return;
        }
        this.rightShow = true;
        this.$nextTick(() => {
          if (this.transformX <= -this.$refs.right.offsetWidth) {
            this.amounts += 3;
            this.transformX += moveX / this.amounts;
          } else {
            this.transformX += moveX;
          }
        });
      }
    },
    cellMouseUp(event2) {
      if (this.disabled) {
        return;
      }
      if (!this.mouseDown) {
        return;
      }
      this.mouseDown = false;
      let moveX = event2.pageX - this.startX2;
      if (moveX == 0) {
        return;
      }
      if (moveX > 0) {
        if (this.transformX > 0) {
          this.open("left");
        } else {
          this.close();
        }
      } else {
        if (this.transformX < 0) {
          this.open("right");
        } else {
          this.close();
        }
      }
      setTimeout(() => {
        this.isDrag = false;
      }, 10);
    },
    setTransform(transformX) {
      return new Promise((resolve, reject) => {
        this.$el.style.transition = "transform 300ms";
        this.$el.style.webkitTransition = "transform 300ms";
        setTimeout(() => {
          this.transformX = transformX;
          setTimeout(() => {
            this.$el.style.transition = "";
            this.$el.style.webkitTransition = "";
            resolve();
          }, 300);
        }, 0);
      });
    },
    open(placement) {
      if (this.disabled) {
        return;
      }
      if (placement == "left") {
        if (!this.leftShow) {
          this.leftShow = true;
        }
        this.$nextTick(() => {
          this.setTransform(this.$refs.left.offsetWidth).then(() => {
            this.$emit("open", placement);
          });
        });
      } else if (placement == "right") {
        if (!this.rightShow) {
          this.rightShow = true;
        }
        this.$nextTick(() => {
          this.setTransform(-this.$refs.right.offsetWidth).then(() => {
            this.$emit("open", placement);
          });
        });
      }
    },
    close(flag) {
      if (!flag) {
        if (this.disabled) {
          return;
        }
      }
      let placement = "left";
      if (this.transformX == 0) {
        return;
      }
      if (this.transformX >= 0) {
        placement = "left";
      } else {
        placement = "right";
      }
      this.setTransform(0).then(() => {
        this.leftShow = false;
        this.rightShow = false;
        this.$emit("close", placement);
      });
    },
    clickCenter() {
      if (this.disabled) {
        return;
      }
      if (this.isDrag) {
        return;
      }
      if (this.centerClose) {
        this.close();
      }
    }
  },
  beforeUnmount() {
    obj$1.event.off(document.documentElement, `mousemove.swipeCell_${this.uid} mouseup.swipeCell_${this.uid}`);
  }
};
const _hoisted_1$n = ["disabled"];
const _hoisted_2$l = {
  ref: "left",
  class: "mvi-swipe-cell-left"
};
const _hoisted_3$j = {
  ref: "right",
  class: "mvi-swipe-cell-right"
};
function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "mvi-swipe-cell",
    onTouchstart: _cache[1] || (_cache[1] = (...args) => $options.cellTouchStart && $options.cellTouchStart(...args)),
    onTouchmove: _cache[2] || (_cache[2] = (...args) => $options.cellTouchMove && $options.cellTouchMove(...args)),
    onTouchend: _cache[3] || (_cache[3] = (...args) => $options.cellTouchEnd && $options.cellTouchEnd(...args)),
    style: normalizeStyle($options.cellStyle),
    disabled: $props.disabled || null,
    onMousedown: _cache[4] || (_cache[4] = (...args) => $options.cellMouseDown && $options.cellMouseDown(...args))
  }, [
    withDirectives(createElementVNode("div", _hoisted_2$l, [
      renderSlot(_ctx.$slots, "left", {}, void 0, true)
    ], 512), [
      [vShow, $data.leftShow]
    ]),
    createElementVNode("div", {
      ref: "center",
      class: "mvi-swipe-cell-center",
      onClick: _cache[0] || (_cache[0] = (...args) => $options.clickCenter && $options.clickCenter(...args))
    }, [
      renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ], 512),
    withDirectives(createElementVNode("div", _hoisted_3$j, [
      renderSlot(_ctx.$slots, "right", {}, void 0, true)
    ], 512), [
      [vShow, $data.rightShow]
    ])
  ], 44, _hoisted_1$n);
}
const SwipeCell = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$C], ["__scopeId", "data-v-1e12e6ca"]]);
SwipeCell.install = (app) => {
  app.component(SwipeCell.name, SwipeCell);
};
const circleProgress_vue_vue_type_style_index_0_scoped_e78a42ce_lang = "";
const _sfc_main$B = {
  name: "m-circle-progress",
  data() {
    return {
      pathSize: 1e3
    };
  },
  props: {
    value: {
      type: Number,
      default: 0
    },
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    size: {
      type: Number,
      default: 2
    },
    color: {
      type: String,
      default: null
    },
    trackColor: {
      type: String,
      default: null
    },
    fill: {
      type: String,
      default: null
    },
    animation: {
      type: Boolean,
      default: true
    },
    timeout: {
      type: Number,
      default: 400
    },
    showTip: {
      type: Boolean,
      default: false
    },
    tipText: {
      type: String,
      default: null
    },
    strokeWidth: {
      type: Number,
      default: 0.2
    },
    round: {
      type: Boolean,
      default: false
    },
    clockWise: {
      type: Boolean,
      default: true
    }
  },
  computed: {
    progressStyle() {
      let style = {};
      if (this.size) {
        style.width = this.size + "rem";
        style.height = this.size + "rem";
      }
      return style;
    },
    viewBox() {
      let width = obj$1.element.rem2px(this.strokeWidth);
      return `0 0 ${this.pathSize + 2 * width} ${this.pathSize + 2 * width}`;
    },
    pathD() {
      let width = obj$1.element.rem2px(this.strokeWidth);
      return `M ${this.pathSize / 2 + width} ${this.pathSize / 2 + width} m 0, -${this.pathSize / 2} a ${this.pathSize / 2}, ${this.pathSize / 2} 0 1, ${this.clockWise ? 1 : 0} 0, ${this.pathSize} a ${this.pathSize / 2}, ${this.pathSize / 2} 0 1, ${this.clockWise ? 1 : 0} 0, -${this.pathSize}`;
    },
    cmpValue() {
      if (this.tipText) {
        return this.tipText;
      } else {
        let value = this.value > this.max ? this.max : this.value < this.min ? this.min : this.value;
        return Math.round((value - this.min) / (this.max - this.min) * 100) + "%";
      }
    },
    barStyle() {
      let style = {};
      if (this.fill) {
        style.fill = this.fill;
      }
      if (this.color) {
        style.stroke = this.color;
      }
      if (obj$1.number.isNumber(this.strokeWidth)) {
        style.strokeWidth = this.strokeWidth + "rem";
      }
      if (this.round) {
        style.strokeLinecap = "round";
      }
      if (this.animation) {
        style.transition = "stroke-dasharray " + this.timeout + "ms";
        style.webkitTransition = "stroke-dasharray " + this.timeout + "ms";
      }
      let circleLength = Number((this.pathSize * Math.PI).toFixed(2));
      let value = this.value > this.max ? this.max : this.value < this.min ? this.min : this.value;
      let valueLength = Number(((value - this.min) / (this.max - this.min) * circleLength).toFixed(2));
      style.strokeDasharray = valueLength + "," + (circleLength - valueLength);
      return style;
    },
    trackStyle() {
      let style = {};
      if (this.fill) {
        style.fill = this.fill;
      }
      if (this.trackColor) {
        style.stroke = this.trackColor;
      }
      if (obj$1.number.isNumber(this.strokeWidth)) {
        style.strokeWidth = this.strokeWidth + "rem";
      }
      return style;
    }
  }
};
const _hoisted_1$m = ["viewBox"];
const _hoisted_2$k = ["d"];
const _hoisted_3$i = ["d"];
const _hoisted_4$d = {
  key: 0,
  class: "mvi-circle-progress-tip"
};
const _hoisted_5$a = ["textContent"];
function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "mvi-circle-progress",
    style: normalizeStyle($options.progressStyle)
  }, [
    (openBlock(), createElementBlock("svg", { viewBox: $options.viewBox }, [
      createElementVNode("path", {
        d: $options.pathD,
        style: normalizeStyle($options.trackStyle),
        class: "mvi-circle-progress-track"
      }, null, 12, _hoisted_2$k),
      createElementVNode("path", {
        d: $options.pathD,
        style: normalizeStyle($options.barStyle),
        class: "mvi-circle-progress-bar"
      }, null, 12, _hoisted_3$i)
    ], 8, _hoisted_1$m)),
    $props.showTip ? (openBlock(), createElementBlock("div", _hoisted_4$d, [
      _ctx.$slots.tip ? renderSlot(_ctx.$slots, "tip", {
        key: 0,
        value: $props.value
      }, void 0, true) : (openBlock(), createElementBlock("span", {
        key: 1,
        textContent: toDisplayString($options.cmpValue)
      }, null, 8, _hoisted_5$a))
    ])) : createCommentVNode("", true)
  ], 4);
}
const CircleProgress = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$B], ["__scopeId", "data-v-e78a42ce"]]);
CircleProgress.install = (app) => {
  app.component(CircleProgress.name, CircleProgress);
};
const collapse_vue_vue_type_style_index_0_scoped_b47c5bd1_lang = "";
const _sfc_main$A = {
  name: "m-collapse",
  data() {
    return {
      children: []
    };
  },
  emits: ["update:modelValue", "before-slide-down", "slide-down", "before-slide-up", "slide-up"],
  props: {
    modelValue: {
      type: [Number, Array],
      default: null
    },
    accordion: {
      type: Boolean,
      default: false
    },
    inBorder: {
      type: Boolean,
      default: true
    },
    outBorder: {
      type: Boolean,
      default: true
    },
    disabled: {
      type: Boolean,
      default: false
    },
    active: {
      type: Boolean,
      default: true
    },
    noWrap: {
      type: Boolean,
      default: false
    }
  },
  provide() {
    return {
      collapse: this
    };
  }
};
const _hoisted_1$l = { class: "mvi-collapse" };
function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$l, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true)
  ]);
}
const Collapse = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$A], ["__scopeId", "data-v-b47c5bd1"]]);
Collapse.install = (app) => {
  app.component(Collapse.name, Collapse);
};
const transitionSlide_vue_vue_type_style_index_0_scoped_446676c7_lang = "";
const _sfc_main$z = {
  name: "m-transition-slide",
  data() {
    return {
      show: true,
      height: null,
      useAnimation: false,
      opacity: 0
    };
  },
  emits: ["before-slide-down", "slide-down", "before-slide-up", "slide-up"],
  props: {
    expand: {
      type: Boolean,
      default: true
    },
    timeout: {
      type: Number,
      default: 200
    }
  },
  watch: {
    expand(newValue) {
      this.show = newValue;
    }
  },
  mounted() {
    this.show = this.expand;
    if (this.show) {
      this.useAnimation = true;
      this.opacity = "";
    }
  },
  methods: {
    beforeEnter(el) {
      el.style.height = 0;
      el.style.transition = "height " + this.timeout + "ms linear";
      el.style.webkitTransition = "height " + this.timeout + "ms linear";
      this.$emit("before-slide-down", this.$el);
    },
    enter(el) {
      el.offsetWidth;
      el.style.height = this.height;
    },
    afterEnter(el) {
      el.style.transition = "";
      el.style.webkitTransition = "";
      el.style.height = "";
      this.$emit("slide-down", this.$el);
    },
    beforeLeave(el) {
      if (!this.height) {
        this.height = obj$1.element.getCssStyle(el, "height");
      }
      el.style.height = this.height;
      if (this.useAnimation) {
        el.style.transition = "height " + this.timeout + "ms linear";
        el.style.webkitTransition = "height " + this.timeout + "ms linear";
        this.$emit("before-slide-up", this.$el);
      }
    },
    leave(el) {
      el.offsetWidth;
      el.style.height = 0;
    },
    afterLeave(el) {
      el.style.height = "";
      if (this.useAnimation) {
        el.style.transition = "";
        el.style.webkitTransition = "";
        this.$emit("slide-up", this.$el);
      } else {
        this.useAnimation = true;
        this.opacity = "";
      }
    }
  }
};
function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    name: "mvi-transition-slide",
    onBeforeEnter: $options.beforeEnter,
    onAfterEnter: $options.afterEnter,
    onBeforeLeave: $options.beforeLeave,
    onAfterLeave: $options.afterLeave,
    onEnter: $options.enter,
    onLeave: $options.leave
  }, {
    default: withCtx(() => [
      withDirectives(createElementVNode("div", {
        class: "mvi-transition-slide",
        style: normalizeStyle({ opacity: $data.opacity })
      }, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 4), [
        [vShow, $data.show]
      ])
    ]),
    _: 3
  }, 8, ["onBeforeEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave", "onEnter", "onLeave"]);
}
const TransitionSlide = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["render", _sfc_render$z], ["__scopeId", "data-v-446676c7"]]);
TransitionSlide.install = (app) => {
  app.component(TransitionSlide.name, TransitionSlide);
};
const collapseItem_vue_vue_type_style_index_0_scoped_a25113d9_lang = "";
const _sfc_main$y = {
  name: "m-collapse-item",
  inject: ["collapse"],
  props: {
    icon: {
      type: [String, Object],
      default: null
    },
    title: {
      type: String,
      default: null
    },
    label: {
      type: String,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    content: {
      type: String,
      default: ""
    }
  },
  components: {
    Cell,
    TransitionSlide
  },
  setup() {
    const uid = getCurrentInstance().uid;
    return {
      uid
    };
  },
  computed: {
    index() {
      return this.collapse.children.findIndex((vm) => {
        return obj$1.common.equal(vm.uid, this.uid);
      });
    },
    cmpActive() {
      if (this.cmpDisabled) {
        return false;
      }
      return this.collapse.active;
    },
    expand() {
      let flag = false;
      if (this.collapse.accordion) {
        if (this.collapse.modelValue === this.index) {
          flag = true;
        }
      } else {
        if (obj$1.number.isNumber(this.collapse.modelValue)) {
          if (this.collapse.modelValue === this.index) {
            flag = true;
          }
        } else if (Array.isArray(this.collapse.modelValue)) {
          if (this.collapse.modelValue.includes(this.index)) {
            flag = true;
          }
        }
      }
      return flag;
    },
    cmpDisabled() {
      return this.collapse.disabled || this.disabled;
    },
    isLast() {
      return this.collapse.children.length == this.index + 1;
    }
  },
  created() {
    this.collapse.children.push(this);
  },
  methods: {
    beforeSlideDown() {
      this.collapse.$emit("before-slide-down", this.index);
    },
    slideDown() {
      this.collapse.$emit("slide-down", this.index);
    },
    beforeSlideUp() {
      this.collapse.$emit("before-slide-up", this.index);
    },
    slideUp() {
      this.collapse.$emit("slide-up", this.index);
    },
    changeCollapse() {
      if (this.cmpDisabled) {
        return false;
      }
      if (this.collapse.accordion) {
        if (this.collapse.modelValue == this.index) {
          this.collapse.$emit("update:modelValue", null);
        } else {
          this.collapse.$emit("update:modelValue", this.index);
        }
      } else {
        if (obj$1.number.isNumber(this.collapse.modelValue)) {
          if (this.collapse.modelValue == this.index) {
            this.collapse.$emit("update:modelValue", []);
          } else {
            this.collapse.$emit("update:modelValue", [this.collapse.modelValue, this.index]);
          }
        } else if (Array.isArray(this.collapse.modelValue)) {
          let arr = [...this.collapse.modelValue];
          if (arr.includes(this.index)) {
            arr = arr.filter((item) => {
              return item != this.index;
            });
            this.collapse.$emit("update:modelValue", arr);
          } else {
            arr.push(this.index);
            this.collapse.$emit("update:modelValue", arr);
          }
        } else {
          let arr = [];
          arr.push(this.index);
          this.collapse.$emit("update:modelValue", arr);
        }
      }
    }
  }
};
const _hoisted_1$k = ["disabled"];
const _hoisted_2$j = { class: "mvi-collapse-content" };
const _hoisted_3$h = ["textContent"];
function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Cell = resolveComponent("Cell");
  const _component_TransitionSlide = resolveComponent("TransitionSlide");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["mvi-collapse-item", $options.collapse.outBorder ? "border" : ""]),
    disabled: $options.cmpDisabled || null
  }, [
    createVNode(_component_Cell, {
      class: normalizeClass(["mvi-collapse-cell", $options.expand ? "expand" : ""]),
      icon: $props.icon,
      content: $props.label,
      title: $props.title,
      border: $options.collapse.inBorder,
      arrow: "angle-right",
      onClick: $options.changeCollapse,
      active: $options.cmpActive,
      "no-wrap": $options.collapse.noWrap
    }, null, 8, ["class", "icon", "content", "title", "border", "onClick", "active", "no-wrap"]),
    createVNode(_component_TransitionSlide, {
      expand: $options.expand,
      timeout: 200,
      onBeforeSlideUp: $options.beforeSlideUp,
      onSlideUp: $options.slideUp,
      onBeforeSlideDown: $options.beforeSlideDown,
      onSlideDown: $options.slideDown
    }, {
      default: withCtx(() => [
        createElementVNode("div", _hoisted_2$j, [
          _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }, void 0, true) : (openBlock(), createElementBlock("span", {
            key: 1,
            textContent: toDisplayString($props.content)
          }, null, 8, _hoisted_3$h))
        ])
      ]),
      _: 3
    }, 8, ["expand", "onBeforeSlideUp", "onSlideUp", "onBeforeSlideDown", "onSlideDown"])
  ], 10, _hoisted_1$k);
}
const CollapseItem = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", _sfc_render$y], ["__scopeId", "data-v-a25113d9"]]);
CollapseItem.install = (app) => {
  app.component(CollapseItem.name, CollapseItem);
};
const divider_vue_vue_type_style_index_0_scoped_1eeeb2dd_lang = "";
const _sfc_main$x = {
  name: "m-divider",
  props: {
    dashed: {
      type: Boolean,
      default: false
    },
    color: {
      type: String,
      default: null
    }
  }
};
const _hoisted_1$j = {
  key: 0,
  class: "mvi-divider-center"
};
function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["mvi-divider", $props.dashed ? "dashed" : ""])
  }, [
    createElementVNode("div", {
      class: "mvi-divider-left",
      style: normalizeStyle({ borderColor: $props.color || "" })
    }, null, 4),
    this.$slots.default ? (openBlock(), createElementBlock("div", _hoisted_1$j, [
      renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ])) : createCommentVNode("", true),
    createElementVNode("div", {
      class: "mvi-divider-right",
      style: normalizeStyle({ borderColor: $props.color || "" })
    }, null, 4)
  ], 2);
}
const Divider = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$x], ["__scopeId", "data-v-1eeeb2dd"]]);
Divider.install = (app) => {
  app.component(Divider.name, Divider);
};
const roll_vue_vue_type_style_index_0_scoped_5de2e07e_lang = "";
const _sfc_main$w = {
  name: "m-roll",
  data() {
    return {
      rollEl: null,
      timer: null,
      status: -1
    };
  },
  emits: ["play", "stop", "pause"],
  props: {
    interval: {
      type: Number,
      default: 5e3
    },
    direction: {
      type: String,
      default: "left",
      validator(value) {
        return ["left", "right", "top", "bottom"].includes(value);
      }
    },
    autoplay: {
      type: Boolean,
      default: false
    },
    loop: {
      type: Boolean,
      default: false
    },
    animation: {
      type: String,
      default: "linear",
      validator(value) {
        return ["linear", "ease", "ease-in", "ease-out", "ease-in-out"].includes(value);
      }
    },
    clickStop: {
      type: Boolean,
      default: false
    },
    hoverStop: {
      type: Boolean,
      default: false
    }
  },
  mounted() {
    this.rollEl = this.$refs.roll;
    if (this.autoplay) {
      this.play();
    }
  },
  computed: {
    rollStyle() {
      let obj2 = {};
      if (this.direction == "left") {
        obj2.left = "100%";
        obj2.right = "auto";
      } else if (this.direction == "right") {
        obj2.right = "100%";
        obj2.left = "auto";
      } else if (this.direction == "top") {
        obj2.top = "100%";
        obj2.bottom = "auto";
      } else if (this.direction == "bottom") {
        obj2.bottom = "100%";
        obj2.top = "auto";
      }
      return obj2;
    },
    containerStyle() {
      let style = {};
      if (this.rollEl) {
        style.height = obj$1.element.getCssStyle(this.rollEl, "height");
      }
      return style;
    }
  },
  methods: {
    hoverIn() {
      if (this.hoverStop) {
        if (this.status == 0) {
          this.pause();
        }
      }
    },
    hoverOut() {
      if (this.hoverStop) {
        if (this.status == 1) {
          this.play();
        }
      }
    },
    clickStopFun() {
      if (this.clickStop) {
        if (this.status == 0) {
          this.pause();
        } else if (this.status == 1) {
          this.play();
        }
      }
    },
    play() {
      if (!this.$refs.roll) {
        return;
      }
      if (this.status == 0) {
        return;
      }
      this.status = 0;
      let placement = obj$1.element.getElementPoint(this.$refs.roll, this.$el);
      let interval = 0;
      if (this.direction == "left") {
        interval = Math.round((placement.left + this.$refs.roll.offsetWidth) / (this.$el.offsetWidth + this.$refs.roll.offsetWidth) * this.interval);
      } else if (this.direction == "right") {
        interval = Math.round((placement.right + this.$refs.roll.offsetWidth) / (this.$el.offsetWidth + this.$refs.roll.offsetWidth) * this.interval);
      } else if (this.direction == "top") {
        interval = Math.round((placement.top + this.$refs.roll.offsetHeight) / (this.$el.offsetHeight + this.$refs.roll.offsetHeight) * this.interval);
      } else if (this.direction == "bottom") {
        interval = Math.round((placement.bottom + this.$refs.roll.offsetHeight) / (this.$el.offsetHeight + this.$refs.roll.offsetHeight) * this.interval);
      }
      this.$refs.roll.style.transition = "all " + interval + "ms " + this.animation;
      this.$refs.roll.style.webkitTransition = "all " + interval + "ms " + this.animation;
      setTimeout(() => {
        if (!this.$refs.roll) {
          return;
        }
        if (this.direction == "left") {
          this.$refs.roll.style.left = -this.$refs.roll.offsetWidth + "px";
          this.$refs.roll.style.right = "auto";
        } else if (this.direction == "right") {
          this.$refs.roll.style.right = -this.$refs.roll.offsetWidth + "px";
          this.$refs.roll.style.left = "auto";
        } else if (this.direction == "top") {
          this.$refs.roll.style.top = -this.$refs.roll.offsetHeight + "px";
          this.$refs.roll.style.bottom = "auto";
        } else if (this.direction == "bottom") {
          this.$refs.roll.style.bottom = -this.$refs.roll.offsetHeight + "px";
          this.$refs.roll.style.top = "auto";
        }
        this.$emit("play");
        this.timer = setTimeout(() => {
          this.stop();
          if (this.loop) {
            this.play();
          }
        }, interval);
      }, 0);
    },
    stop() {
      if (this.status == 2) {
        return;
      }
      this.status = 2;
      this.$refs.roll.style.transition = "";
      this.$refs.roll.style.webkitTransition = "";
      if (this.direction == "left") {
        this.$refs.roll.style.left = "100%";
        this.$refs.roll.style.right = "auto";
      } else if (this.direction == "right") {
        this.$refs.roll.style.right = "100%";
        this.$refs.roll.style.left = "auto";
      } else if (this.direction == "top") {
        this.$refs.roll.style.top = "100%";
        this.$refs.roll.style.bottom = "auto";
      } else if (this.direction == "bottom") {
        this.$refs.roll.style.bottom = "100%";
        this.$refs.roll.style.top = "auto";
      }
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
      this.$emit("stop");
    },
    pause() {
      if (this.status != 0) {
        return;
      }
      this.status = 1;
      let placement = obj$1.element.getElementPoint(this.$refs.roll, this.$el);
      this.$refs.roll.style.transition = "";
      this.$refs.roll.style.webkitTransition = "";
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
      if (this.direction == "left") {
        this.$refs.roll.style.left = placement.left + "px";
        this.$refs.roll.style.right = "auto";
      } else if (this.direction == "right") {
        this.$refs.roll.style.right = placement.right + "px";
        this.$refs.roll.style.left = "auto";
      } else if (this.direction == "top") {
        this.$refs.roll.style.top = placement.top + "px";
        this.$refs.roll.style.bottom = "auto";
      } else if (this.direction == "bottom") {
        this.$refs.roll.style.bottom = placement.bottom + "px";
        this.$refs.roll.style.top = "auto";
      }
      this.$emit("pause");
    }
  },
  beforeUnmount() {
    this.stop();
  }
};
function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    onClick: _cache[0] || (_cache[0] = (...args) => $options.clickStopFun && $options.clickStopFun(...args)),
    onMouseenter: _cache[1] || (_cache[1] = (...args) => $options.hoverIn && $options.hoverIn(...args)),
    onMouseleave: _cache[2] || (_cache[2] = (...args) => $options.hoverOut && $options.hoverOut(...args)),
    class: "mvi-roll-container",
    style: normalizeStyle($options.containerStyle)
  }, [
    createElementVNode("div", {
      class: normalizeClass(["mvi-roll", $props.direction == "left" || $props.direction == "right" ? "horizontal" : "vertical"]),
      style: normalizeStyle($options.rollStyle),
      ref: "roll"
    }, [
      renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ], 6)
  ], 36);
}
const Roll = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$w], ["__scopeId", "data-v-5de2e07e"]]);
Roll.install = (app) => {
  app.component(Roll.name, Roll);
};
const steps_vue_vue_type_style_index_0_scoped_c61b4376_lang = "";
const _sfc_main$v = {
  name: "m-steps",
  data() {
    return {
      children: []
    };
  },
  props: {
    active: {
      type: Number,
      default: 0
    },
    vertical: {
      type: Boolean,
      default: false
    },
    activeColor: {
      type: String,
      default: null
    },
    inactiveColor: {
      type: String,
      default: null
    },
    activeIcon: {
      type: [String, Object],
      default: "success-o"
    },
    inactiveIcon: {
      type: [String, Object],
      default: null
    }
  },
  provide() {
    return {
      steps: this
    };
  }
};
function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["mvi-steps", $props.vertical ? "vertical" : ""])
  }, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true)
  ], 2);
}
const Steps = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", _sfc_render$v], ["__scopeId", "data-v-c61b4376"]]);
Steps.install = (app) => {
  app.component(Steps.name, Steps);
};
const step_vue_vue_type_style_index_0_scoped_0c19a341_lang = "";
const _sfc_main$u = {
  name: "m-step",
  data() {
    return {
      elm: null
    };
  },
  setup() {
    const uid = getCurrentInstance().uid;
    return {
      uid
    };
  },
  inject: ["steps"],
  created() {
    this.steps.children.push(this);
  },
  mounted() {
    this.elm = this.$el;
  },
  computed: {
    parseIcon() {
      return (param) => {
        let icon = {
          spin: false,
          type: null,
          url: null,
          color: null,
          size: null
        };
        if (obj$1.common.isObject(param)) {
          if (typeof param.spin == "boolean") {
            icon.spin = param.spin;
          }
          if (typeof param.type == "string") {
            icon.type = param.type;
          }
          if (typeof param.url == "string") {
            icon.url = param.url;
          }
          if (typeof param.color == "string") {
            icon.color = param.color;
          }
          if (typeof param.size == "string") {
            icon.size = param.size;
          }
        } else if (typeof param == "string") {
          icon.type = param;
        }
        return icon;
      };
    },
    stepIndex() {
      return this.steps.children.findIndex((vm) => {
        return obj$1.common.equal(vm.uid, this.uid);
      });
    },
    labelStyle() {
      let style = {};
      if (this.steps.activeColor) {
        if (this.steps.active == this.stepIndex) {
          style.color = this.steps.activeColor;
        }
      }
      if (this.steps.inactiveColor) {
        if (this.steps.active != this.stepIndex) {
          style.color = this.steps.inactiveColor;
        }
      }
      return style;
    },
    activeIconStyle() {
      let style = {};
      if (this.steps.activeColor) {
        if (this.steps.active == this.stepIndex) {
          style.color = this.steps.activeColor;
        }
      }
      return style;
    },
    inactiveIconStyle() {
      let style = {};
      if (this.steps.inactiveColor) {
        if (this.stepIndex > this.steps.active) {
          style.color = this.steps.inactiveColor;
        }
      }
      if (this.steps.activeColor) {
        if (this.stepIndex <= this.steps.active) {
          style.color = this.steps.activeColor;
        }
      }
      return style;
    },
    circleStyle() {
      let style = {};
      if (this.stepIndex <= this.steps.active) {
        if (this.steps.activeColor) {
          style.backgroundColor = this.steps.activeColor;
        }
      } else {
        if (this.steps.inactiveColor) {
          style.backgroundColor = this.steps.inactiveColor;
        }
      }
      return style;
    },
    activeCircleStyle() {
      let style = {};
      if (this.steps.activeColor) {
        if (this.steps.active == this.stepIndex) {
          style.backgroundColor = this.steps.activeColor;
        }
      }
      return style;
    },
    lineStyle() {
      let style = {};
      if (this.steps.activeColor) {
        if (this.stepIndex < this.steps.active) {
          if (this.steps.vertical) {
            style.borderRightColor = this.steps.activeColor;
          } else {
            style.borderTopColor = this.steps.activeColor;
          }
        }
      }
      if (this.steps.inactiveColor) {
        if (this.stepIndex >= this.steps.active) {
          if (this.steps.vertical) {
            style.borderRightColor = this.steps.inactiveColor;
          } else {
            style.borderTopColor = this.steps.inactiveColor;
          }
        }
      }
      return style;
    },
    stepIconStyle() {
      let style = {};
      if (this.elm) {
        style.backgroundColor = obj$1.element.getCssStyle(this.steps.$el, "background-color");
      }
      return style;
    }
  },
  components: {
    Icon
  }
};
const _hoisted_1$i = {
  key: 0,
  class: "mvi-step-vertical"
};
const _hoisted_2$i = { class: "mvi-step-vertical-container" };
const _hoisted_3$g = { class: "mvi-step-vertical-icon" };
const _hoisted_4$c = { class: "mvi-step-container" };
function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return $options.steps.vertical ? (openBlock(), createElementBlock("div", _hoisted_1$i, [
    createElementVNode("div", {
      class: normalizeClass(["mvi-step-vertical-label", $options.stepIndex == $options.steps.active ? "finish" : ""]),
      style: normalizeStyle($options.labelStyle)
    }, [
      renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ], 6),
    createElementVNode("div", _hoisted_2$i, [
      createElementVNode("div", _hoisted_3$g, [
        $options.steps.active == $options.stepIndex && ($options.parseIcon($options.steps.activeIcon).type || $options.parseIcon($options.steps.activeIcon).url) ? (openBlock(), createBlock(_component_Icon, {
          key: 0,
          class: "mvi-step-icon-active-el",
          type: $options.parseIcon($options.steps.activeIcon).type,
          url: $options.parseIcon($options.steps.activeIcon).url,
          spin: $options.parseIcon($options.steps.activeIcon).spin,
          size: $options.parseIcon($options.steps.activeIcon).size,
          color: $options.parseIcon($options.steps.activeIcon).color,
          style: normalizeStyle($options.activeIconStyle)
        }, null, 8, ["type", "url", "spin", "size", "color", "style"])) : $options.steps.active == $options.stepIndex ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: "mvi-step-circle-active",
          style: normalizeStyle($options.activeCircleStyle)
        }, null, 4)) : $options.parseIcon($options.steps.inactiveIcon).type || $options.parseIcon($options.steps.inactiveIcon).url ? (openBlock(), createBlock(_component_Icon, {
          key: 2,
          class: normalizeClass(["mvi-step-icon-inactive-el", $options.stepIndex <= $options.steps.active ? "finish" : ""]),
          type: $options.parseIcon($options.steps.inactiveIcon).type,
          url: $options.parseIcon($options.steps.inactiveIcon).url,
          spin: $options.parseIcon($options.steps.inactiveIcon).spin,
          size: $options.parseIcon($options.steps.inactiveIcon).size,
          color: $options.parseIcon($options.steps.inactiveIcon).color,
          style: normalizeStyle($options.inactiveIconStyle)
        }, null, 8, ["class", "type", "url", "spin", "size", "color", "style"])) : (openBlock(), createElementBlock("div", {
          key: 3,
          class: normalizeClass(["mvi-step-circle", $options.stepIndex <= $options.steps.active ? "finish" : ""]),
          style: normalizeStyle($options.circleStyle)
        }, null, 6))
      ]),
      createElementVNode("div", {
        class: normalizeClass(["mvi-step-vertical-line", $options.stepIndex == $options.steps.children.length - 1 ? "last" : "", $options.stepIndex < $options.steps.active ? "finish" : ""]),
        style: normalizeStyle($options.lineStyle)
      }, null, 6)
    ])
  ])) : (openBlock(), createElementBlock("div", {
    key: 1,
    class: normalizeClass(["mvi-step", $options.stepIndex == $options.steps.children.length - 1 ? "last" : ""])
  }, [
    createElementVNode("div", {
      class: normalizeClass(["mvi-step-label", $options.stepIndex == $options.steps.children.length - 1 ? "last" : "", $options.stepIndex == 0 ? "first" : "", $options.stepIndex == $options.steps.active ? "finish" : ""]),
      style: normalizeStyle($options.labelStyle)
    }, [
      createElementVNode("div", null, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ])
    ], 6),
    createElementVNode("div", _hoisted_4$c, [
      createElementVNode("div", {
        class: normalizeClass(["mvi-step-icon", $options.stepIndex == $options.steps.children.length - 1 ? "last" : ""]),
        style: normalizeStyle($options.stepIconStyle)
      }, [
        $options.steps.active == $options.stepIndex && ($options.parseIcon($options.steps.activeIcon).type || $options.parseIcon($options.steps.activeIcon).url) ? (openBlock(), createBlock(_component_Icon, {
          key: 0,
          class: "mvi-step-icon-active-el",
          type: $options.parseIcon($options.steps.activeIcon).type,
          url: $options.parseIcon($options.steps.activeIcon).url,
          spin: $options.parseIcon($options.steps.activeIcon).spin,
          size: $options.parseIcon($options.steps.activeIcon).size,
          color: $options.parseIcon($options.steps.activeIcon).color,
          style: normalizeStyle($options.activeIconStyle)
        }, null, 8, ["type", "url", "spin", "size", "color", "style"])) : $options.steps.active == $options.stepIndex ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: "mvi-step-circle-active",
          style: normalizeStyle($options.activeCircleStyle)
        }, null, 4)) : $options.parseIcon($options.steps.inactiveIcon).type || $options.parseIcon($options.steps.inactiveIcon).url ? (openBlock(), createBlock(_component_Icon, {
          key: 2,
          class: normalizeClass(["mvi-step-icon-inactive-el", $options.stepIndex <= $options.steps.active ? "finish" : ""]),
          type: $options.parseIcon($options.steps.inactiveIcon).type,
          url: $options.parseIcon($options.steps.inactiveIcon).url,
          spin: $options.parseIcon($options.steps.inactiveIcon).spin,
          size: $options.parseIcon($options.steps.inactiveIcon).size,
          color: $options.parseIcon($options.steps.inactiveIcon).color,
          style: normalizeStyle($options.inactiveIconStyle)
        }, null, 8, ["class", "type", "url", "spin", "size", "color", "style"])) : (openBlock(), createElementBlock("div", {
          key: 3,
          class: normalizeClass(["mvi-step-circle", $options.stepIndex <= $options.steps.active ? "finish" : ""]),
          style: normalizeStyle($options.circleStyle)
        }, null, 6))
      ], 6),
      createElementVNode("div", {
        class: normalizeClass(["mvi-step-line", $options.stepIndex == $options.steps.children.length - 1 ? "last" : "", $options.stepIndex < $options.steps.active ? "finish" : ""]),
        style: normalizeStyle($options.lineStyle)
      }, null, 6)
    ])
  ], 2));
}
const Step = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$u], ["__scopeId", "data-v-0c19a341"]]);
Step.install = (app) => {
  app.component(Step.name, Step);
};
const label_vue_vue_type_style_index_0_scoped_bb5198b2_lang = "";
const _sfc_main$t = {
  name: "m-label",
  data() {
    return {
      show: true
    };
  },
  props: {
    type: {
      type: String,
      default: "default",
      validator(value) {
        return ["default", "error", "info", "primary", "success", "warn"].includes(value);
      }
    },
    size: {
      type: String,
      default: "medium",
      validator(value) {
        return ["medium", "large"].includes(value);
      }
    },
    color: {
      type: String,
      default: null
    },
    plain: {
      type: Boolean,
      default: false
    },
    round: {
      type: Boolean,
      default: false
    },
    mark: {
      type: Boolean,
      default: false
    },
    subColor: {
      type: String,
      default: null
    },
    closable: {
      type: Boolean,
      default: false
    },
    reverse: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    labelClass() {
      let cls = ["mvi-label"];
      if (this.size) {
        cls.push(this.size);
      }
      if (this.type) {
        cls.push(this.type);
      }
      if (this.plain) {
        cls.push("plain");
      }
      if (this.round) {
        cls.push("round");
      }
      if (this.mark) {
        cls.push("mark");
        if (this.reverse) {
          cls.push("reverse");
        }
      }
      return cls;
    },
    labelStyle() {
      let style = {};
      if (this.color) {
        if (this.plain) {
          style.borderColor = this.color;
          style.color = this.color;
          style.backgroundColor = this.subColor || "#fff";
        } else {
          style.backgroundColor = this.color;
          style.borderColor = this.color;
          style.color = this.subColor || "#fff";
        }
      }
      return style;
    }
  },
  components: {
    Icon
  },
  methods: {
    closeLabel() {
      this.show = false;
    }
  }
};
function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return $props.closable ? (openBlock(), createBlock(Transition, {
    key: 0,
    name: "mvi-label"
  }, {
    default: withCtx(() => [
      $data.show ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass($options.labelClass),
        style: normalizeStyle($options.labelStyle)
      }, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true),
        createElementVNode("span", {
          class: "mvi-label-closable",
          onClick: _cache[0] || (_cache[0] = (...args) => $options.closeLabel && $options.closeLabel(...args))
        }, [
          createVNode(_component_Icon, { type: "times" })
        ])
      ], 6)) : createCommentVNode("", true)
    ]),
    _: 3
  })) : (openBlock(), createElementBlock("div", {
    key: 1,
    class: normalizeClass($options.labelClass),
    style: normalizeStyle($options.labelStyle)
  }, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true)
  ], 6));
}
const Label = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$t], ["__scopeId", "data-v-bb5198b2"]]);
Label.install = (app) => {
  app.component(Label.name, Label);
};
const swiper_vue_vue_type_style_index_0_scoped_3e00cf07_lang = "";
const _sfc_main$s = {
  name: "m-swiper",
  provide() {
    return {
      swiper: this
    };
  },
  emits: ["before-change", "change"],
  data() {
    return {
      elm: null,
      sizeCounts: 0,
      children: [],
      start: 0,
      initStart: 0,
      transform: 0,
      timer: null,
      totalMove: 0,
      oldIndex: -1,
      amounts: 0,
      mouseDown: false,
      fadeActiveIndex: 0,
      useOpacity: true,
      apiDoSlide: false
    };
  },
  props: {
    autoplay: {
      type: Boolean,
      default: false
    },
    speed: {
      type: Number,
      default: 500
    },
    interval: {
      type: Number,
      default: 5e3
    },
    initialSlide: {
      type: Number,
      default: 0
    },
    width: {
      type: String,
      default: null
    },
    height: {
      type: String,
      default: null
    },
    loop: {
      type: Boolean,
      default: false
    },
    showIndicators: {
      type: Boolean,
      default: false
    },
    activeColor: {
      type: String,
      default: null
    },
    inactiveColor: {
      type: String,
      default: null
    },
    vertical: {
      type: Boolean,
      default: false
    },
    touchable: {
      type: Boolean,
      default: true
    },
    showControl: {
      type: Boolean,
      default: false
    },
    fade: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    indicatorStyle() {
      return (index) => {
        let style = {};
        if (this.isIndicatorActive(index)) {
          if (this.activeColor) {
            style.backgroundColor = this.activeColor;
          }
        } else {
          if (this.inactiveColor) {
            style.backgroundColor = this.inactiveColor;
          }
        }
        return style;
      };
    },
    wrapperStyle() {
      let style = {};
      if (this.vertical) {
        style.height = "calc(100% * " + this.children.length + ")";
        style.transform = "translateY(" + this.transform + "px)";
        style.webkitTransform = "translateY(" + this.transform + "px)";
      } else {
        style.width = "calc(100% * " + this.children.length + ")";
        style.transform = "translateX(" + this.transform + "px)";
        style.webkitTransform = "translateX(" + this.transform + "px)";
      }
      return style;
    },
    containerStyle() {
      let style = {};
      if (this.width) {
        style.width = this.width;
      }
      if (this.height) {
        style.height = this.height;
      }
      return style;
    },
    slideSize() {
      this.sizeCounts;
      let width = 0;
      if (this.vertical) {
        if (this.height) {
          if (this.height.includes("rem")) {
            width = obj$1.element.rem2px(parseFloat(this.height));
          } else if (this.height.includes("px")) {
            width = parseFloat(this.height);
          } else if (this.elm) {
            width = parseFloat(obj$1.element.getCssStyle(this.elm, "height"));
          }
        } else if (this.elm) {
          width = parseFloat(obj$1.element.getCssStyle(this.elm, "height"));
        }
      } else {
        if (this.width) {
          if (this.width.includes("rem")) {
            width = obj$1.element.rem2px(parseFloat(this.width));
          } else if (this.width.includes("px")) {
            width = parseFloat(this.width);
          } else if (this.elm) {
            width = parseFloat(obj$1.element.getCssStyle(this.elm, "width"));
          }
        } else if (this.elm) {
          width = parseFloat(obj$1.element.getCssStyle(this.elm, "width"));
        }
      }
      return Number(width.toFixed(2));
    },
    activeIndex() {
      let index = 0;
      if (this.totalMove <= 0) {
        index = this.mathNext(Math.abs(obj$1.number.divide(this.transform, this.slideSize)));
      } else {
        index = this.mathPrev(Math.abs(obj$1.number.divide(this.transform, this.slideSize)));
      }
      if (index > this.children.length - 1) {
        index = this.children.length - 1;
      } else if (index < 0) {
        index = 0;
      }
      return index;
    },
    indicatorsIndex() {
      let index = 0;
      if (this.fade) {
        index = this.fadeActiveIndex;
      } else {
        if (this.loop) {
          if (this.activeIndex == this.children.length - 1) {
            index = 0;
          } else if (this.activeIndex == 0) {
            index = this.children.length - 3;
          } else {
            index = this.activeIndex - 1;
          }
        } else {
          index = this.activeIndex;
        }
      }
      return index;
    },
    cmpInitalSlide() {
      if (this.loop) {
        if (this.initialSlide < this.children.length - 2) {
          return this.initialSlide + 1;
        } else {
          return 1;
        }
      } else {
        return this.initialSlide;
      }
    },
    controlStyle() {
      return (index) => {
        let style = {};
        if (index == 0) {
          style.left = "0";
          style.right = "auto";
        } else {
          style.left = "auto";
          style.right = "0";
        }
        return style;
      };
    },
    indicatorShow() {
      return (index) => {
        if (this.fade) {
          return true;
        }
        return this.loop ? index != 0 && index != this.children.length - 1 : true;
      };
    },
    indicatorsTotal() {
      if (this.fade) {
        return this.children.length;
      }
      if (this.loop) {
        return this.children.length - 2 > 0 ? this.children.length - 2 : 0;
      }
      return this.children.length;
    },
    isIndicatorActive() {
      return (index) => {
        if (this.fade) {
          return this.indicatorsIndex == index;
        }
        if (this.loop) {
          return this.indicatorsIndex + 1 == index;
        }
        return this.indicatorsIndex == index;
      };
    }
  },
  components: {
    Icon
  },
  watch: {
    autoplay() {
      this.setAutoplay();
    },
    initialSlide(newValue) {
      if (this.fade) {
        this.useOpacity = false;
        this.fadeActiveIndex = newValue;
      } else {
        this.setDefaultSlide();
      }
    }
  },
  created() {
    if (this.fade) {
      this.fadeActiveIndex = this.initialSlide;
    }
  },
  setup() {
    const instance = getCurrentInstance();
    return {
      uid: instance.uid
    };
  },
  mounted() {
    this.elm = this.$el;
    if (this.children.length == 0) {
      return;
    }
    if (this.fade) {
      this.setAutoplay();
    } else {
      if (this.loop && this.children.length > 0) {
        let copy_first = this.children[0].$el.cloneNode(true);
        let copy_last = this.children[this.children.length - 1].$el.cloneNode(true);
        this.$refs.wrapper.append(copy_first);
        this.$refs.wrapper.prepend(copy_last);
        this.children.unshift({
          $el: copy_last
        });
        this.children.push({
          $el: copy_first
        });
      }
      this.setDefaultSlide();
      obj$1.event.on(document.documentElement, `mousemove.swiper_${this.uid}`, this.swiperMouseMove);
      obj$1.event.on(document.documentElement, `mouseup.swiper_${this.uid}`, this.swiperMouseUp);
    }
    obj$1.event.on(window, `resize.swiper_${this.uid}`, this.resizeChange);
  },
  methods: {
    resizeChange() {
      this.sizeCounts++;
      this.transform = -obj$1.number.mutiply(this.activeIndex, this.slideSize);
    },
    setAutoplay() {
      if (this.children.length == 0) {
        return;
      }
      if (this.autoplay && !this.timer && this.interval > this.speed) {
        this.timer = setInterval(() => {
          this.slideNext();
        }, this.interval);
      } else {
        if (this.timer) {
          clearInterval(this.timer);
          this.timer = null;
        }
      }
    },
    swiperTouchStart(event2) {
      if (this.children.length == 0) {
        return;
      }
      if (!this.touchable) {
        return;
      }
      if (this.apiDoSlide) {
        return;
      }
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
      this.amounts = 0;
      this.totalMove = 0;
      if (this.vertical) {
        this.start = event2.targetTouches[0].pageY;
      } else {
        this.start = event2.targetTouches[0].pageX;
      }
      this.initStart = this.start;
      this.removeTransition();
    },
    swiperTouchMove(event2) {
      if (this.children.length == 0) {
        return;
      }
      if (!this.touchable) {
        return;
      }
      if (event2.cancelable) {
        event2.preventDefault();
      }
      let end = 0;
      if (this.vertical) {
        end = event2.targetTouches[0].pageY;
      } else {
        end = event2.targetTouches[0].pageX;
      }
      let move = end - this.start;
      this.totalMove = end - this.initStart;
      if (this.totalMove > 0) {
        if (this.transform >= 0) {
          this.amounts++;
          this.transform = obj$1.number.add(this.transform, obj$1.number.divide(move, this.amounts));
          this.start = end;
          return;
        }
      } else {
        if (this.transform <= -obj$1.number.mutiply(this.children.length - 1, this.slideSize)) {
          this.amounts++;
          this.transform = obj$1.number.add(this.transform, obj$1.number.divide(move, this.amounts));
          this.start = end;
          return;
        }
      }
      this.start = end;
      this.transform = obj$1.number.add(this.transform, move);
    },
    swiperTouchEnd(event2) {
      if (this.children.length == 0) {
        return;
      }
      if (!this.touchable) {
        return;
      }
      this.addTransition().then(() => {
        this.transform = -obj$1.number.mutiply(this.activeIndex, this.slideSize);
        setTimeout(() => {
          this.slideDone();
        }, this.speed);
      });
    },
    swiperMouseDown(event2) {
      if (this.children.length == 0) {
        return;
      }
      if (!this.touchable) {
        return;
      }
      if (this.apiDoSlide) {
        return;
      }
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
      this.mouseDown = true;
      this.amounts = 0;
      this.totalMove = 0;
      if (this.vertical) {
        this.start = event2.pageY;
      } else {
        this.start = event2.pageX;
      }
      this.initStart = this.start;
      this.removeTransition();
    },
    swiperMouseMove(event2) {
      if (this.children.length == 0) {
        return;
      }
      if (!this.touchable) {
        return;
      }
      if (!this.mouseDown) {
        return;
      }
      if (event2.cancelable) {
        event2.preventDefault();
      }
      let end = 0;
      if (this.vertical) {
        end = event2.pageY;
      } else {
        end = event2.pageX;
      }
      let move = end - this.start;
      this.totalMove = end - this.initStart;
      if (this.totalMove > 0) {
        if (this.transform >= 0) {
          this.amounts++;
          this.transform = obj$1.number.add(this.transform, obj$1.number.divide(move, this.amounts));
          this.start = end;
          return;
        }
      } else {
        if (this.transform <= -obj$1.number.mutiply(this.children.length - 1, this.slideSize)) {
          this.amounts++;
          this.transform = obj$1.number.add(this.transform, obj$1.number.divide(move, this.amounts));
          this.start = end;
          return;
        }
      }
      this.start = end;
      this.transform = obj$1.number.add(this.transform, move);
    },
    swiperMouseUp(event2) {
      if (this.children.length == 0) {
        return;
      }
      if (!this.touchable) {
        return;
      }
      if (!this.mouseDown) {
        return;
      }
      this.mouseDown = false;
      this.addTransition().then(() => {
        this.transform = -obj$1.number.mutiply(this.activeIndex, this.slideSize);
        setTimeout(() => {
          this.slideDone();
        }, this.speed);
      });
    },
    setDefaultSlide() {
      if (this.children.length == 0) {
        return;
      }
      if (!this.fade) {
        if (!this.$refs.wrapper) {
          return;
        }
        this.removeTransition().then(() => {
          this.transform = -obj$1.number.mutiply(this.cmpInitalSlide, this.slideSize);
          this.$nextTick(() => {
            setTimeout(() => {
              if (!this.$refs.wrapper) {
                return;
              }
              this.addTransition().then(() => {
                this.oldIndex = this.initialSlide;
                this.setAutoplay();
              });
            }, 50);
          });
        });
      }
    },
    addTransition() {
      return new Promise((resolve, reject) => {
        this.$refs.wrapper.style.transition = "transform " + this.speed + "ms";
        this.$refs.wrapper.style.webkitTransition = "transform " + this.speed + "ms";
        setTimeout(() => {
          resolve();
        }, 10);
      });
    },
    removeTransition() {
      return new Promise((resolve, reject) => {
        this.$refs.wrapper.style.transition = "";
        this.$refs.wrapper.style.webkitTransition = "";
        setTimeout(() => {
          resolve();
        }, 10);
      });
    },
    slideDone() {
      return new Promise((resolve, reject) => {
        if (this.loop) {
          if (this.transform == -obj$1.number.mutiply(this.children.length - 1, this.slideSize)) {
            this.removeTransition().then(() => {
              this.transform = -this.slideSize;
              this.$nextTick(() => {
                setTimeout(() => {
                  this.addTransition().then(() => {
                    if (this.indicatorsIndex != this.oldIndex) {
                      this.oldIndex = this.indicatorsIndex;
                      this.$emit("change", this.indicatorsIndex);
                    }
                    this.setAutoplay();
                    resolve();
                  });
                }, 50);
              });
            });
          } else if (this.transform == 0) {
            this.removeTransition().then(() => {
              this.transform = -obj$1.number.mutiply(this.children.length - 2, this.slideSize);
              this.$nextTick(() => {
                setTimeout(() => {
                  this.addTransition().then(() => {
                    if (this.indicatorsIndex != this.oldIndex) {
                      this.oldIndex = this.indicatorsIndex;
                      this.$emit("change", this.indicatorsIndex);
                    }
                    this.setAutoplay();
                    resolve();
                  });
                }, 50);
              });
            });
          } else {
            if (this.indicatorsIndex != this.oldIndex) {
              this.oldIndex = this.indicatorsIndex;
              this.$emit("change", this.indicatorsIndex);
            }
            this.setAutoplay();
            resolve();
          }
        } else {
          if (this.indicatorsIndex != this.oldIndex) {
            this.oldIndex = this.indicatorsIndex;
            this.$emit("change", this.indicatorsIndex);
          }
          this.setAutoplay();
          resolve();
        }
      });
    },
    mathNext(number2) {
      const num = Math.floor(number2);
      const floor = obj$1.number.subtract(number2, num);
      if (floor >= 0.25) {
        return num + 1;
      } else {
        return num;
      }
    },
    mathPrev(number2) {
      const num = Math.floor(number2);
      const floor = obj$1.number.subtract(number2, num);
      if (floor <= 0.75) {
        return num;
      } else {
        return num + 1;
      }
    },
    slideTo(index) {
      return new Promise((resolve, reject) => {
        if (this.children.length == 0) {
          resolve();
          return;
        }
        if (this.fade) {
          if (index > this.children.length - 1) {
            index = this.children.length - 1;
          } else if (index < 0) {
            index = 0;
          }
          if (this.fadeActiveIndex != index) {
            this.$emit("before-change", this.fadeActiveIndex);
            this.fadeActiveIndex = index;
            if (this.timer) {
              clearInterval(this.timer);
              this.timer = null;
            }
            setTimeout(() => {
              this.$emit("change", this.fadeActiveIndex);
              this.setAutoplay();
              resolve();
            }, this.speed);
          } else {
            resolve();
          }
        } else {
          if (this.oldIndex > index) {
            if (this.transform >= 0) {
              resolve();
              return;
            }
            this.apiDoSlide = true;
            this.$emit("before-change", this.oldIndex);
            if (this.timer) {
              clearInterval(this.timer);
              this.timer = null;
            }
            this.addTransition().then(() => {
              this.transform = obj$1.number.add(this.transform, obj$1.number.mutiply(this.oldIndex - index, this.slideSize));
              setTimeout(() => {
                this.slideDone().then(() => {
                  this.apiDoSlide = false;
                  resolve();
                });
              }, this.speed);
            });
          } else {
            if (this.transform <= -obj$1.number.mutiply(this.children.length - 1, this.slideSize)) {
              resolve();
              return;
            }
            this.apiDoSlide = true;
            this.$emit("before-change", this.oldIndex);
            if (this.timer) {
              clearInterval(this.timer);
              this.timer = null;
            }
            this.addTransition().then(() => {
              this.transform = obj$1.number.subtract(this.transform, obj$1.number.mutiply(index - this.oldIndex, this.slideSize));
              setTimeout(() => {
                this.slideDone().then(() => {
                  this.apiDoSlide = false;
                  resolve();
                });
              }, this.speed);
            });
          }
        }
      });
    },
    slideNext() {
      return new Promise((resolve, reject) => {
        if (this.children.length == 0) {
          resolve();
          return;
        }
        if (this.fade) {
          if (this.loop) {
            this.$emit("before-change", this.fadeActiveIndex);
            if (this.fadeActiveIndex == this.children.length - 1) {
              this.fadeActiveIndex = 0;
            } else {
              this.fadeActiveIndex++;
            }
            if (this.timer) {
              clearInterval(this.timer);
              this.timer = null;
            }
            setTimeout(() => {
              this.$emit("change", this.fadeActiveIndex);
              this.setAutoplay();
              resolve();
            }, this.speed);
          } else {
            if (this.fadeActiveIndex != this.children.length - 1) {
              this.$emit("before-change", this.fadeActiveIndex);
              this.fadeActiveIndex++;
              if (this.timer) {
                clearInterval(this.timer);
                this.timer = null;
              }
              setTimeout(() => {
                this.$emit("change", this.fadeActiveIndex);
                this.setAutoplay();
                resolve();
              }, this.speed);
            } else {
              resolve();
            }
          }
        } else {
          if (this.transform <= -obj$1.number.mutiply(this.children.length - 1, this.slideSize)) {
            resolve();
            return;
          }
          this.apiDoSlide = true;
          this.$emit("before-change", this.oldIndex);
          if (this.timer) {
            clearInterval(this.timer);
            this.timer = null;
          }
          this.addTransition().then(() => {
            this.transform = obj$1.number.subtract(this.transform, this.slideSize);
            setTimeout(() => {
              this.slideDone().then(() => {
                this.apiDoSlide = false;
                resolve();
              });
            }, this.speed);
          });
        }
      });
    },
    slidePrev() {
      return new Promise((resolve, reject) => {
        if (this.children.length == 0) {
          resolve();
          return;
        }
        if (this.fade) {
          if (this.loop) {
            this.$emit("before-change", this.fadeActiveIndex);
            if (this.fadeActiveIndex == 0) {
              this.fadeActiveIndex = this.children.length - 1;
            } else {
              this.fadeActiveIndex--;
            }
            if (this.timer) {
              clearInterval(this.timer);
              this.timer = null;
            }
            setTimeout(() => {
              this.$emit("change", this.fadeActiveIndex);
              this.setAutoplay();
              resolve();
            }, this.speed);
          } else {
            if (this.fadeActiveIndex != 0) {
              this.$emit("before-change", this.fadeActiveIndex);
              this.fadeActiveIndex--;
              if (this.timer) {
                clearInterval(this.timer);
                this.timer = null;
              }
              setTimeout(() => {
                this.$emit("change", this.fadeActiveIndex);
                this.setAutoplay();
                resolve();
              }, this.speed);
            } else {
              resolve();
            }
          }
        } else {
          if (this.transform >= 0) {
            resolve();
            return;
          }
          this.apiDoSlide = true;
          this.$emit("before-change", this.oldIndex);
          if (this.timer) {
            clearInterval(this.timer);
            this.timer = null;
          }
          this.addTransition().then(() => {
            this.transform = obj$1.number.add(this.transform, this.slideSize);
            setTimeout(() => {
              this.slideDone().then(() => {
                this.apiDoSlide = false;
                resolve();
              });
            }, this.speed);
          });
        }
      });
    }
  },
  beforeUnmount() {
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = null;
    }
    if (!this.fade) {
      obj$1.event.off(document.documentElement, `mousemove.swiper_${this.uid} mouseup.swiper_${this.uid}`);
    }
    obj$1.event.off(window, `resize.swiper_${this.uid}`);
  }
};
const _hoisted_1$h = {
  key: 0,
  class: "mvi-swiper-fade"
};
const _hoisted_2$h = {
  key: 3,
  class: "mvi-swiper-indicators"
};
const _hoisted_3$f = ["onClick"];
function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["mvi-swiper-container", $props.vertical ? "vertical" : ""]),
    style: normalizeStyle($options.containerStyle)
  }, [
    $props.fade ? (openBlock(), createElementBlock("div", _hoisted_1$h, [
      renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ])) : (openBlock(), createElementBlock("div", {
      key: 1,
      class: "mvi-swiper-wrapper",
      ref: "wrapper",
      style: normalizeStyle($options.wrapperStyle),
      onTouchstart: _cache[0] || (_cache[0] = (...args) => $options.swiperTouchStart && $options.swiperTouchStart(...args)),
      onTouchmove: _cache[1] || (_cache[1] = (...args) => $options.swiperTouchMove && $options.swiperTouchMove(...args)),
      onTouchend: _cache[2] || (_cache[2] = (...args) => $options.swiperTouchEnd && $options.swiperTouchEnd(...args)),
      onMousedown: _cache[3] || (_cache[3] = (...args) => $options.swiperMouseDown && $options.swiperMouseDown(...args))
    }, [
      renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ], 36)),
    _ctx.$slots.indicators ? renderSlot(_ctx.$slots, "indicators", {
      key: 2,
      active: $options.indicatorsIndex,
      total: $options.indicatorsTotal
    }, void 0, true) : $props.showIndicators ? (openBlock(), createElementBlock("div", _hoisted_2$h, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($data.children, (item, index) => {
        return openBlock(), createElementBlock(Fragment, null, [
          $options.indicatorShow(index) ? (openBlock(), createElementBlock("div", {
            class: normalizeClass(["mvi-swiper-indicator", $options.isIndicatorActive(index) ? "active" : ""]),
            style: normalizeStyle($options.indicatorStyle(index)),
            key: "indicator-" + index,
            onClick: ($event) => $options.slideTo($props.fade ? index : $props.loop ? index - 1 : index)
          }, null, 14, _hoisted_3$f)) : createCommentVNode("", true)
        ], 64);
      }), 256))
    ])) : createCommentVNode("", true),
    $props.showControl ? (openBlock(), createElementBlock("div", {
      key: 4,
      class: "mvi-swiper-control",
      style: normalizeStyle($options.controlStyle(0)),
      onClick: _cache[4] || (_cache[4] = (...args) => $options.slidePrev && $options.slidePrev(...args))
    }, [
      createVNode(_component_Icon, { type: "angle-left" })
    ], 4)) : createCommentVNode("", true),
    $props.showControl ? (openBlock(), createElementBlock("div", {
      key: 5,
      class: "mvi-swiper-control",
      style: normalizeStyle($options.controlStyle(1)),
      onClick: _cache[5] || (_cache[5] = (...args) => $options.slideNext && $options.slideNext(...args))
    }, [
      createVNode(_component_Icon, { type: "angle-right" })
    ], 4)) : createCommentVNode("", true)
  ], 6);
}
const Swiper = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$s], ["__scopeId", "data-v-3e00cf07"]]);
Swiper.install = (app) => {
  app.component(Swiper.name, Swiper);
};
const swiperSlide_vue_vue_type_style_index_0_scoped_1cd4abbd_lang = "";
const _sfc_main$r = {
  name: "m-swiper-slide",
  setup() {
    const uid = getCurrentInstance().uid;
    return {
      uid
    };
  },
  inject: ["swiper"],
  created() {
    this.swiper.children.push(this);
  },
  computed: {
    slideStyle() {
      let style = {};
      if (this.swiper.vertical) {
        style.width = "100%";
        style.height = this.swiper.fade ? "100%" : "calc(100% * " + 1 / this.swiper.children.length + ")";
      } else {
        style.height = "100%";
        style.width = this.swiper.fade ? "100%" : "calc(100% * " + 1 / this.swiper.children.length + ")";
      }
      return style;
    },
    slideIndex() {
      return this.swiper.children.findIndex((vm) => {
        return obj$1.common.equal(vm.uid, this.uid);
      });
    }
  },
  methods: {
    addTransition(el) {
      if (this.swiper.useOpacity) {
        el.style.transition = "opacity " + this.swiper.speed + "ms";
        el.style.webkitTransition = "opacity " + this.swiper.speed + "ms";
      } else {
        el.style.transition = "";
        el.style.webkitTransition = "";
      }
    },
    removeTransition(el) {
      if (this.swiper.useOpacity) {
        el.style.transition = "";
        el.style.webkitTransition = "";
      } else {
        this.swiper.useOpacity = true;
      }
    }
  }
};
function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
  return $options.swiper.fade ? (openBlock(), createBlock(Transition, {
    key: 0,
    name: "mvi-swiper-slide",
    onBeforeEnter: $options.addTransition,
    onAfterEnter: $options.removeTransition,
    onBeforeLeave: $options.addTransition,
    onAfterLeave: $options.removeTransition
  }, {
    default: withCtx(() => [
      withDirectives(createElementVNode("div", {
        class: "mvi-swiper-slide-fade",
        style: normalizeStyle($options.slideStyle)
      }, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 4), [
        [vShow, $options.swiper.fadeActiveIndex == $options.slideIndex]
      ])
    ]),
    _: 3
  }, 8, ["onBeforeEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave"])) : (openBlock(), createElementBlock("div", {
    key: 1,
    class: "mvi-swiper-slide",
    style: normalizeStyle($options.slideStyle)
  }, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true)
  ], 4));
}
const SwiperSlide = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$r], ["__scopeId", "data-v-1cd4abbd"]]);
SwiperSlide.install = (app) => {
  app.component(SwiperSlide.name, SwiperSlide);
};
const tabs_vue_vue_type_style_index_0_scoped_b7e3e17c_lang = "";
const _sfc_main$q = {
  name: "m-tabs",
  data() {
    return {
      children: [],
      slideLeft: 0,
      slideWidth: 0,
      current: 0
    };
  },
  provide() {
    return {
      tabs: this
    };
  },
  emits: ["update:modelValue", "change"],
  props: {
    type: {
      type: String,
      default: "default",
      validator(value) {
        return ["default", "card"].includes(value);
      }
    },
    modelValue: {
      type: Number,
      default: 0
    },
    animation: {
      type: String,
      default: "none",
      validator(value) {
        return ["none", "slide", "fade"].includes(value);
      }
    },
    timeout: {
      type: Number,
      default: 200
    },
    ellipsis: {
      type: Boolean,
      default: true
    },
    border: {
      type: Boolean,
      default: false
    },
    flex: {
      type: String,
      default: "space-between"
    },
    offset: {
      type: String,
      default: "0"
    },
    activeColor: {
      type: String,
      default: null
    }
  },
  computed: {
    sliderStyle() {
      let style = {};
      if (this.animation == "slide" || this.animation == "fade") {
        style.transition = "left " + this.timeout + "ms,width " + this.timeout + "ms";
        style.webkitTransition = "left " + this.timeout + "ms,width " + this.timeout + "ms";
      }
      if (this.activeColor) {
        style.background = this.activeColor;
      }
      style.width = this.slideWidth + "px";
      style.left = this.slideLeft + "px";
      return style;
    },
    headersStyle() {
      let style = {};
      if (this.flex && this.type == "default") {
        style.justifyContent = this.flex;
      }
      if (this.type == "card" && this.activeColor) {
        style.borderColor = this.activeColor;
      }
      return style;
    },
    headerClass() {
      return (item, index) => {
        let cls = ["mvi-tab-header"];
        if (this.modelValue == index) {
          cls.push("active");
        }
        if (this.ellipsis) {
          cls.push("ellipsis");
        }
        return cls;
      };
    },
    headerStyle() {
      return (item, index) => {
        let style = {};
        if (this.offset && index != 0 && this.type == "default") {
          style.marginLeft = this.offset;
        }
        if (this.activeColor) {
          style.borderColor = this.activeColor;
          if (this.modelValue == index) {
            if (this.type == "default") {
              style.color = this.activeColor;
            } else {
              style.background = this.activeColor;
            }
          }
        }
        style.maxWidth = `calc(100% / ${this.children.length})`;
        return style;
      };
    },
    parseIcon() {
      return (param) => {
        let icon = {
          spin: false,
          type: null,
          url: null,
          color: null,
          size: null
        };
        if (obj$1.common.isObject(param)) {
          if (typeof param.spin == "boolean") {
            icon.spin = param.spin;
          }
          if (typeof param.type == "string") {
            icon.type = param.type;
          }
          if (typeof param.url == "string") {
            icon.url = param.url;
          }
          if (typeof param.color == "string") {
            icon.color = param.color;
          }
          if (typeof param.size == "string") {
            icon.size = param.size;
          }
        } else if (typeof param == "string") {
          icon.type = param;
        }
        return icon;
      };
    }
  },
  components: {
    Icon
  },
  created() {
    this.current = this.modelValue;
  },
  watch: {
    modelValue(newValue, oldValue) {
      this.to(newValue, oldValue);
    }
  },
  setup() {
    const instance = getCurrentInstance();
    return {
      uid: instance.uid
    };
  },
  mounted() {
    this.$nextTick(() => {
      this.setSlider();
    });
    this.setHeight();
    obj$1.event.on(window, `resize.tabs_${this.uid}`, this.setHeight);
  },
  methods: {
    clickHeader(item, index) {
      if (item.disabled) {
        return;
      }
      if (this.modelValue == index) {
        return;
      }
      this.$emit("update:modelValue", index);
      this.$emit("change", index);
    },
    to(newValue, oldValue) {
      for (let i = 0; i < this.children.length; i++) {
        this.children[i].show = false;
        if (newValue < oldValue) {
          this.children[i].back = true;
        } else {
          this.children[i].back = false;
        }
      }
      this.children[newValue].show = true;
      if (!this.children[newValue].firstShow) {
        this.children[newValue].firstShow = true;
      }
      this.$nextTick(() => {
        this.current = newValue;
        this.setHeight();
        this.setSlider();
      });
    },
    setHeight() {
      if (this.children[this.current] && this.$refs.content) {
        this.$refs.content.style.height = this.children[this.current].$el.offsetHeight + "px";
      }
    },
    setSlider() {
      if (this.type == "card") {
        return;
      }
      if (!this.$refs.headers) {
        return;
      }
      this.slideWidth = parseFloat(obj$1.element.getCssStyle(this.$refs.headers.querySelector(".mvi-tab-header.active"), "width"));
      this.slideLeft = obj$1.element.getElementPoint(this.$refs.headers.querySelector(".mvi-tab-header.active"), this.$refs.headers).left;
    }
  },
  beforeUnmount() {
    obj$1.event.off(window, `resize.tabs_${this.uid}`);
  }
};
const _hoisted_1$g = { class: "mvi-tabs" };
const _hoisted_2$g = ["onClick", "disabled"];
const _hoisted_3$e = ["innerHTML"];
const _hoisted_4$b = {
  class: "mvi-tabs-content",
  ref: "content"
};
function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("div", _hoisted_1$g, [
    createElementVNode("div", {
      ref: "headers",
      class: normalizeClass(["mvi-tabs-header", $props.type == "card" ? "card" : "", $props.type == "default" && $props.border ? "border" : ""]),
      style: normalizeStyle($options.headersStyle)
    }, [
      $props.type == "default" ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "mvi-tabs-slider",
        style: normalizeStyle($options.sliderStyle)
      }, null, 4)) : createCommentVNode("", true),
      (openBlock(true), createElementBlock(Fragment, null, renderList($data.children, (item, index) => {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass($options.headerClass(item, index)),
          onClick: ($event) => $options.clickHeader(item, index),
          style: normalizeStyle($options.headerStyle(item, index)),
          disabled: item.disabled || null
        }, [
          item.placement == "left" && ($options.parseIcon(item.icon).type || $options.parseIcon(item.icon).url) ? (openBlock(), createBlock(_component_Icon, {
            key: 0,
            class: normalizeClass(["mvi-tab-icon", item.title ? "left" : ""]),
            type: $options.parseIcon(item.icon).type,
            url: $options.parseIcon(item.icon).url,
            spin: $options.parseIcon(item.icon).spin,
            size: $options.parseIcon(item.icon).size,
            color: $options.parseIcon(item.icon).color
          }, null, 8, ["class", "type", "url", "spin", "size", "color"])) : createCommentVNode("", true),
          item.title ? (openBlock(), createElementBlock("span", {
            key: 1,
            class: "mvi-tab-header-text",
            innerHTML: item.title
          }, null, 8, _hoisted_3$e)) : createCommentVNode("", true),
          item.placement == "right" && ($options.parseIcon(item.icon).type || $options.parseIcon(item.icon).url) ? (openBlock(), createBlock(_component_Icon, {
            key: 2,
            class: normalizeClass(["mvi-tab-icon", item.title ? "right" : ""]),
            type: $options.parseIcon(item.icon).type,
            url: $options.parseIcon(item.icon).url,
            spin: $options.parseIcon(item.icon).spin,
            size: $options.parseIcon(item.icon).size,
            color: $options.parseIcon(item.icon).color
          }, null, 8, ["class", "type", "url", "spin", "size", "color"])) : createCommentVNode("", true)
        ], 14, _hoisted_2$g);
      }), 256))
    ], 6),
    createElementVNode("div", _hoisted_4$b, [
      renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ], 512)
  ]);
}
const Tabs = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$q], ["__scopeId", "data-v-b7e3e17c"]]);
Tabs.install = (app) => {
  app.component(Tabs.name, Tabs);
};
const tab_vue_vue_type_style_index_0_scoped_f3fc1fea_lang = "";
const _sfc_main$p = {
  name: "m-tab",
  inject: ["tabs"],
  data() {
    return {
      show: false,
      back: false,
      firstShow: false
    };
  },
  setup() {
    const uid = getCurrentInstance().uid;
    return {
      uid
    };
  },
  created() {
    this.tabs.children.push(this);
    if (this.tabs.modelValue == this.tabIndex) {
      this.show = true;
      if (!this.firstShow) {
        this.firstShow = true;
      }
    }
  },
  props: {
    title: {
      type: String,
      default: ""
    },
    icon: {
      type: [String, Object],
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    placement: {
      type: String,
      default: "left",
      validator(value) {
        return ["left", "right"].includes(value);
      }
    }
  },
  computed: {
    tabStyle() {
      let style = {};
      if (this.tabs.animation == "slide") {
        style.transition = "left " + this.tabs.timeout + "ms,opacity " + this.tabs.timeout + "ms";
        style.webkitTransition = "left " + this.tabs.timeout + "ms,opacity " + this.tabs.timeout + "ms";
      } else if (this.tabs.animation == "fade") {
        style.transition = "opacity " + this.tabs.timeout + "ms";
        style.webkitTransition = "opacity " + this.tabs.timeout + "ms";
      }
      return style;
    },
    tabIndex() {
      return this.tabs.children.findIndex((vm) => {
        return obj$1.common.equal(vm.uid, this.uid);
      });
    }
  },
  unmounted() {
    this.tabs.children.splice(this.tabIndex, 1);
    if (this.tabs.modelValue > 0) {
      this.tabs.$emit("update:modelValue", this.tabs.modelValue - 1);
      this.tabs.$emit("change", this.tabs.modelValue - 1);
    } else {
      this.tabs.to(0, 0);
    }
  }
};
function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    name: "mvi-tab-" + $options.tabs.animation + ($data.back ? "-back" : "")
  }, {
    default: withCtx(() => [
      $data.firstShow ? withDirectives((openBlock(), createElementBlock("div", {
        key: 0,
        class: "mvi-tab",
        style: normalizeStyle($options.tabStyle)
      }, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 4)), [
        [vShow, $data.show]
      ]) : createCommentVNode("", true)
    ]),
    _: 3
  }, 8, ["name"]);
}
const Tab = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$p], ["__scopeId", "data-v-f3fc1fea"]]);
Tab.install = (app) => {
  app.component(Tab.name, Tab);
};
const triangle_vue_vue_type_style_index_0_scoped_aa2239dc_lang = "";
const _sfc_main$o = {
  name: "m-triangle",
  props: {
    background: {
      type: String,
      default: null
    },
    borderColor: {
      type: String,
      default: null
    },
    size: {
      type: String,
      default: "0.14rem"
    },
    placement: {
      type: String,
      default: "top",
      validator(value) {
        return ["top", "left", "right", "bottom"].includes(value);
      }
    }
  },
  computed: {
    triangleStyle() {
      let style = {};
      style.borderWidth = this.size;
      if (this.placement == "top") {
        style.borderBottomColor = this.borderColor || "";
      } else if (this.placement == "bottom") {
        style.borderTopColor = this.borderColor || "";
      } else if (this.placement == "left") {
        style.borderRightColor = this.borderColor || "";
      } else if (this.placement == "right") {
        style.borderLeftColor = this.borderColor || "";
      }
      return style;
    },
    triangleElStyle() {
      let style = {};
      style.borderWidth = `calc(${this.size} - 1px)`;
      if (this.placement == "top") {
        style.borderBottomColor = this.background || "";
        style.marginLeft = `-${this.size}`;
      } else if (this.placement == "bottom") {
        style.borderTopColor = this.background || "";
        style.marginLeft = `-${this.size}`;
      } else if (this.placement == "left") {
        style.borderRightColor = this.background || "";
        style.marginTop = `-${this.size}`;
      } else if (this.placement == "right") {
        style.borderLeftColor = this.background || "";
        style.marginTop = `-${this.size}`;
      }
      return style;
    }
  }
};
const _hoisted_1$f = ["data-placement"];
const _hoisted_2$f = ["data-placement"];
function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "mvi-triangle",
    style: normalizeStyle($options.triangleStyle),
    "data-placement": $props.placement
  }, [
    createElementVNode("div", {
      class: "mvi-triangle-el",
      style: normalizeStyle($options.triangleElStyle),
      "data-placement": $props.placement
    }, null, 12, _hoisted_2$f)
  ], 12, _hoisted_1$f);
}
const Triangle = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$o], ["__scopeId", "data-v-aa2239dc"]]);
Triangle.install = (app) => {
  app.component(Triangle.name, Triangle);
};
const layer_vue_vue_type_style_index_0_scoped_68b82631_lang = "";
const _sfc_main$n = {
  name: "m-layer",
  data() {
    return {
      layerShow: false,
      firstShow: false,
      realPlacement: "bottom"
    };
  },
  emits: ["update:modelValue", "show", "showing", "shown", "hide", "hidding", "hidden"],
  props: {
    modelValue: {
      type: Boolean,
      default: false
    },
    target: {
      type: String,
      default: null
    },
    root: {
      type: String,
      default: null
    },
    placement: {
      type: String,
      default: "bottom",
      validator(value) {
        return ["top", "left", "right", "bottom", "top-start", "top-end", "left-start", "left-end", "right-start", "right-end", "bottom-start", "bottom-end"].includes(value);
      }
    },
    offset: {
      type: String,
      default: "0.2rem"
    },
    zIndex: {
      type: Number,
      default: null
    },
    fixed: {
      type: Boolean,
      default: false
    },
    width: {
      type: String,
      default: null
    },
    timeout: {
      type: Number,
      default: 200
    },
    closable: {
      type: Boolean,
      default: false
    },
    showTriangle: {
      type: Boolean,
      default: false
    },
    animation: {
      type: String,
      default: null
    },
    shadow: {
      type: Boolean,
      default: true
    },
    border: {
      type: Boolean,
      default: false
    },
    borderColor: {
      type: String,
      default: "#eee"
    },
    background: {
      type: String,
      default: "#fff"
    },
    fixedAuto: {
      type: Boolean,
      default: false
    }
  },
  components: {
    Triangle
  },
  watch: {
    placement(newValue) {
      if (this.layerShow && this.firstShow) {
        this.autoAdjust();
        this.reset();
        this.$nextTick(() => {
          this.resetTriangle();
        });
      }
    },
    modelValue(newValue) {
      if (newValue) {
        if (!this.firstShow) {
          this.firstShow = true;
        }
      }
      this.layerShow = newValue;
    }
  },
  computed: {
    trianglePlacement() {
      if (this.realPlacement == "bottom-start" || this.realPlacement == "bottom" || this.realPlacement == "bottom-end") {
        return "top";
      } else if (this.realPlacement == "top-start" || this.realPlacement == "top" || this.realPlacement == "top-end") {
        return "bottom";
      } else if (this.realPlacement == "left-start" || this.realPlacement == "left" || this.realPlacement == "left-end") {
        return "right";
      } else if (this.realPlacement == "right-start" || this.realPlacement == "right" || this.realPlacement == "right-end") {
        return "left";
      }
    },
    wrapperCls() {
      let cls = ["mvi-layer-wrapper"];
      if (this.shadow) {
        cls.push("shadow");
      }
      if (this.border) {
        cls.push("border");
      }
      return cls;
    },
    wrapperStyle() {
      let style = {};
      if (this.border && this.borderColor) {
        style.borderColor = this.borderColor;
      }
      if (this.background) {
        style.background = this.background;
      }
      if (this.width) {
        style.width = this.width;
      }
      return style;
    },
    layerStyle() {
      let style = {};
      if (obj$1.number.isNumber(this.zIndex)) {
        style.zIndex = this.zIndex;
      }
      if (this.timeout) {
        style.transition = "transform " + this.timeout + "ms,opacity " + this.timeout + "ms";
        style.webkitTransition = "transform " + this.timeout + "ms,opacity " + this.timeout + "ms";
      }
      if (!this.showTriangle) {
        style.padding = 0;
        if (this.realPlacement == "bottom-start" || this.realPlacement == "bottom" || this.realPlacement == "bottom-end") {
          style.paddingTop = this.offset;
        } else if (this.realPlacement == "top-start" || this.realPlacement == "top" || this.realPlacement == "top-end") {
          style.paddingBottom = this.offset;
        } else if (this.realPlacement == "left-start" || this.realPlacement == "left" || this.realPlacement == "left-end") {
          style.paddingRight = this.offset;
        } else if (this.realPlacement == "right-start" || this.realPlacement == "right" || this.realPlacement == "right-end") {
          style.paddingLeft = this.offset;
        }
      }
      return style;
    }
  },
  setup() {
    const instance = getCurrentInstance();
    return {
      uid: instance.uid
    };
  },
  mounted() {
    if (this.modelValue) {
      if (!this.firstShow) {
        this.firstShow = true;
      }
      this.layerShow = this.modelValue;
    }
    obj$1.event.on(window, `resize.layer_${this.uid}`, this.resizeSet);
    obj$1.event.on(window, `click.layer_${this.uid}`, this.hideLayer);
  },
  methods: {
    resizeSet() {
      if (this.layerShow && this.firstShow) {
        this.autoAdjust();
        this.reset();
        this.$nextTick(() => {
          this.resetTriangle();
        });
      }
    },
    autoAdjust() {
      let $target = this.getTargetEl();
      let point = obj$1.element.getElementBounding($target);
      this.realPlacement = this.placement;
      if (this.placement == "bottom") {
        if (point.bottom < this.$el.offsetHeight) {
          if (point.top > this.$el.offsetHeight) {
            this.realPlacement = "top";
            if (point.left + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "top-start";
            }
            if (point.right + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "top-end";
            }
          } else if (point.left > this.$el.offsetWidth) {
            this.realPlacement = "left";
            if (point.top + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "left-start";
            }
            if (point.bottom + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "left-end";
            }
          } else if (point.right > this.$el.offsetWidth) {
            this.realPlacement = "right";
            if (point.top + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "right-start";
            }
            if (point.bottom + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "right-end";
            }
          }
        } else {
          if (point.left + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
            this.realPlacement = "bottom-start";
          }
          if (point.right + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
            this.realPlacement = "bottom-end";
          }
        }
      } else if (this.placement == "bottom-start") {
        if (point.bottom < this.$el.offsetHeight) {
          if (point.top > this.$el.offsetHeight) {
            this.realPlacement = "top-start";
            if (point.right + $target.offsetWidth < this.$el.offsetWidth) {
              this.realPlacement = "top";
            }
            if (point.right + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "top-end";
            }
          } else if (point.left > this.$el.offsetWidth) {
            this.realPlacement = "left";
            if (point.top + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "left-start";
            }
            if (point.bottom + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "left-end";
            }
          } else if (point.right > this.$el.offsetWidth) {
            this.realPlacement = "right";
            if (point.top + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "right-start";
            }
            if (point.bottom + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "right-end";
            }
          }
        } else {
          if (point.right + $target.offsetWidth < this.$el.offsetWidth) {
            this.realPlacement = "bottom";
          }
          if (point.right + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
            this.realPlacement = "bottom-end";
          }
        }
      } else if (this.placement == "bottom-end") {
        if (point.bottom < this.$el.offsetHeight) {
          if (point.top > this.$el.offsetHeight) {
            this.realPlacement = "top-end";
            if (point.left + $target.offsetWidth < this.$el.offsetWidth) {
              this.realPlacement = "top";
            }
            if (point.left + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "top-start";
            }
          } else if (point.left > this.$el.offsetWidth) {
            this.realPlacement = "left";
            if (point.top + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "left-start";
            }
            if (point.bottom + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "left-end";
            }
          } else if (point.right > this.$el.offsetWidth) {
            this.realPlacement = "right";
            if (point.top + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "right-start";
            }
            if (point.bottom + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "right-end";
            }
          }
        } else {
          if (point.left + $target.offsetWidth < this.$el.offsetWidth) {
            this.realPlacement = "bottom";
          }
          if (point.left + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
            this.realPlacement = "bottom-start";
          }
        }
      } else if (this.placement == "top") {
        if (point.top < this.$el.offsetHeight) {
          if (point.bottom > this.$el.offsetHeight) {
            this.realPlacement = "bottom";
            if (point.left + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "bottom-start";
            }
            if (point.right + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "bottom-end";
            }
          } else if (point.left > this.$el.offsetWidth) {
            this.realPlacement = "left";
            if (point.top + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "left-start";
            }
            if (point.bottom + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "left-end";
            }
          } else if (point.right > this.$el.offsetWidth) {
            this.realPlacement = "right";
            if (point.top + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "right-start";
            }
            if (point.bottom + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "right-end";
            }
          }
        } else {
          if (point.left + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
            this.realPlacement = "top-start";
          }
          if (point.right + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
            this.realPlacement = "top-end";
          }
        }
      } else if (this.placement == "top-start") {
        if (point.top < this.$el.offsetHeight) {
          if (point.bottom > this.$el.offsetHeight) {
            this.realPlacement = "bottom-start";
            if (point.right + $target.offsetWidth < this.$el.offsetWidth) {
              this.realPlacement = "bottom";
            }
            if (point.right + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "bottom-end";
            }
          } else if (point.left > this.$el.offsetWidth) {
            this.realPlacement = "left";
            if (point.top + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "left-start";
            }
            if (point.bottom + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "left-end";
            }
          } else if (point.right > this.$el.offsetWidth) {
            this.realPlacement = "right";
            if (point.top + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "right-start";
            }
            if (point.bottom + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "right-end";
            }
          }
        } else {
          if (point.right + $target.offsetWidth < this.$el.offsetWidth) {
            this.realPlacement = "top";
          }
          if (point.right + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
            this.realPlacement = "top-end";
          }
        }
      } else if (this.placement == "top-end") {
        if (point.top < this.$el.offsetHeight) {
          if (point.bottom > this.$el.offsetHeight) {
            this.realPlacement = "bottom-end";
            if (point.left + $target.offsetWidth < this.$el.offsetWidth) {
              this.realPlacement = "bottom";
            }
            if (point.left + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "bottom-start";
            }
          } else if (point.left > this.$el.offsetWidth) {
            this.realPlacement = "left";
            if (point.top + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "left-start";
            }
            if (point.bottom + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "left-end";
            }
          } else if (point.right > this.$el.offsetWidth) {
            this.realPlacement = "right";
            if (point.top + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "right-start";
            }
            if (point.bottom + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "right-end";
            }
          }
        } else {
          if (point.left + $target.offsetWidth < this.$el.offsetWidth) {
            this.realPlacement = "top";
          }
          if (point.left + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
            this.realPlacement = "top-start";
          }
        }
      } else if (this.placement == "left") {
        if (point.left < this.$el.offsetWidth) {
          if (point.right > this.$el.offsetWidth) {
            this.realPlacement = "right";
            if (point.top + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "right-start";
            }
            if (point.bottom + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "right-end";
            }
          } else if (point.top > this.$el.offsetHeight) {
            this.realPlacement = "top";
            if (point.left + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "top-start";
            }
            if (point.right + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "top-end";
            }
          } else if (point.bottom > this.$el.offsetHeight) {
            this.realPlacement = "bottom";
            if (point.left + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "bottom-start";
            }
            if (point.right + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "bottom-end";
            }
          }
        } else {
          if (point.top + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
            this.realPlacement = "left-start";
          }
          if (point.bottom + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
            this.realPlacement = "left-end";
          }
        }
      } else if (this.placement == "left-start") {
        if (point.left < this.$el.offsetWidth) {
          if (point.right > this.$el.offsetWidth) {
            this.realPlacement = "right-start";
            if (point.bottom + $target.offsetHeight < this.$el.offsetHeight) {
              this.realPlacement = "right";
            }
            if (point.bottom + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "right-end";
            }
          } else if (point.top > this.$el.offsetHeight) {
            this.realPlacement = "top";
            if (point.left + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "top-start";
            }
            if (point.right + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "top-end";
            }
          } else if (point.bottom > this.$el.offsetHeight) {
            this.realPlacement = "bottom";
            if (point.left + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "bottom-start";
            }
            if (point.right + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "bottom-end";
            }
          }
        } else {
          if (point.bottom + $target.offsetHeight < this.$el.offsetHeight) {
            this.realPlacement = "left";
          }
          if (point.bottom + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
            this.realPlacement = "left-end";
          }
        }
      } else if (this.placement == "left-end") {
        if (point.left < this.$el.offsetWidth) {
          if (point.right > this.$el.offsetWidth) {
            this.realPlacement = "right-end";
            if (point.top + $target.offsetHeight < this.$el.offsetHeight) {
              this.realPlacement = "right";
            }
            if (point.top + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "right-start";
            }
          } else if (point.top > this.$el.offsetHeight) {
            this.realPlacement = "top";
            if (point.left + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "top-start";
            }
            if (point.right + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "top-end";
            }
          } else if (point.bottom > this.$el.offsetHeight) {
            this.realPlacement = "bottom";
            if (point.left + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "bottom-start";
            }
            if (point.right + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "bottom-end";
            }
          }
        } else {
          if (point.top + $target.offsetHeight < this.$el.offsetHeight) {
            this.realPlacement = "left";
          }
          if (point.top + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
            this.realPlacement = "left-start";
          }
        }
      } else if (this.placement == "right") {
        if (point.right < this.$el.offsetWidth) {
          if (point.left > this.$el.offsetWidth) {
            this.realPlacement = "left";
            if (point.top + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "left-start";
            }
            if (point.bottom + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "left-end";
            }
          } else if (point.top > this.$el.offsetHeight) {
            this.realPlacement = "top";
            if (point.left + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "top-start";
            }
            if (point.right + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "top-end";
            }
          } else if (point.bottom > this.$el.offsetHeight) {
            this.realPlacement = "bottom";
            if (point.left + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "bottom-start";
            }
            if (point.right + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "bottom-end";
            }
          }
        } else {
          if (point.top + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
            this.realPlacement = "right-start";
          }
          if (point.bottom + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
            this.realPlacement = "right-end";
          }
        }
      } else if (this.placement == "right-start") {
        if (point.right < this.$el.offsetWidth) {
          if (point.left > this.$el.offsetWidth) {
            this.realPlacement = "left-start";
            if (point.bottom + $target.offsetHeight < this.$el.offsetHeight) {
              this.realPlacement = "left";
            }
            if (point.bottom + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "left-end";
            }
          } else if (point.top > this.$el.offsetHeight) {
            this.realPlacement = "top";
            if (point.left + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "top-start";
            }
            if (point.right + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "top-end";
            }
          } else if (point.bottom > this.$el.offsetHeight) {
            this.realPlacement = "bottom";
            if (point.left + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "bottom-start";
            }
            if (point.right + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "bottom-end";
            }
          }
        } else {
          if (point.bottom + $target.offsetHeight < this.$el.offsetHeight) {
            this.realPlacement = "right";
          }
          if (point.bottom + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
            this.realPlacement = "right-end";
          }
        }
      } else if (this.placement == "right-end") {
        if (point.right < this.$el.offsetWidth) {
          if (point.left > this.$el.offsetWidth) {
            this.realPlacement = "left-end";
            if (point.top + $target.offsetHeight < this.$el.offsetHeight) {
              this.realPlacement = "left";
            }
            if (point.top + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
              this.realPlacement = "left-start";
            }
          } else if (point.top > this.$el.offsetHeight) {
            this.realPlacement = "top";
            if (point.left + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "top-start";
            }
            if (point.right + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "top-end";
            }
          } else if (point.bottom > this.$el.offsetHeight) {
            this.realPlacement = "bottom";
            if (point.left + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "bottom-start";
            }
            if (point.right + $target.offsetWidth / 2 < this.$el.offsetWidth / 2) {
              this.realPlacement = "bottom-end";
            }
          }
        } else {
          if (point.top + $target.offsetHeight < this.$el.offsetHeight) {
            this.realPlacement = "right";
          }
          if (point.top + $target.offsetHeight / 2 < this.$el.offsetHeight / 2) {
            this.realPlacement = "right-start";
          }
        }
      }
    },
    hideLayer(event2) {
      if (this.layerShow && this.firstShow && this.closable) {
        if (obj$1.element.isContains(this.$el, event2.target) || obj$1.element.isContains(this.getTargetEl(), event2.target)) {
          return;
        }
        this.$emit("update:modelValue", false);
      }
    },
    beforeEnter(el) {
      if (obj$1.data.get(el, "mvi-layer-beforeEnter-trigger")) {
        return;
      }
      obj$1.data.set(el, "mvi-layer-beforeEnter-trigger", true);
      this.$emit("show", el);
      if (typeof this.layerComponentWatch == "function") {
        this.layerComponentWatch.apply(this, ["show", el]);
      }
    },
    enter(el) {
      if (obj$1.data.get(el, "mvi-layer-enter-trigger")) {
        return;
      }
      obj$1.data.set(el, "mvi-layer-enter-trigger", true);
      this.$nextTick(() => {
        this.autoAdjust();
        this.reset();
        this.$nextTick(() => {
          this.resetTriangle();
        });
        this.$emit("showing", el);
        if (typeof this.layerComponentWatch == "function") {
          this.layerComponentWatch.apply(this, ["showing", el]);
        }
      });
    },
    afterEnter(el) {
      this.$emit("shown", el);
      if (typeof this.layerComponentWatch == "function") {
        this.layerComponentWatch.apply(this, ["shown", el]);
      }
    },
    beforeLeave(el) {
      obj$1.data.remove(el, "mvi-layer-beforeEnter-trigger");
      obj$1.data.remove(el, "mvi-layer-enter-trigger");
      this.$emit("hide", el);
      if (typeof this.layerComponentWatch == "function") {
        this.layerComponentWatch.apply(this, ["hide", el]);
      }
    },
    leave(el) {
      this.$emit("hidding", el);
      if (typeof this.layerComponentWatch == "function") {
        this.layerComponentWatch.apply(this, ["hidding", el]);
      }
    },
    afterLeave(el) {
      this.$emit("hidden", el);
      if (typeof this.layerComponentWatch == "function") {
        this.layerComponentWatch.apply(this, ["hidden", el]);
      }
    },
    reset() {
      if (!obj$1.element.isElement(this.$el)) {
        return;
      }
      if (this.showTriangle) {
        this.$el.style.padding = 0;
        if (this.realPlacement == "bottom-start" || this.realPlacement == "bottom" || this.realPlacement == "bottom-end") {
          this.$el.style.paddingTop = `calc(${this.offset} + ${this.$refs.triangle.$el.offsetHeight}px)`;
        } else if (this.realPlacement == "top-start" || this.realPlacement == "top" || this.realPlacement == "top-end") {
          this.$el.style.paddingBottom = `calc(${this.offset} + ${this.$refs.triangle.$el.offsetHeight}px)`;
        } else if (this.realPlacement == "left-start" || this.realPlacement == "left" || this.realPlacement == "left-end") {
          this.$el.style.paddingRight = `calc(${this.offset} + ${this.$refs.triangle.$el.offsetWidth}px)`;
        } else if (this.realPlacement == "right-start" || this.realPlacement == "right" || this.realPlacement == "right-end") {
          this.$el.style.paddingLeft = `calc(${this.offset} + ${this.$refs.triangle.$el.offsetWidth}px)`;
        }
      }
      let $target = this.getTargetEl();
      let $root = this.getRootEl();
      let pt = obj$1.element.getElementPoint($target, $root);
      if (this.fixed) {
        if (this.fixedAuto) {
          let flag = true;
          let element2 = $target.offsetParent;
          while (flag && element2) {
            if (obj$1.element.getCssStyle(element2, "transform") != "none") {
              flag = false;
            } else {
              element2 = element2.offsetParent;
            }
          }
          pt = obj$1.element.getElementPoint($target, element2);
        } else {
          pt = obj$1.element.getElementBounding($target);
        }
      }
      if (this.realPlacement == "bottom" || this.realPlacement == "bottom-start" || this.realPlacement == "bottom-end") {
        this.$el.style.top = pt.top + $target.offsetHeight + "px";
        this.$el.style.bottom = "auto";
        if (this.realPlacement == "bottom") {
          this.$el.style.left = pt.left + $target.offsetWidth / 2 - this.$el.offsetWidth / 2 + "px";
        } else if (this.realPlacement == "bottom-start") {
          this.$el.style.left = pt.left + "px";
        } else if (this.realPlacement == "bottom-end") {
          this.$el.style.left = $target.offsetWidth + pt.left - this.$el.offsetWidth + "px";
        }
        this.$el.style.right = "auto";
      } else if (this.realPlacement == "top" || this.realPlacement == "top-start" || this.realPlacement == "top-end") {
        this.$el.style.bottom = (this.fixed ? pt.bottom + $target.offsetHeight : $root.clientHeight - pt.top) + "px";
        this.$el.style.top = "auto";
        if (this.realPlacement == "top") {
          this.$el.style.left = pt.left + $target.offsetWidth / 2 - this.$el.offsetWidth / 2 + "px";
        } else if (this.realPlacement == "top-start") {
          this.$el.style.left = pt.left + "px";
        } else if (this.realPlacement == "top-end") {
          this.$el.style.left = $target.offsetWidth + pt.left - this.$el.offsetWidth + "px";
        }
        this.$el.style.right = "auto";
      } else if (this.realPlacement == "left" || this.realPlacement == "left-start" || this.realPlacement == "left-end") {
        this.$el.style.right = (this.fixed ? pt.right + $target.offsetWidth : $root.clientWidth - pt.left) + "px";
        this.$el.style.left = "auto";
        if (this.realPlacement == "left") {
          this.$el.style.top = pt.top + $target.offsetHeight / 2 - this.$el.offsetHeight / 2 + "px";
        } else if (this.realPlacement == "left-start") {
          this.$el.style.top = pt.top + "px";
        } else if (this.realPlacement == "left-end") {
          this.$el.style.top = $target.offsetHeight + pt.top - this.$el.offsetHeight + "px";
        }
        this.$el.style.bottom = "auto";
      } else if (this.realPlacement == "right" || this.realPlacement == "right-start" || this.realPlacement == "right-end") {
        this.$el.style.left = pt.left + $target.offsetWidth + "px";
        this.$el.style.right = "auto";
        if (this.realPlacement == "right") {
          this.$el.style.top = pt.top + $target.offsetHeight / 2 - this.$el.offsetHeight / 2 + "px";
        } else if (this.realPlacement == "right-start") {
          this.$el.style.top = pt.top + "px";
        } else if (this.realPlacement == "right-end") {
          this.$el.style.top = $target.offsetHeight + pt.top - this.$el.offsetHeight + "px";
        }
        this.$el.style.bottom = "auto";
      }
    },
    resetTriangle() {
      if (!this.showTriangle || this.$refs.triangle && !this.$refs.triangle.$el) {
        return;
      }
      const targetWidth = this.getTargetEl().offsetWidth;
      const elWidth = this.$el.offsetWidth;
      const targetHeight = this.getTargetEl().offsetHeight;
      const elHeight = this.$el.offsetHeight;
      const triWidth = this.$refs.triangle.$el.offsetWidth;
      const triHeight = this.$refs.triangle.$el.offsetHeight;
      if (this.realPlacement == "bottom-start") {
        this.$refs.triangle.$el.style.top = "auto";
        this.$refs.triangle.$el.style.right = "auto";
        this.$refs.triangle.$el.style.bottom = "100%";
        this.$refs.triangle.$el.style.left = (targetWidth > elWidth ? elWidth : targetWidth) / 2 - triWidth / 2 + "px";
      } else if (this.realPlacement == "bottom") {
        this.$refs.triangle.$el.style.top = "auto";
        this.$refs.triangle.$el.style.right = "auto";
        this.$refs.triangle.$el.style.bottom = "100%";
        this.$refs.triangle.$el.style.left = elWidth / 2 - triWidth / 2 + "px";
      } else if (this.realPlacement == "bottom-end") {
        this.$refs.triangle.$el.style.top = "auto";
        this.$refs.triangle.$el.style.left = "auto";
        this.$refs.triangle.$el.style.bottom = "100%";
        this.$refs.triangle.$el.style.right = (targetWidth > elWidth ? elWidth : targetWidth) / 2 - triWidth / 2 + "px";
      } else if (this.realPlacement == "top-start") {
        this.$refs.triangle.$el.style.top = "100%";
        this.$refs.triangle.$el.style.right = "auto";
        this.$refs.triangle.$el.style.bottom = "auto";
        this.$refs.triangle.$el.style.left = (targetWidth > elWidth ? elWidth : targetWidth) / 2 - triWidth / 2 + "px";
      } else if (this.realPlacement == "top") {
        this.$refs.triangle.$el.style.top = "100%";
        this.$refs.triangle.$el.style.right = "auto";
        this.$refs.triangle.$el.style.bottom = "auto";
        this.$refs.triangle.$el.style.left = elWidth / 2 - triWidth / 2 + "px";
      } else if (this.realPlacement == "top-end") {
        this.$refs.triangle.$el.style.top = "100%";
        this.$refs.triangle.$el.style.left = "auto";
        this.$refs.triangle.$el.style.bottom = "auto";
        this.$refs.triangle.$el.style.right = (targetWidth > elWidth ? elWidth : targetWidth) / 2 - triWidth / 2 + "px";
      } else if (this.realPlacement == "left-start") {
        this.$refs.triangle.$el.style.left = "100%";
        this.$refs.triangle.$el.style.right = "auto";
        this.$refs.triangle.$el.style.top = (targetHeight > elHeight ? elHeight : targetHeight) / 2 - triHeight / 2 + "px";
        this.$refs.triangle.$el.style.bottom = "auto";
      } else if (this.realPlacement == "left") {
        this.$refs.triangle.$el.style.left = "100%";
        this.$refs.triangle.$el.style.right = "auto";
        this.$refs.triangle.$el.style.top = elHeight / 2 - triHeight / 2 + "px";
        this.$refs.triangle.$el.style.bottom = "auto";
      } else if (this.realPlacement == "left-end") {
        this.$refs.triangle.$el.style.left = "100%";
        this.$refs.triangle.$el.style.right = "auto";
        this.$refs.triangle.$el.style.bottom = (targetHeight > elHeight ? elHeight : targetHeight) / 2 - triHeight / 2 + "px";
        this.$refs.triangle.$el.style.top = "auto";
      } else if (this.realPlacement == "right-start") {
        this.$refs.triangle.$el.style.right = "100%";
        this.$refs.triangle.$el.style.left = "auto";
        this.$refs.triangle.$el.style.top = (targetHeight > elHeight ? elHeight : targetHeight) / 2 - triHeight / 2 + "px";
        this.$refs.triangle.$el.style.bottom = "auto";
      } else if (this.realPlacement == "right") {
        this.$refs.triangle.$el.style.right = "100%";
        this.$refs.triangle.$el.style.left = "auto";
        this.$refs.triangle.$el.style.top = elHeight / 2 - triHeight / 2 + "px";
        this.$refs.triangle.$el.style.bottom = "auto";
      } else if (this.realPlacement == "right-end") {
        this.$refs.triangle.$el.style.right = "100%";
        this.$refs.triangle.$el.style.left = "auto";
        this.$refs.triangle.$el.style.bottom = (targetHeight > elHeight ? elHeight : targetHeight) / 2 - triHeight / 2 + "px";
        this.$refs.triangle.$el.style.top = "auto";
      }
    },
    getTargetEl() {
      if (this.target) {
        return document.body.querySelector(this.target) || document.body;
      } else {
        return document.body;
      }
    },
    getRootEl() {
      if (this.fixed) {
        return document.body;
      }
      if (this.root) {
        return document.body.querySelector(this.root) || document.body;
      } else {
        return document.body;
      }
    }
  },
  beforeUnmount() {
    obj$1.event.off(window, `resize.layer_${this.uid} click.layer_${this.uid}`);
  }
};
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Triangle = resolveComponent("Triangle");
  return openBlock(), createBlock(Transition, {
    name: $props.animation || "mvi-layer",
    onBeforeEnter: $options.beforeEnter,
    onEnter: $options.enter,
    onAfterEnter: $options.afterEnter,
    onLeave: $options.leave,
    onBeforeLeave: $options.beforeLeave,
    onAfterLeave: $options.afterLeave
  }, {
    default: withCtx(() => [
      $data.firstShow ? withDirectives((openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["mvi-layer", $props.fixed ? "fixed" : ""]),
        style: normalizeStyle($options.layerStyle)
      }, [
        createElementVNode("div", {
          class: normalizeClass($options.wrapperCls),
          style: normalizeStyle($options.wrapperStyle)
        }, [
          $props.showTriangle ? (openBlock(), createBlock(_component_Triangle, {
            key: 0,
            ref: "triangle",
            class: "mvi-layer-triangle",
            placement: $options.trianglePlacement,
            background: $props.background,
            "border-color": $props.border && $props.borderColor ? $props.borderColor : $props.background,
            size: "0.14rem"
          }, null, 8, ["placement", "background", "border-color"])) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ], 6)
      ], 6)), [
        [vShow, $data.layerShow]
      ]) : createCommentVNode("", true)
    ]),
    _: 3
  }, 8, ["name", "onBeforeEnter", "onEnter", "onAfterEnter", "onLeave", "onBeforeLeave", "onAfterLeave"]);
}
const Layer = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$n], ["__scopeId", "data-v-68b82631"]]);
Layer.install = (app) => {
  app.component(Layer.name, Layer);
};
const tooltip_vue_vue_type_style_index_0_scoped_acd39211_lang = "";
const _sfc_main$m = {
  name: "m-tooltip",
  data() {
    return {
      show: false
    };
  },
  props: {
    title: {
      type: String,
      default: ""
    },
    placement: {
      type: String,
      default: "bottom"
    },
    disabled: {
      type: Boolean,
      default: false
    },
    timeout: {
      type: Number,
      default: 200
    },
    borderColor: {
      type: String,
      default: "#333"
    },
    color: {
      type: String,
      default: "#333"
    },
    textColor: {
      type: String,
      default: "#fff"
    },
    trigger: {
      type: String,
      default: "click",
      validator(value) {
        return ["hover", "click", "custom"].includes(value);
      }
    },
    offset: {
      type: String,
      default: "0.1rem"
    },
    zIndex: {
      type: Number,
      default: 20
    },
    fixed: {
      type: Boolean,
      default: false
    },
    fixedAuto: {
      type: Boolean,
      default: false
    },
    width: {
      type: String,
      default: null
    },
    animation: {
      type: String,
      default: null
    },
    showTriangle: {
      type: Boolean,
      default: true
    },
    block: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    contentStyle() {
      let style = {};
      if (this.textColor) {
        style.color = this.textColor;
      }
      if (this.width) {
        style.whiteSpace = "normal";
      }
      return style;
    }
  },
  components: {
    Layer
  },
  setup() {
    const instance = getCurrentInstance();
    return {
      uid: instance.uid
    };
  },
  methods: {
    hoverShowTooltip() {
      if (this.trigger == "hover") {
        this.showTooltip();
      }
    },
    hoverHideToolTip() {
      if (this.trigger == "hover") {
        this.hideTooltip();
      }
    },
    clickShowTooltip() {
      if (this.trigger === "click") {
        if (this.show) {
          this.hideTooltip();
        } else {
          this.showTooltip();
        }
      }
    },
    showTooltip() {
      if (this.disabled) {
        return;
      }
      this.show = true;
    },
    hideTooltip() {
      if (this.disabled) {
        return;
      }
      this.show = false;
    }
  }
};
const _hoisted_1$e = ["data-id"];
const _hoisted_2$e = ["data-id"];
const _hoisted_3$d = ["textContent"];
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Layer = resolveComponent("Layer");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["mvi-tooltip", $props.block ? "block" : ""]),
    "data-id": "mvi-tooltip-" + $setup.uid
  }, [
    createElementVNode("div", {
      onClick: _cache[0] || (_cache[0] = (...args) => $options.clickShowTooltip && $options.clickShowTooltip(...args)),
      onMouseenter: _cache[1] || (_cache[1] = (...args) => $options.hoverShowTooltip && $options.hoverShowTooltip(...args)),
      onMouseleave: _cache[2] || (_cache[2] = (...args) => $options.hoverHideToolTip && $options.hoverHideToolTip(...args)),
      class: "mvi-tooltip-toggle",
      ref: "toggle",
      "data-id": "mvi-tooltip-target-" + $setup.uid
    }, [
      renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ], 40, _hoisted_2$e),
    createVNode(_component_Layer, {
      modelValue: $data.show,
      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $data.show = $event),
      offset: $props.offset,
      background: $props.color,
      border: "",
      "border-color": $props.borderColor,
      closable: "",
      "show-triangle": $props.showTriangle,
      "z-index": $props.zIndex,
      target: `[data-id='mvi-tooltip-target-${$setup.uid}']`,
      root: `[data-id='mvi-tooltip-${$setup.uid}']`,
      placement: $props.placement,
      fixed: $props.fixed,
      "fixed-auto": $props.fixedAuto,
      width: $props.width,
      timeout: $props.timeout,
      animation: $props.animation || "mvi-tooltip",
      shadow: false
    }, {
      default: withCtx(() => [
        createElementVNode("div", {
          class: "mvi-tooltip-content",
          ref: "content",
          style: normalizeStyle($options.contentStyle)
        }, [
          _ctx.$slots.title ? renderSlot(_ctx.$slots, "title", { key: 0 }, void 0, true) : (openBlock(), createElementBlock("span", {
            key: 1,
            textContent: toDisplayString($props.title)
          }, null, 8, _hoisted_3$d))
        ], 4)
      ]),
      _: 3
    }, 8, ["modelValue", "offset", "background", "border-color", "show-triangle", "z-index", "target", "root", "placement", "fixed", "fixed-auto", "width", "timeout", "animation"])
  ], 10, _hoisted_1$e);
}
const Tooltip = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$m], ["__scopeId", "data-v-acd39211"]]);
Tooltip.install = (app) => {
  app.component(Tooltip.name, Tooltip);
};
const table_vue_vue_type_style_index_0_scoped_e26e1b7a_lang = "";
const _sfc_main$l = {
  name: "m-table",
  emits: ["check", "sort-cancel", "sort-asc", "sort-desc"],
  props: {
    data: {
      type: Array,
      default: function() {
        return [];
      }
    },
    columns: {
      type: Array,
      default: function() {
        return [];
      }
    },
    border: {
      type: Boolean,
      default: false
    },
    columnBorder: {
      type: Boolean,
      default: false
    },
    stripe: {
      type: Boolean,
      default: false
    },
    height: {
      type: String,
      default: null
    },
    noDataMsg: {
      type: String,
      default: "\u6682\u65E0\u6570\u636E"
    },
    loading: {
      type: Boolean,
      default: false
    },
    loadText: {
      type: String,
      default: "\u6B63\u5728\u52A0\u8F7D\u4E2D..."
    },
    center: {
      type: Boolean,
      default: false
    },
    cellClass: {
      type: Function
    },
    activeColor: {
      type: String,
      default: null
    }
  },
  data() {
    return {
      columnAlignKey: 0,
      rowData: [],
      columnData: [],
      scrollWidth: 0,
      sortBy: "",
      sortOrder: "",
      checkedRows: [],
      selectAll: false,
      headerColumnRefs: []
    };
  },
  computed: {
    wrapWidth() {
      this.columnAlignKey;
      if (this.headerColumnRefs.length) {
        let width = this.headerColumnRefs.reduce((total, item, index) => {
          const width2 = this.columnData[index].width ? this.parseWidth(this.columnData[index].width) : obj$1.element.rem2px(2);
          return total += width2;
        }, 0);
        if (this.scrollWidth) {
          width += this.scrollWidth;
        }
        const tableWidth = obj$1.element.width(this.$el);
        return width > tableWidth ? width + "px" : tableWidth + "px";
      }
      return "";
    },
    headerColumnClass() {
      let cls = [];
      if (this.columnBorder) {
        cls.push("border");
      }
      return cls;
    },
    headerColumnStyle() {
      return (column) => {
        return {
          width: column.width ? this.parseWidth(column.width) + "px" : "auto"
        };
      };
    },
    bodyColumnClass() {
      return (row, rowIndex, column, columnIndex) => {
        let cls = [];
        if (this.columnBorder) {
          cls.push("border");
        }
        if (column.className) {
          cls.push(column.className);
        }
        if (typeof this.cellClass == "function") {
          cls.push(this.cellClass.apply(this, [row, rowIndex, column, columnIndex]) || "");
        }
        return cls;
      };
    },
    bodyColumnStyle() {
      return (column, index) => {
        this.columnAlignKey;
        return {
          width: this.headerColumnRefs[index] ? obj$1.element.getCssStyle(this.headerColumnRefs[index], "width") : ""
        };
      };
    },
    sortIconStyle() {
      return (sortOrder, column) => {
        let style = {};
        if (this.sortBy == column.prop && this.sortOrder == sortOrder) {
          style.color = this.activeColor || "";
        }
        return style;
      };
    },
    dataFormat() {
      return (row, column) => {
        if (typeof column.format == "function") {
          return column.format.apply(this, [row[column.prop], row, column]) || "";
        }
        return row[column.prop] ? row[column.prop] + "" : "";
      };
    },
    cmpSelectable() {
      return (row, rowIndex, column) => {
        if (typeof column.selectable == "function") {
          return column.selectable.apply(this, [row, rowIndex]);
        }
        return true;
      };
    },
    tooltipTitle() {
      return (row, column) => {
        const dom = obj$1.element.string2dom(`<div>${this.dataFormat(row, column)}</div>`);
        return dom.innerText;
      };
    }
  },
  components: {
    Loading,
    Icon,
    Checkbox,
    Tooltip
  },
  watch: {
    data: {
      immediate: true,
      handler: function(newVal) {
        this.rowData = this.deepClone(newVal);
        this.$nextTick(() => {
          this.scrollWidth = this.getScrollWidth();
          this.$nextTick(() => {
            this.columnAlignKey++;
          });
        });
      }
    },
    columns: {
      immediate: true,
      handler: function(newVal) {
        this.columnData = this.deepClone(newVal).filter((column) => {
          return !column.hidden;
        });
      }
    },
    height: {
      immediate: true,
      handler: function() {
        this.$nextTick(() => {
          this.scrollWidth = this.getScrollWidth();
          this.$nextTick(() => {
            this.columnAlignKey++;
          });
        });
      }
    }
  },
  setup() {
    const instance = getCurrentInstance();
    return {
      uid: instance.uid
    };
  },
  mounted() {
    this.columnAlignKey++;
    obj$1.event.on(window, `resize.table_${this.uid}`, (e) => {
      this.columnAlignKey++;
    });
  },
  methods: {
    doCheck(rowIndex, column) {
      if (this.checkedRows.length == this.rowData.filter((item, index) => {
        return this.cmpSelectable(item, index, column);
      }).length) {
        this.selectAll = true;
      } else {
        this.selectAll = false;
      }
      this.$emit("check", this.checkedRows, rowIndex);
    },
    allSelect(column) {
      if (this.selectAll) {
        this.checkedRows = [];
        for (let i = 0; i < this.rowData.length; i++) {
          if (this.cmpSelectable(this.rowData[i], i, column)) {
            this.checkedRows.push(i);
          }
        }
      } else {
        this.checkedRows = [];
      }
      this.$emit("check", this.checkedRows);
    },
    sortAsc(column) {
      if (this.sortBy == column.prop && this.sortOrder == "asc") {
        this.sortBy = "";
        this.sortOrder = "";
        if (typeof column.sortMethod == "function") {
          column.sortMethod.apply(this, [this.sortOrder, this.sortBy, this.rowData, column]);
        } else {
          this.rowData = this.deepClone(this.data);
          this.$emit("sort-cancel", this.rowData);
        }
      } else {
        this.sortBy = column.prop;
        this.sortOrder = "asc";
        if (typeof column.sortMethod == "function") {
          column.sortMethod.apply(this, [this.sortOrder, this.sortBy, this.rowData, column]);
        } else {
          this.rowData = this.rowData.sort(function(rowA, rowB) {
            if (obj$1.number.isNumber(rowA[column.prop]) && obj$1.number.isNumber(rowB[column.prop])) {
              return rowA[column.prop] - rowB[column.prop];
            }
            return rowA[column.prop].toString().localeCompare(rowB[column.prop].toString(), "zh-CN");
          });
          this.$emit("sort-asc", this.rowData);
        }
      }
    },
    sortDesc(column) {
      if (this.sortBy == column.prop && this.sortOrder == "desc") {
        this.sortBy = "";
        this.sortOrder = "";
        if (typeof column.sortMethod == "function") {
          column.sortMethod.apply(this, [this.sortOrder, this.sortBy, this.rowData, column]);
        } else {
          this.rowData = this.deepClone(this.data);
          this.$emit("sort-cancel", this.rowData);
        }
      } else {
        this.sortBy = column.prop;
        this.sortOrder = "desc";
        if (typeof column.sortMethod == "function") {
          column.sortMethod.apply(this, [this.sortOrder, this.sortBy, this.rowData, column]);
        } else {
          this.rowData = this.rowData.sort(function(rowA, rowB) {
            if (obj$1.number.isNumber(rowA[column.prop]) && obj$1.number.isNumber(rowB[column.prop])) {
              return rowB[column.prop] - rowA[column.prop];
            }
            return -rowA[column.prop].toString().localeCompare(rowB[column.prop].toString(), "zh-CN");
          });
          this.$emit("sort-desc", this.rowData);
        }
      }
    },
    getScrollWidth() {
      return this.$refs.body.offsetWidth - this.$refs.body.clientWidth;
    },
    deepClone(data2) {
      if (Array.isArray(data2)) {
        return data2.map((item) => {
          return this.deepClone(item);
        });
      }
      if (obj$1.common.isObject(data2)) {
        let cloneData = {};
        for (let key in data2) {
          cloneData[key] = this.deepClone(data2[key]);
        }
        return cloneData;
      }
      return data2;
    },
    parseWidth(val) {
      if (obj$1.number.isNumber(val)) {
        return val;
      }
      if (typeof val == "string" && val) {
        if (val.endsWith("px")) {
          return parseFloat(val);
        }
        if (val.endsWith("rem")) {
          return obj$1.element.rem2px(parseFloat(val));
        }
      }
      return 0;
    }
  },
  beforeUnmount() {
    obj$1.event.off(window, `resize.table_${this.uid}`);
  }
};
const _hoisted_1$d = { class: "mvi-table-header" };
const _hoisted_2$d = {
  cellpadding: "0",
  cellspacing: "0"
};
const _hoisted_3$c = {
  key: 0,
  class: "mvi-table-sortable"
};
const _hoisted_4$a = {
  key: 0,
  class: "mvi-table-loading"
};
const _hoisted_5$9 = {
  key: 0,
  cellpadding: "0",
  cellspacing: "0"
};
const _hoisted_6$8 = { class: "mvi-table-column" };
const _hoisted_7$7 = ["innerHTML"];
const _hoisted_8$6 = {
  key: 1,
  class: "mvi-table-nodata"
};
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Checkbox = resolveComponent("Checkbox");
  const _component_Icon = resolveComponent("Icon");
  const _component_Loading = resolveComponent("Loading");
  const _component_Tooltip = resolveComponent("Tooltip");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["mvi-table", $props.border ? "border" : ""])
  }, [
    createElementVNode("div", {
      class: "mvi-table-wrap",
      style: normalizeStyle({ width: $options.wrapWidth })
    }, [
      createElementVNode("div", _hoisted_1$d, [
        createElementVNode("table", _hoisted_2$d, [
          createElementVNode("tr", null, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($data.columnData, (column, index) => {
              return openBlock(), createElementBlock("th", {
                ref_for: true,
                ref: (el) => $data.headerColumnRefs[index] = el,
                class: normalizeClass($options.headerColumnClass),
                style: normalizeStyle($options.headerColumnStyle(column))
              }, [
                createElementVNode("div", {
                  class: normalizeClass(["mvi-table-column", $props.center ? "center" : ""])
                }, [
                  column.type == "selection" ? (openBlock(), createBlock(_component_Checkbox, {
                    key: 0,
                    modelValue: $data.selectAll,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.selectAll = $event),
                    size: "0.24rem",
                    onChange: ($event) => $options.allSelect(column),
                    color: $props.activeColor
                  }, null, 8, ["modelValue", "onChange", "color"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createElementVNode("span", null, toDisplayString(column.label), 1),
                    column.sortable ? (openBlock(), createElementBlock("span", _hoisted_3$c, [
                      createVNode(_component_Icon, {
                        type: "caret-up",
                        class: normalizeClass($data.sortBy == column.prop && $data.sortOrder == "asc" ? "active" : ""),
                        onClick: ($event) => $options.sortAsc(column),
                        style: normalizeStyle($options.sortIconStyle("asc", column))
                      }, null, 8, ["class", "onClick", "style"]),
                      createVNode(_component_Icon, {
                        type: "caret-down",
                        class: normalizeClass($data.sortBy == column.prop && $data.sortOrder == "desc" ? "active" : ""),
                        onClick: ($event) => $options.sortDesc(column),
                        style: normalizeStyle($options.sortIconStyle("desc", column))
                      }, null, 8, ["class", "onClick", "style"])
                    ])) : createCommentVNode("", true)
                  ], 64))
                ], 2)
              ], 6);
            }), 256)),
            $data.scrollWidth ? (openBlock(), createElementBlock("th", {
              key: 0,
              class: "placeholder",
              style: normalizeStyle({ width: $data.scrollWidth + "px" })
            }, null, 4)) : createCommentVNode("", true)
          ])
        ])
      ]),
      createElementVNode("div", {
        ref: "body",
        class: normalizeClass(["mvi-table-body", $props.height ? "overflow" : ""]),
        style: normalizeStyle({ maxHeight: $props.height })
      }, [
        $props.loading ? (openBlock(), createElementBlock("div", _hoisted_4$a, [
          createVNode(_component_Loading, {
            color: "#bbb",
            size: "0.3rem"
          }),
          createElementVNode("span", null, toDisplayString($props.loadText), 1)
        ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          $data.rowData.length ? (openBlock(), createElementBlock("table", _hoisted_5$9, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($data.rowData, (row, rowIndex) => {
              return openBlock(), createElementBlock("tr", {
                class: normalizeClass($props.stripe ? "stripe" : "")
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($data.columnData, (column, columnIndex) => {
                  return openBlock(), createElementBlock("td", {
                    class: normalizeClass($options.bodyColumnClass(row, rowIndex, column, columnIndex)),
                    style: normalizeStyle($options.bodyColumnStyle(column, columnIndex))
                  }, [
                    createElementVNode("div", _hoisted_6$8, [
                      column.type == "selection" ? (openBlock(), createElementBlock("div", {
                        key: 0,
                        class: normalizeClass(["mvi-table-column-item", $props.center ? "center" : ""])
                      }, [
                        createVNode(_component_Checkbox, {
                          modelValue: $data.checkedRows,
                          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.checkedRows = $event),
                          value: rowIndex,
                          size: "0.24rem",
                          onChange: ($event) => $options.doCheck(rowIndex, column),
                          color: $props.activeColor,
                          disabled: !$options.cmpSelectable(row, rowIndex, column)
                        }, null, 8, ["modelValue", "value", "onChange", "color", "disabled"])
                      ], 2)) : column.type == "custom" && _ctx.$slots.custom ? (openBlock(), createElementBlock("div", {
                        key: 1,
                        class: normalizeClass(["mvi-table-column-item", $props.center ? "center" : ""])
                      }, [
                        renderSlot(_ctx.$slots, "custom", {
                          row,
                          rowIndex,
                          column,
                          columnIndex
                        }, void 0, true)
                      ], 2)) : (openBlock(), createBlock(_component_Tooltip, {
                        key: 2,
                        class: "mvi-table-column-tooltip",
                        disabled: !column.ellipsis || !$options.tooltipTitle(row, column),
                        block: "",
                        title: $options.tooltipTitle(row, column),
                        trigger: "hover",
                        placement: $props.center ? "bottom" : "bottom-start",
                        fixed: $props.height ? true : false
                      }, {
                        default: withCtx(() => [
                          createElementVNode("div", {
                            class: normalizeClass(["mvi-table-column-item", $props.center ? "center" : ""])
                          }, [
                            createElementVNode("div", {
                              innerHTML: $options.dataFormat(row, column),
                              class: normalizeClass([column.ellipsis ? "ellipsis" : ""])
                            }, null, 10, _hoisted_7$7)
                          ], 2)
                        ]),
                        _: 2
                      }, 1032, ["disabled", "title", "placement", "fixed"]))
                    ])
                  ], 6);
                }), 256))
              ], 2);
            }), 256))
          ])) : (openBlock(), createElementBlock("div", _hoisted_8$6, toDisplayString($props.noDataMsg), 1))
        ], 64))
      ], 6)
    ], 4)
  ], 2);
}
const Table = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$l], ["__scopeId", "data-v-e26e1b7a"]]);
Table.install = (app) => {
  app.component(Table.name, Table);
};
const calendar_vue_vue_type_style_index_0_scoped_be2c7756_lang = "";
const _sfc_main$k = {
  name: "m-calendar",
  emits: ["update:modelValue", "date-click", "month-click", "year-click"],
  props: {
    modelValue: {
      type: Date,
      default: function() {
        return new Date();
      }
    },
    view: {
      type: String,
      default: "date",
      validator(value) {
        return ["year", "month", "date"].includes(value);
      }
    },
    monthText: {
      type: Array,
      default: function() {
        return ["\u4E00\u6708", "\u4E8C\u6708", "\u4E09\u6708", "\u56DB\u6708", "\u4E94\u6708", "\u516D\u6708", "\u4E03\u6708", "\u516B\u6708", "\u4E5D\u6708", "\u5341\u6708", "\u5341\u4E00\u6708", "\u5341\u4E8C\u6708"];
      },
      validator(value) {
        if (value.length != 12) {
          return false;
        }
        return value.every((item) => {
          return obj$1.number.isNumber(item) || typeof item == "string" && item;
        });
      }
    },
    weekText: {
      type: Array,
      default: function() {
        return ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"];
      },
      validator(value) {
        if (value.length != 7) {
          return false;
        }
        return value.every((item) => {
          return obj$1.number.isNumber(item) || typeof item == "string" && item;
        });
      }
    },
    startDate: {
      type: Date,
      default: function() {
        return dayjs("1970-01-01").toDate();
      }
    },
    endDate: {
      type: Date,
      default: function() {
        return dayjs("2099-01-01").toDate();
      }
    },
    nonCurrentClick: {
      type: Boolean,
      default: false
    },
    active: {
      type: Boolean,
      default: true
    },
    type: {
      type: String,
      default: "info",
      validator(value) {
        return ["info", "primary", "error", "warn", "success"].includes(value);
      }
    }
  },
  computed: {
    years() {
      let arr = [];
      const year = this.modelValue.getFullYear();
      const startYear = this.startDate.getFullYear();
      let index = Math.floor((year - startYear) / 12);
      for (let i = startYear + index * 12; i < startYear + index * 12 + 12; i++) {
        arr.push(dayjs(this.modelValue).year(i).toDate());
      }
      return arr;
    },
    months() {
      let arr = [];
      for (let i = 0; i < 12; i++) {
        arr.push(dayjs(this.modelValue).month(i).toDate());
      }
      return arr;
    },
    days() {
      let total = dayjs(this.modelValue).daysInMonth();
      let arr = [];
      for (let i = 1; i <= total; i++) {
        arr.push({
          date: dayjs(`${dayjs(this.modelValue).format("YYYY-MM")}-${i < 10 ? "0" + i : i}`).toDate(),
          nonCurrent: false
        });
      }
      const firstDate = arr[0].date;
      let firstWeek = firstDate.getDay();
      for (let i = 0; i < firstWeek; i++) {
        let prevDate = dayjs(firstDate).subtract(i + 1, "day").toDate();
        arr.unshift({
          date: prevDate,
          nonCurrent: true
        });
      }
      const lastDate = arr[arr.length - 1].date;
      let lastWeek = lastDate.getDay();
      for (let i = 0; i < 6 - lastWeek; i++) {
        let nextDate = dayjs(lastDate).add(i + 1, "day").toDate();
        arr.push({
          date: nextDate,
          nonCurrent: true
        });
      }
      return arr;
    },
    yearDisabled() {
      return (date2) => {
        return dayjs(date2).isBefore(dayjs(this.startDate), "year") || dayjs(date2).isAfter(dayjs(this.endDate), "year");
      };
    },
    monthDisabled() {
      return (date2) => {
        return dayjs(date2).isBefore(dayjs(this.startDate), "month") || dayjs(date2).isAfter(dayjs(this.endDate), "month");
      };
    },
    dateDisabled() {
      return (item) => {
        return dayjs(item.date).isBefore(dayjs(this.startDate), "date") || dayjs(item.date).isAfter(dayjs(this.endDate), "date");
      };
    },
    yearClass() {
      return (date2) => {
        let arr = ["mvi-calendar-year-item", this.type];
        if (this.yearDisabled(date2)) {
          return arr;
        }
        if (this.active) {
          arr.push("active");
        }
        if (dayjs().isSame(dayjs(date2), "year")) {
          arr.push("now");
        }
        if (dayjs(this.modelValue).isSame(dayjs(date2), "year")) {
          arr.push("current");
        }
        return arr;
      };
    },
    monthClass() {
      return (date2) => {
        let arr = ["mvi-calendar-month-item", this.type];
        if (this.monthDisabled(date2)) {
          return arr;
        }
        if (this.active) {
          arr.push("active");
        }
        if (dayjs().isSame(dayjs(date2), "month")) {
          arr.push("now");
        }
        if (dayjs(this.modelValue).isSame(dayjs(date2), "month")) {
          arr.push("current");
        }
        return arr;
      };
    },
    dateClass() {
      return (item) => {
        let arr = ["mvi-calendar-date-item", this.type];
        if (this.dateDisabled(item)) {
          return arr;
        }
        if (item.nonCurrent) {
          arr.push("none-current");
          if (this.nonCurrentClick) {
            arr.push("allowed");
            if (this.active) {
              arr.push("active");
            }
          }
        } else {
          if (this.active) {
            arr.push("active");
          }
          if (dayjs().isSame(dayjs(item.date), "date")) {
            arr.push("now");
          }
          if (dayjs(this.modelValue).isSame(dayjs(item.date), "date")) {
            arr.push("current");
          }
        }
        return arr;
      };
    }
  },
  methods: {
    yearClick(date2) {
      if (this.yearDisabled(date2)) {
        return;
      }
      this.$emit("update:modelValue", date2);
      this.$emit("year-click", date2);
    },
    monthClick(date2) {
      if (this.monthDisabled(date2)) {
        return;
      }
      this.$emit("update:modelValue", date2);
      this.$emit("month-click", date2);
    },
    dateClick(item) {
      if (this.dateDisabled(item)) {
        return;
      }
      if (item.nonCurrent && !this.nonCurrentClick) {
        return;
      }
      this.$emit("update:modelValue", item.date);
      this.$emit("date-click", item.date);
    }
  }
};
const _hoisted_1$c = { class: "mvi-calendar" };
const _hoisted_2$c = { class: "mvi-calendar-years" };
const _hoisted_3$b = { class: "mvi-calendar-year" };
const _hoisted_4$9 = ["disabled", "onClick"];
const _hoisted_5$8 = { class: "mvi-calendar-months" };
const _hoisted_6$7 = { class: "mvi-calendar-month" };
const _hoisted_7$6 = ["disabled", "onClick"];
const _hoisted_8$5 = {
  key: 2,
  class: "mvi-calendar-date"
};
const _hoisted_9$4 = { class: "mvi-calendar-date-header" };
const _hoisted_10$4 = { class: "mvi-calendar-date-header-item" };
const _hoisted_11$3 = { class: "mvi-calendar-date-body" };
const _hoisted_12$2 = { class: "mvi-calendar-date-row" };
const _hoisted_13$2 = { class: "mvi-calendar-date-column" };
const _hoisted_14$2 = ["disabled", "onClick"];
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$c, [
    $props.view == "year" ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(new Array(3), (item, index) => {
      return openBlock(), createElementBlock("div", _hoisted_2$c, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.years.slice(index * 4, index * 4 + 4), (el) => {
          return openBlock(), createElementBlock("div", _hoisted_3$b, [
            createElementVNode("div", {
              class: normalizeClass($options.yearClass(el)),
              disabled: $options.yearDisabled(el) || null,
              onClick: ($event) => $options.yearClick(el)
            }, toDisplayString(el.getFullYear()), 11, _hoisted_4$9)
          ]);
        }), 256))
      ]);
    }), 256)) : $props.view == "month" ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(new Array(3), (item, index) => {
      return openBlock(), createElementBlock("div", _hoisted_5$8, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.months.slice(index * 4, index * 4 + 4), (el) => {
          return openBlock(), createElementBlock("div", _hoisted_6$7, [
            createElementVNode("div", {
              class: normalizeClass($options.monthClass(el)),
              disabled: $options.monthDisabled(el) || null,
              onClick: ($event) => $options.monthClick(el)
            }, toDisplayString($props.monthText[el.getMonth()]), 11, _hoisted_7$6)
          ]);
        }), 256))
      ]);
    }), 256)) : $props.view == "date" ? (openBlock(), createElementBlock("div", _hoisted_8$5, [
      createElementVNode("div", _hoisted_9$4, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($props.weekText, (item) => {
          return openBlock(), createElementBlock("div", _hoisted_10$4, toDisplayString(item), 1);
        }), 256))
      ]),
      createElementVNode("div", _hoisted_11$3, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(new Array(6), (item, index) => {
          return openBlock(), createElementBlock("div", _hoisted_12$2, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($options.days.slice(index * 7, index * 7 + 7), (el, i) => {
              return openBlock(), createElementBlock("div", _hoisted_13$2, [
                createElementVNode("div", {
                  class: normalizeClass($options.dateClass(el)),
                  disabled: $options.dateDisabled(el) || null,
                  onClick: ($event) => $options.dateClick(el)
                }, toDisplayString(el.date.getDate()), 11, _hoisted_14$2)
              ]);
            }), 256))
          ]);
        }), 256))
      ])
    ])) : createCommentVNode("", true)
  ]);
}
const Calendar = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$k], ["__scopeId", "data-v-be2c7756"]]);
Calendar.install = (app) => {
  app.component(Calendar.name, Calendar);
};
const colorPicker_vue_vue_type_style_index_0_scoped_2743107c_lang = "";
const _sfc_main$j = {
  name: "m-color-picker",
  data() {
    return {
      hsv: [0, 0, 0],
      opacity: 1,
      updateByDrag: false,
      dragging: false,
      heightObj: null,
      dragObj: null
    };
  },
  emits: ["update:modelValue", "change"],
  components: {
    Slider
  },
  props: {
    modelValue: {
      type: String,
      default: "#ff0000"
    },
    showAlpha: {
      type: Boolean,
      default: true
    }
  },
  computed: {
    panelStyle() {
      const rgbValue = obj$1.color.hsv2rgb([this.hsv[0], 100, 100]);
      return {
        background: `rgb(${rgbValue[0]},${rgbValue[1]},${rgbValue[2]})`
      };
    },
    alphaTrackColor() {
      const rgbValue = obj$1.color.hsv2rgb(this.hsv);
      return `linear-gradient(to right, transparent 0%, rgb(${rgbValue[0]}, ${rgbValue[1]}, ${rgbValue[2]}) 100%)`;
    }
  },
  watch: {
    modelValue() {
      this.initHSV();
      this.setSliderPlacement();
    }
  },
  created() {
    this.initHSV();
  },
  mounted() {
    this.setPanelHeight();
    this.setPanelDrag();
    this.setSliderPlacement();
  },
  methods: {
    initHSV() {
      if (this.updateByDrag) {
        return;
      }
      if (this.modelValue && obj$1.common.matchingText(this.modelValue, "hex")) {
        const rgbValue = obj$1.color.hex2rgb(this.modelValue);
        this.hsv = obj$1.color.rgb2hsv(rgbValue);
        this.opacity = 1;
      } else {
        try {
          let first = this.modelValue.indexOf("(");
          let last = this.modelValue.lastIndexOf(")");
          let str = this.modelValue.substring(first + 1, last);
          let arry = str.split(",");
          if (arry.length < 3) {
            throw new Error("Color values are not RGB (RGBA) format and hexadecimal format");
          }
          const rgbValue = [Number(arry[0]), Number(arry[1]), Number(arry[2])];
          this.hsv = obj$1.color.rgb2hsv(rgbValue);
          this.opacity = arry.length == 4 ? Number(arry[3]) : 1;
        } catch (e) {
          throw new Error("Color values are not RGB (RGBA) format and hexadecimal format");
        }
      }
    },
    setPanelHeight() {
      if (this.heightObj) {
        return;
      }
      this.heightObj = new Prop$1(this.$refs.panel, 0.7);
      this.heightObj.init();
    },
    setPanelDrag() {
      if (this.dragObj) {
        return;
      }
      this.dragObj = new Drag$1(this.$refs.slider, {
        container: this.$refs.panel,
        mode: "on",
        draggableX: true,
        draggableY: true,
        cursor: false,
        beforeDrag: () => {
          this.updateByDrag = true;
          this.dragging = true;
        },
        drag: () => {
          const placement = obj$1.element.getElementPoint(this.$refs.slider, this.$refs.panel);
          this.hsv[1] = (placement.left + this.$refs.slider.offsetWidth / 2) / this.$refs.panel.offsetWidth * 100;
          this.hsv[2] = (1 - (placement.top + this.$refs.slider.offsetHeight / 2) / this.$refs.panel.offsetHeight) * 100;
          this.setValue();
        },
        dragged: () => {
          this.updateByDrag = false;
          this.$nextTick(() => {
            setTimeout(() => {
              this.dragging = false;
            }, 10);
          });
        }
      });
      this.dragObj.init();
    },
    setSliderPlacement() {
      this.$refs.slider.style.left = this.hsv[1] / 100 * this.$refs.panel.offsetWidth - this.$refs.slider.offsetWidth / 2 + "px";
      this.$refs.slider.style.top = (1 - this.hsv[2] / 100) * this.$refs.panel.offsetHeight - this.$refs.slider.offsetHeight / 2 + "px";
    },
    setValue() {
      const rgbValue = obj$1.color.hsv2rgb(this.hsv);
      if (this.opacity == 1) {
        const val = `rgb(${rgbValue[0]},${rgbValue[1]},${rgbValue[2]})`;
        this.$emit("update:modelValue", val);
        this.$emit("change", val);
      } else {
        const val = `rgba(${rgbValue[0]},${rgbValue[1]},${rgbValue[2]},${Number(this.opacity.toFixed(2))})`;
        this.$emit("update:modelValue", val);
        this.$emit("change", val);
      }
    },
    clickPanelSetColor(e) {
      if (this.dragging) {
        return;
      }
      this.updateByDrag = true;
      this.$refs.slider.style.left = e.offsetX - this.$refs.slider.offsetWidth / 2 + "px";
      this.$refs.slider.style.top = e.offsetY - this.$refs.slider.offsetHeight / 2 + "px";
      const placement = obj$1.element.getElementPoint(this.$refs.slider, this.$refs.panel);
      this.hsv[1] = (placement.left + this.$refs.slider.offsetWidth / 2) / this.$refs.panel.offsetWidth * 100;
      this.hsv[2] = (1 - (placement.top + this.$refs.slider.offsetHeight / 2) / this.$refs.panel.offsetHeight) * 100;
      this.setValue();
    }
  },
  beforeUnmount() {
    if (this.dragObj) {
      this.dragObj.destroy();
    }
    if (this.heightObj) {
      this.heightObj.destroy();
    }
  }
};
const _withScopeId$2 = (n) => (pushScopeId("data-v-2743107c"), n = n(), popScopeId(), n);
const _hoisted_1$b = { class: "mvi-color-picker" };
const _hoisted_2$b = {
  class: "mvi-color-picker-panel-slider",
  ref: "slider"
};
const _hoisted_3$a = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createElementVNode("div", { class: "mvi-color-picker-slider" }, null, -1));
const _hoisted_4$8 = {
  key: 0,
  class: "mvi-color-picker-alpha"
};
const _hoisted_5$7 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createElementVNode("div", { class: "mvi-color-picker-slider" }, null, -1));
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Slider = resolveComponent("Slider");
  return openBlock(), createElementBlock("div", _hoisted_1$b, [
    createElementVNode("div", {
      class: "mvi-color-picker-panel",
      ref: "panel",
      style: normalizeStyle($options.panelStyle),
      onClick: _cache[0] || (_cache[0] = (...args) => $options.clickPanelSetColor && $options.clickPanelSetColor(...args))
    }, [
      createElementVNode("div", _hoisted_2$b, null, 512)
    ], 4),
    createVNode(_component_Slider, {
      modelValue: $data.hsv[0],
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.hsv[0] = $event),
      min: 0,
      max: 360,
      "stroke-width": "0.3rem",
      square: "",
      "track-color": "linear-gradient(to right, #f00 0%, #ff0 16.66%, #0f0 33.33%, #0ff 50%, #00f 66.66%, #f0f 83.33%, #f00 100%)",
      color: "transparent",
      onChange: $options.setValue
    }, {
      button: withCtx(() => [
        _hoisted_3$a
      ]),
      _: 1
    }, 8, ["modelValue", "onChange"]),
    $props.showAlpha ? (openBlock(), createElementBlock("div", _hoisted_4$8, [
      createVNode(_component_Slider, {
        modelValue: $data.opacity,
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.opacity = $event),
        min: 0,
        max: 1,
        "stroke-width": "0.3rem",
        square: "",
        "track-color": $options.alphaTrackColor,
        color: "transparent",
        onChange: $options.setValue
      }, {
        button: withCtx(() => [
          _hoisted_5$7
        ]),
        _: 1
      }, 8, ["modelValue", "track-color", "onChange"])
    ])) : createCommentVNode("", true)
  ]);
}
const ColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$j], ["__scopeId", "data-v-2743107c"]]);
ColorPicker.install = (app) => {
  app.component(ColorPicker.name, ColorPicker);
};
const richImage_vue_vue_type_style_index_0_scoped_a4afd322_lang = "";
const _sfc_main$i = {
  name: "m-rich-image",
  data() {
    return {
      isDoubleTouch: false,
      touchDistance: 0,
      scale: 1,
      translateX: 0,
      translateY: 0,
      startX: 0,
      startY: 0,
      canMove: false,
      downPoint: null,
      upPoint: null,
      isTriggerDouble: false,
      timer: null,
      rotate: 0
    };
  },
  props: {
    src: {
      type: String,
      default: ""
    },
    loadIcon: {
      type: [String, Object],
      default: null
    },
    errorIcon: {
      type: [String, Object],
      default: null
    },
    maxScale: {
      type: Number,
      default: 3
    },
    minScale: {
      type: Number,
      default: 0.3
    }
  },
  emits: ["close-preview", "disable-swiper-touch", "enable-swiper-touch"],
  components: {
    Image
  },
  computed: {
    imgStyle() {
      return {
        transform: `scale(${this.scale}) translate(${this.translateX}px,${this.translateY}px) rotate(${this.rotate}deg)`
      };
    }
  },
  setup() {
    const instance = getCurrentInstance();
    return {
      uid: instance.uid
    };
  },
  mounted() {
    obj$1.event.on(document.documentElement, `mousemove.richImage_${this.uid}`, this.imageMouseMove);
    obj$1.event.on(document.documentElement, `mouseup.richImage_${this.uid}`, this.imageMouseUp);
  },
  methods: {
    leftRotate() {
      this.translateX = 0;
      this.translateY = 0;
      this.scale = 1;
      this.rotate -= 90;
    },
    rightRotate() {
      this.translateX = 0;
      this.translateY = 0;
      this.scale = 1;
      this.rotate += 90;
    },
    scalePlus() {
      if (this.scale < this.maxScale) {
        this.translateX = 0;
        this.translateY = 0;
        this.scale = obj$1.number.add(this.scale, 0.1);
      }
    },
    scaleMinus() {
      if (this.scale > this.minScale) {
        this.translateX = 0;
        this.translateY = 0;
        this.scale = obj$1.number.subtract(this.scale, 0.1);
      }
    },
    scaleImageByWheel(event2) {
      if (event2.cancelable) {
        event2.preventDefault();
      }
      let deltaY = event2.wheelDeltaY || -event2.deltaY;
      if (deltaY > 0) {
        this.scalePlus();
      } else {
        this.scaleMinus();
      }
    },
    scaleImageByTouch(type, event2) {
      if (type == 0) {
        this.isTriggerDouble = false;
        if (event2.touches.length == 2) {
          this.disableSwiperTouch();
          this.isDoubleTouch = true;
          this.canMove = false;
          this.touchDistance = this.getDistance(event2.touches[0], event2.touches[1]);
        } else {
          this.isDoubleTouch = false;
          if (this.scale > 1) {
            this.disableSwiperTouch();
            this.startX = event2.targetTouches[0].pageX;
            this.startY = event2.targetTouches[0].pageY;
            this.canMove = true;
          }
        }
      } else if (type == 1) {
        if (event2.touches.length == 2 && this.isDoubleTouch) {
          if (event2.cancelable) {
            event2.preventDefault();
          }
          let distance = this.getDistance(event2.touches[0], event2.touches[1]);
          if (distance < this.touchDistance) {
            if (this.scale > this.minScale) {
              this.translateX = 0;
              this.translateY = 0;
              this.scale = obj$1.number.add(this.scale, obj$1.number.divide(obj$1.number.subtract(distance, this.touchDistance), this.$el.offsetWidth));
            }
          } else {
            if (this.scale < this.maxScale) {
              this.translateX = 0;
              this.translateY = 0;
              this.scale = obj$1.number.add(this.scale, obj$1.number.divide(obj$1.number.subtract(distance, this.touchDistance), this.$el.offsetWidth));
            }
          }
          this.touchDistance = distance;
        } else {
          if (event2.cancelable) {
            event2.preventDefault();
          }
          let endX = event2.targetTouches[0].pageX;
          let endY = event2.targetTouches[0].pageY;
          if (this.canMove) {
            this.imageTranslate(endX, endY);
          }
        }
      } else if (type == 2) {
        if (this.isDoubleTouch) {
          if (this.scale < 1) {
            this.doTransition(() => {
              this.scale = 1;
            });
          }
          this.isTriggerDouble = true;
          this.isDoubleTouch = false;
          this.enableSwiperTouch();
        } else {
          if (this.canMove && !this.isTriggerDouble) {
            this.imageTranslateEnd();
          }
        }
      }
    },
    getDistance(p1, p2) {
      let x = p2.pageX - p1.pageX;
      let y = p2.pageY - p1.pageY;
      return Math.sqrt(x * x + y * y);
    },
    reset() {
      this.scale = 1;
      this.translateX = 0;
      this.translateY = 0;
      this.rotate = 0;
      this.enableSwiperTouch();
    },
    judgeClose(index, event2) {
      if (index == 0) {
        this.downPoint = {
          x: event2.pageX,
          y: event2.pageY
        };
      } else if (index == 1) {
        this.upPoint = {
          x: event2.pageX,
          y: event2.pageY
        };
      }
    },
    closePreview() {
      if (this.downPoint && this.upPoint && this.downPoint.x == this.upPoint.x && this.downPoint.y == this.upPoint.y) {
        this.$emit("close-preview");
      }
    },
    imageMouseDown(event2) {
      if (this.scale <= 1) {
        return;
      }
      this.disableSwiperTouch();
      this.startX = event2.pageX;
      this.startY = event2.pageY;
      this.canMove = true;
    },
    imageMouseMove(event2) {
      if (event2.cancelable) {
        event2.preventDefault();
      }
      let endX = event2.pageX;
      let endY = event2.pageY;
      if (this.canMove) {
        this.imageTranslate(endX, endY);
      }
    },
    imageMouseUp(event2) {
      if (this.canMove) {
        this.imageTranslateEnd();
      }
    },
    doTransition(callback) {
      this.$refs.img.$el.style.transition = "transform 300ms";
      this.$refs.img.$el.style.webkitTransition = "transform 300ms";
      this.$refs.img.$el.offsetWidth;
      callback();
      setTimeout(() => {
        this.$refs.img.$el.style.transition = "";
        this.$refs.img.$el.style.webkitTransition = "";
        this.$refs.img.$el.offsetWidth;
      }, 300);
    },
    imageTranslate(endX, endY) {
      let moveX = obj$1.number.divide(endX - this.startX, 2);
      let moveY = obj$1.number.divide(endY - this.startY, 2);
      const placement = obj$1.element.getElementBounding(this.$refs.img.$el);
      if (moveX > 0 && placement.left >= 0) {
        return;
      }
      if (moveX < 0 && placement.right >= 0) {
        return;
      }
      if (moveY > 0 && placement.top >= 0) {
        return;
      }
      if (moveY < 0 && placement.bottom >= 0) {
        return;
      }
      this.translateX = this.translateX + moveX;
      this.translateY = this.translateY + moveY;
      this.startX = endX;
      this.startY = endY;
    },
    imageTranslateEnd() {
      const placement = obj$1.element.getElementBounding(this.$refs.img.$el);
      if (placement.left > 0) {
        this.doTransition(() => {
          this.translateX = this.translateX - placement.left;
        });
      }
      if (placement.top > 0) {
        this.doTransition(() => {
          this.translateY = this.translateY - placement.top;
        });
      }
      if (placement.right > 0) {
        this.doTransition(() => {
          this.translateX = this.translateX + placement.right;
        });
      }
      if (placement.bottom > 0) {
        this.doTransition(() => {
          this.translateY = this.translateY + placement.bottom;
        });
      }
      this.canMove = false;
      this.enableSwiperTouch();
    },
    disableSwiperTouch() {
      clearTimeout(this.timer);
      this.$emit("disable-swiper-touch");
    },
    enableSwiperTouch() {
      this.timer = setTimeout(() => {
        this.$emit("enable-swiper-touch");
      }, 100);
    }
  },
  beforeUnmount() {
    obj$1.event.off(document.documentElement, `mousemove.richImage_${this.uid} mouseup.richImage_${this.uid}`);
  }
};
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Image = resolveComponent("Image");
  return openBlock(), createElementBlock("div", {
    class: "mvi-rich-image",
    onMousewheel: _cache[0] || (_cache[0] = (...args) => $options.scaleImageByWheel && $options.scaleImageByWheel(...args)),
    onTouchstart: _cache[1] || (_cache[1] = ($event) => $options.scaleImageByTouch(0, $event)),
    onTouchmove: _cache[2] || (_cache[2] = ($event) => $options.scaleImageByTouch(1, $event)),
    onTouchend: _cache[3] || (_cache[3] = ($event) => $options.scaleImageByTouch(2, $event)),
    onMousedown: _cache[4] || (_cache[4] = ($event) => $options.judgeClose(0, $event)),
    onMouseup: _cache[5] || (_cache[5] = ($event) => $options.judgeClose(1, $event)),
    onClick: _cache[6] || (_cache[6] = (...args) => $options.closePreview && $options.closePreview(...args))
  }, [
    createVNode(_component_Image, {
      ref: "img",
      fit: "response",
      onMousedown: $options.imageMouseDown,
      style: normalizeStyle($options.imgStyle),
      width: "100%",
      height: "100%",
      src: $props.src,
      "load-icon": $props.loadIcon,
      "error-icon": $props.errorIcon
    }, null, 8, ["onMousedown", "style", "src", "load-icon", "error-icon"])
  ], 32);
}
const RichImage = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$i], ["__scopeId", "data-v-a4afd322"]]);
const imagePreview_vue_vue_type_style_index_0_scoped_bdc0dfbe_lang = "";
const _sfc_main$h = {
  name: "m-image-preview",
  data() {
    return {
      firstShow: false,
      enableTouch: true,
      imageRefs: []
    };
  },
  emits: ["update:modelValue", "change"],
  props: {
    modelValue: {
      type: Boolean,
      default: false
    },
    images: {
      type: Array,
      default: function() {
        return [];
      }
    },
    descriptions: {
      type: Array,
      default: function() {
        return [];
      }
    },
    active: {
      type: Number,
      default: 0
    },
    mountEl: {
      type: String,
      default: null
    },
    showPage: {
      type: Boolean,
      default: true
    },
    zIndex: {
      type: Number,
      default: 5e3
    },
    fade: {
      type: Boolean,
      default: false
    },
    showControl: {
      type: Boolean,
      default: false
    },
    usePadding: {
      type: Boolean,
      default: false
    },
    errorIcon: {
      type: [String, Object],
      default: {
        size: "1rem",
        type: "image-error"
      }
    },
    loadIcon: {
      type: [String, Object],
      default: function() {
        return {
          size: "1rem",
          type: "image-alt"
        };
      }
    },
    useTools: {
      type: Boolean,
      default: false
    },
    maxScale: {
      type: Number,
      default: 3
    },
    minScale: {
      type: Number,
      default: 0.3
    }
  },
  computed: {
    $$el() {
      return this.$refs.overlay.$$el;
    },
    show: {
      set(value) {
        this.$emit("update:modelValue", value);
      },
      get() {
        return this.modelValue;
      }
    }
  },
  components: {
    Overlay,
    Swiper,
    SwiperSlide,
    Icon,
    RichImage
  },
  methods: {
    resetImage(active) {
      this.imageRefs[active].reset();
    },
    plusImage(active) {
      this.imageRefs[active].scalePlus();
    },
    minusImage(active) {
      this.imageRefs[active].scaleMinus();
    },
    leftRotateImage(active) {
      this.imageRefs[active].leftRotate();
    },
    rightRotateImage(active) {
      this.imageRefs[active].rightRotate();
    },
    overlayShowing() {
      if (!this.firstShow) {
        this.firstShow = true;
      }
    },
    closeOverlay(e) {
      for (let richImage of this.imageRefs) {
        richImage.reset();
      }
      this.show = false;
    },
    swiperChange(active) {
      for (let richImage of this.imageRefs) {
        richImage.reset();
      }
      this.$emit("change", active);
    }
  }
};
const _withScopeId$1 = (n) => (pushScopeId("data-v-bdc0dfbe"), n = n(), popScopeId(), n);
const _hoisted_1$a = {
  key: 0,
  class: "mvi-image-preview-page"
};
const _hoisted_2$a = { key: 1 };
const _hoisted_3$9 = ["textContent"];
const _hoisted_4$7 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createElementVNode("span", null, "/", -1));
const _hoisted_5$6 = ["textContent"];
const _hoisted_6$6 = {
  key: 1,
  class: "mvi-image-preview-footer"
};
const _hoisted_7$5 = {
  key: 0,
  class: "mvi-image-preview-tools"
};
const _hoisted_8$4 = ["textContent"];
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_RichImage = resolveComponent("RichImage");
  const _component_SwiperSlide = resolveComponent("SwiperSlide");
  const _component_Icon = resolveComponent("Icon");
  const _component_Swiper = resolveComponent("Swiper");
  const _component_Overlay = resolveComponent("Overlay");
  return openBlock(), createBlock(_component_Overlay, {
    ref: "overlay",
    modelValue: $options.show,
    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $options.show = $event),
    color: "#000",
    fade: false,
    onShowing: $options.overlayShowing,
    "z-index": $props.zIndex,
    "use-padding": $props.usePadding,
    mountEl: $props.mountEl
  }, {
    default: withCtx(() => [
      $data.firstShow ? (openBlock(), createBlock(_component_Swiper, {
        key: 0,
        class: "mvi-image-preview-swiper",
        "initial-slide": $props.active,
        "show-indicators": "",
        ref: "swiper",
        onChange: $options.swiperChange,
        "show-control": $props.showControl,
        fade: $props.fade,
        touchable: $data.enableTouch
      }, {
        indicators: withCtx((data2) => [
          $props.showPage ? (openBlock(), createElementBlock("div", _hoisted_1$a, [
            _ctx.$slots.page ? renderSlot(_ctx.$slots, "page", {
              key: 0,
              total: data2.total,
              current: data2.active
            }, void 0, true) : (openBlock(), createElementBlock("div", _hoisted_2$a, [
              createElementVNode("span", {
                textContent: toDisplayString(data2.active + 1)
              }, null, 8, _hoisted_3$9),
              _hoisted_4$7,
              createElementVNode("span", {
                textContent: toDisplayString(data2.total)
              }, null, 8, _hoisted_5$6)
            ]))
          ])) : createCommentVNode("", true),
          $props.useTools || _ctx.$slots.descriptions || $props.descriptions.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_6$6, [
            $props.useTools ? (openBlock(), createElementBlock("div", _hoisted_7$5, [
              createVNode(_component_Icon, {
                onClick: ($event) => $options.plusImage(data2.active),
                class: "mvi-image-preview-tools-icon",
                type: "search-plus-o"
              }, null, 8, ["onClick"]),
              createVNode(_component_Icon, {
                onClick: ($event) => $options.minusImage(data2.active),
                class: "mvi-image-preview-tools-icon",
                type: "search-minus-o"
              }, null, 8, ["onClick"]),
              createVNode(_component_Icon, {
                onClick: ($event) => $options.resetImage(data2.active),
                class: "mvi-image-preview-tools-icon",
                type: "double-circle"
              }, null, 8, ["onClick"]),
              createVNode(_component_Icon, {
                onClick: ($event) => $options.leftRotateImage(data2.active),
                class: "mvi-image-preview-tools-icon",
                type: "left-rotate"
              }, null, 8, ["onClick"]),
              createVNode(_component_Icon, {
                onClick: ($event) => $options.rightRotateImage(data2.active),
                class: "mvi-image-preview-tools-icon",
                type: "right-rotate"
              }, null, 8, ["onClick"]),
              _ctx.$slots.tools ? renderSlot(_ctx.$slots, "tools", { key: 0 }, void 0, true) : createCommentVNode("", true)
            ])) : createCommentVNode("", true),
            _ctx.$slots.descriptions || $props.descriptions.length > 0 ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(["mvi-image-preview-description", $props.useTools ? "mvi-image-preview-description-margin" : ""])
            }, [
              _ctx.$slots.descriptions ? renderSlot(_ctx.$slots, "descriptions", {
                key: 0,
                total: data2.total,
                current: data2.active
              }, void 0, true) : $props.descriptions.length > 0 ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: "mvi-image-preview-description-el",
                textContent: toDisplayString($props.descriptions[data2.active])
              }, null, 8, _hoisted_8$4)) : createCommentVNode("", true)
            ], 2)) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.images, (item, index) => {
            return openBlock(), createBlock(_component_SwiperSlide, { class: "mvi-preview-container" }, {
              default: withCtx(() => [
                createVNode(_component_RichImage, {
                  ref_for: true,
                  ref: (el) => $data.imageRefs[index] = el,
                  onClosePreview: $options.closeOverlay,
                  onDisableSwiperTouch: _cache[0] || (_cache[0] = ($event) => $data.enableTouch = false),
                  onEnableSwiperTouch: _cache[1] || (_cache[1] = ($event) => $data.enableTouch = true),
                  src: item,
                  "error-icon": $props.errorIcon,
                  "load-icon": $props.loadIcon,
                  "max-scale": $props.maxScale,
                  "min-scale": $props.minScale
                }, null, 8, ["onClosePreview", "src", "error-icon", "load-icon", "max-scale", "min-scale"])
              ]),
              _: 2
            }, 1024);
          }), 256))
        ]),
        _: 3
      }, 8, ["initial-slide", "onChange", "show-control", "fade", "touchable"])) : createCommentVNode("", true)
    ]),
    _: 3
  }, 8, ["modelValue", "onShowing", "z-index", "use-padding", "mountEl"]);
}
const ImagePreview = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$h], ["__scopeId", "data-v-bdc0dfbe"]]);
ImagePreview.install = (app) => {
  app.component(ImagePreview.name, ImagePreview);
};
const page_vue_vue_type_style_index_0_scoped_f303e966_lang = "";
const _sfc_main$g = {
  name: "m-page",
  data() {
    return {
      el: null
    };
  },
  emits: ["update:modelValue", "change"],
  props: {
    modelValue: {
      type: Number,
      default: 1
    },
    total: {
      type: Number,
      default: 1
    },
    overNumber: {
      type: Number,
      default: 3,
      validator(value) {
        return value % 2 != 0;
      }
    },
    prevText: {
      type: String,
      default: null
    },
    nextText: {
      type: String,
      default: null
    },
    prevIcon: {
      type: [String, Object],
      default: "angle-left"
    },
    nextIcon: {
      type: [String, Object],
      default: "angle-right"
    },
    simple: {
      type: Boolean,
      default: false
    },
    firstText: {
      type: String,
      default: null
    },
    lastText: {
      type: String,
      default: null
    },
    firstIcon: {
      type: [Object, String],
      default: "angle-double-left"
    },
    lastIcon: {
      type: [Object, String],
      default: "angle-double-right"
    },
    color: {
      type: String,
      default: null
    },
    active: {
      type: Boolean,
      default: true
    }
  },
  computed: {
    pageStyle() {
      return (item) => {
        let style = {};
        if (this.modelValue == item) {
          if (this.el) {
            style.color = obj$1.element.getCssStyle(this.el, "background-color");
          }
          style.backgroundColor = this.color || "";
        } else {
          style.color = this.color || "";
        }
        return style;
      };
    },
    arr() {
      let arr = [];
      if (this.modelValue <= (this.overNumber - 1) / 2 + 1) {
        for (let i = 0; i < this.overNumber; i++) {
          arr.push(i + 1);
        }
      } else if (this.modelValue <= this.total - (this.overNumber - 1) / 2) {
        for (let i = 0; i < (this.overNumber - 1) / 2; i++) {
          arr.push(this.modelValue - ((this.overNumber - 1) / 2 - i));
        }
        arr.push(this.modelValue);
        for (let i = 0; i < (this.overNumber - 1) / 2; i++) {
          arr.push(this.modelValue + (i + 1));
        }
      } else {
        for (let i = 0; i < this.overNumber; i++) {
          arr.push(this.total - (this.overNumber - 1 - i));
        }
      }
      return arr;
    },
    parseIcon() {
      return (param) => {
        let icon = {
          spin: false,
          type: null,
          url: null,
          color: null,
          size: null
        };
        if (obj$1.common.isObject(param)) {
          if (typeof param.spin == "boolean") {
            icon.spin = param.spin;
          }
          if (typeof param.type == "string") {
            icon.type = param.type;
          }
          if (typeof param.url == "string") {
            icon.url = param.url;
          }
          if (typeof param.color == "string") {
            icon.color = param.color;
          }
          if (typeof param.size == "string") {
            icon.size = param.size;
          }
        } else if (typeof param == "string") {
          icon.type = param;
        }
        return icon;
      };
    },
    firstStyle() {
      let style = {};
      if (this.modelValue > 1 && this.color) {
        style.color = this.color;
      }
      return style;
    },
    lastStyle() {
      let style = {};
      if (this.modelValue < this.total && this.color) {
        style.color = this.color;
      }
      return style;
    }
  },
  components: {
    Icon
  },
  mounted() {
    this.el = this.$el;
  },
  methods: {
    pagePrev() {
      if (this.modelValue == 1) {
        return;
      }
      let page = this.modelValue - 1;
      this.$emit("update:modelValue", page);
      this.$emit("change", page);
    },
    pageNext() {
      if (this.modelValue == this.total) {
        return;
      }
      let page = this.modelValue + 1;
      this.$emit("update:modelValue", page);
      this.$emit("change", page);
    },
    pageFirst() {
      if (this.modelValue == 1) {
        return;
      }
      this.$emit("update:modelValue", 1);
      this.$emit("change", 1);
    },
    pageLast() {
      if (this.modelValue == this.total) {
        return;
      }
      this.$emit("update:modelValue", this.total);
      this.$emit("change", this.total);
    },
    toPage(page) {
      if (this.modelValue == page) {
        return;
      }
      if (page >= this.total) {
        page = this.total;
      }
      if (page <= 1) {
        page = 1;
      }
      this.$emit("update:modelValue", page);
      this.$emit("change", page);
    }
  }
};
const _hoisted_1$9 = { class: "mvi-page" };
const _hoisted_2$9 = ["disabled"];
const _hoisted_3$8 = ["textContent"];
const _hoisted_4$6 = ["disabled"];
const _hoisted_5$5 = ["textContent"];
const _hoisted_6$5 = { class: "mvi-page-numbers" };
const _hoisted_7$4 = {
  key: 0,
  class: "mvi-page-numbers-simple"
};
const _hoisted_8$3 = {
  key: 1,
  class: "mvi-page-numbers-items"
};
const _hoisted_9$3 = ["textContent", "onClick"];
const _hoisted_10$3 = ["textContent", "onClick"];
const _hoisted_11$2 = ["disabled"];
const _hoisted_12$1 = ["textContent"];
const _hoisted_13$1 = ["disabled"];
const _hoisted_14$1 = ["textContent"];
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("div", _hoisted_1$9, [
    $props.firstText || $options.parseIcon($props.firstIcon).type || $options.parseIcon($props.firstIcon).url ? (openBlock(), createElementBlock("div", {
      key: 0,
      disabled: $props.modelValue == 1 || null,
      onClick: _cache[0] || (_cache[0] = (...args) => $options.pageFirst && $options.pageFirst(...args)),
      class: normalizeClass(["mvi-page-first", $props.active && $props.modelValue != 1 ? "active" : ""]),
      style: normalizeStyle($options.firstStyle)
    }, [
      $options.parseIcon($props.firstIcon).type || $options.parseIcon($props.firstIcon).url ? (openBlock(), createBlock(_component_Icon, {
        key: 0,
        class: normalizeClass($props.firstText ? "margin-right" : ""),
        type: $options.parseIcon($props.firstIcon).type,
        url: $options.parseIcon($props.firstIcon).url,
        spin: $options.parseIcon($props.firstIcon).spin,
        size: $options.parseIcon($props.firstIcon).size,
        color: $options.parseIcon($props.firstIcon).color
      }, null, 8, ["class", "type", "url", "spin", "size", "color"])) : createCommentVNode("", true),
      $props.firstText ? (openBlock(), createElementBlock("span", {
        key: 1,
        textContent: toDisplayString($props.firstText)
      }, null, 8, _hoisted_3$8)) : createCommentVNode("", true)
    ], 14, _hoisted_2$9)) : createCommentVNode("", true),
    $props.prevText || $options.parseIcon($props.prevIcon).type || $options.parseIcon($props.prevIcon).url ? (openBlock(), createElementBlock("div", {
      key: 1,
      disabled: $props.modelValue == 1 || null,
      onClick: _cache[1] || (_cache[1] = (...args) => $options.pagePrev && $options.pagePrev(...args)),
      class: normalizeClass(["mvi-page-prev", $props.active && $props.modelValue != 1 ? "active" : ""]),
      style: normalizeStyle($options.firstStyle)
    }, [
      $options.parseIcon($props.prevIcon).type || $options.parseIcon($props.prevIcon).url ? (openBlock(), createBlock(_component_Icon, {
        key: 0,
        class: normalizeClass($props.prevText ? "margin-right" : ""),
        type: $options.parseIcon($props.prevIcon).type,
        url: $options.parseIcon($props.prevIcon).url,
        size: $options.parseIcon($props.prevIcon).size,
        spin: $options.parseIcon($props.prevIcon).spin,
        color: $options.parseIcon($props.prevIcon).color
      }, null, 8, ["class", "type", "url", "size", "spin", "color"])) : createCommentVNode("", true),
      $props.prevText ? (openBlock(), createElementBlock("span", {
        key: 1,
        textContent: toDisplayString($props.prevText)
      }, null, 8, _hoisted_5$5)) : createCommentVNode("", true)
    ], 14, _hoisted_4$6)) : createCommentVNode("", true),
    createElementVNode("div", _hoisted_6$5, [
      $props.simple ? (openBlock(), createElementBlock("div", _hoisted_7$4, toDisplayString($props.modelValue) + " / " + toDisplayString($props.total), 1)) : (openBlock(), createElementBlock("div", _hoisted_8$3, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($props.total, (item) => {
          return openBlock(), createElementBlock(Fragment, null, [
            $props.total <= $props.overNumber ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(["mvi-page-numbers-item", $props.modelValue == item ? "number-active" : "", $props.active && $props.modelValue != item ? "active" : ""]),
              textContent: toDisplayString(item),
              onClick: ($event) => $options.toPage(item),
              style: normalizeStyle($options.pageStyle(item))
            }, null, 14, _hoisted_9$3)) : createCommentVNode("", true)
          ], 64);
        }), 256)),
        $props.total > $props.overNumber && $props.modelValue > ($props.overNumber - 1) / 2 + 1 ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["mvi-page-numbers-item", $props.active ? "active" : ""]),
          onClick: _cache[2] || (_cache[2] = ($event) => $options.toPage($props.modelValue - ($props.overNumber - 1))),
          style: normalizeStyle({ color: $props.color || "" })
        }, "...", 6)) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.arr, (item) => {
          return openBlock(), createElementBlock(Fragment, null, [
            $props.total > $props.overNumber ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(["mvi-page-numbers-item", $props.modelValue == item ? "number-active" : "", $props.active && $props.modelValue != item ? "active" : ""]),
              textContent: toDisplayString(item),
              onClick: ($event) => $options.toPage(item),
              style: normalizeStyle($options.pageStyle(item))
            }, null, 14, _hoisted_10$3)) : createCommentVNode("", true)
          ], 64);
        }), 256)),
        $props.total > $props.overNumber && $props.modelValue < $props.total - ($props.overNumber - 1) / 2 ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(["mvi-page-numbers-item", $props.active ? "active" : ""]),
          onClick: _cache[3] || (_cache[3] = ($event) => $options.toPage($props.modelValue + ($props.overNumber - 1))),
          style: normalizeStyle({ color: $props.color || "" })
        }, "...", 6)) : createCommentVNode("", true)
      ]))
    ]),
    $props.nextText || $options.parseIcon($props.nextIcon).type || $options.parseIcon($props.nextIcon).url ? (openBlock(), createElementBlock("div", {
      key: 2,
      disabled: $props.modelValue == $props.total || null,
      onClick: _cache[4] || (_cache[4] = (...args) => $options.pageNext && $options.pageNext(...args)),
      class: normalizeClass(["mvi-page-next", $props.active && $props.modelValue != $props.total ? "active" : ""]),
      style: normalizeStyle($options.lastStyle)
    }, [
      $props.nextText ? (openBlock(), createElementBlock("span", {
        key: 0,
        textContent: toDisplayString($props.nextText)
      }, null, 8, _hoisted_12$1)) : createCommentVNode("", true),
      $options.parseIcon($props.nextIcon).type || $options.parseIcon($props.nextIcon).url ? (openBlock(), createBlock(_component_Icon, {
        key: 1,
        class: normalizeClass($props.nextText ? "margin-left" : ""),
        type: $options.parseIcon($props.nextIcon).type,
        url: $options.parseIcon($props.nextIcon).url,
        size: $options.parseIcon($props.nextIcon).size,
        spin: $options.parseIcon($props.nextIcon).spin,
        color: $options.parseIcon($props.nextIcon).color
      }, null, 8, ["class", "type", "url", "size", "spin", "color"])) : createCommentVNode("", true)
    ], 14, _hoisted_11$2)) : createCommentVNode("", true),
    $props.lastText || $options.parseIcon($props.lastIcon).type || $options.parseIcon($props.lastIcon).url ? (openBlock(), createElementBlock("div", {
      key: 3,
      disabled: $props.modelValue == $props.total || null,
      onClick: _cache[5] || (_cache[5] = (...args) => $options.pageLast && $options.pageLast(...args)),
      class: normalizeClass(["mvi-page-last", $props.active && $props.modelValue != $props.total ? "active" : ""]),
      style: normalizeStyle($options.lastStyle)
    }, [
      $props.lastText ? (openBlock(), createElementBlock("span", {
        key: 0,
        textContent: toDisplayString($props.lastText)
      }, null, 8, _hoisted_14$1)) : createCommentVNode("", true),
      $options.parseIcon($props.lastIcon).type || $options.parseIcon($props.lastIcon).url ? (openBlock(), createBlock(_component_Icon, {
        key: 1,
        class: normalizeClass($props.lastText ? "margin-left" : ""),
        type: $options.parseIcon($props.lastIcon).type,
        url: $options.parseIcon($props.lastIcon).url,
        size: $options.parseIcon($props.lastIcon).size,
        spin: $options.parseIcon($props.lastIcon).spin,
        color: $options.parseIcon($props.lastIcon).color
      }, null, 8, ["class", "type", "url", "size", "spin", "color"])) : createCommentVNode("", true)
    ], 14, _hoisted_13$1)) : createCommentVNode("", true)
  ]);
}
const Page = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$g], ["__scopeId", "data-v-f303e966"]]);
Page.install = (app) => {
  app.component(Page.name, Page);
};
const loadingBar_vue_vue_type_style_index_0_scoped_efd41e28_lang = "";
const _sfc_main$f = {
  name: "m-loading-bar",
  data() {
    return {
      opacityTime: 300,
      widthEnterTime: 4e3,
      widthLeaveTime: 2e3,
      timer: null,
      hasTriggerLeave: false
    };
  },
  props: {
    color: {
      type: String,
      default: null
    },
    zIndex: {
      type: Number,
      default: null
    },
    __remove: {
      type: Function,
      default: function() {
        return function() {
        };
      }
    },
    __init: {
      type: Function,
      default: function() {
        return function() {
        };
      }
    }
  },
  computed: {
    cmpColor() {
      if (typeof this.color == "string" && this.color) {
        return this.color;
      } else {
        return null;
      }
    },
    cmpZIndex() {
      if (obj$1.number.isNumber(this.zIndex)) {
        return this.zIndex;
      } else {
        return null;
      }
    },
    barStyle() {
      let style = {};
      if (this.cmpColor) {
        style.background = this.cmpColor;
      }
      if (this.cmpZIndex) {
        style.zIndex = this.cmpZIndex;
      }
      return style;
    }
  },
  mounted() {
    this.__init(this);
    this.enter();
  },
  methods: {
    enter() {
      this.removeTransition();
      this.$refs.bar.style.width = 0;
      this.addTransition("enter");
      this.$refs.bar.style.width = window.innerWidth * 0.9 + "px";
      this.$refs.bar.style.opacity = 1;
    },
    leave() {
      if (this.hasTriggerLeave) {
        return;
      }
      this.hasTriggerLeave = true;
      this.addTransition("leave");
      this.$refs.bar.style.width = window.innerWidth + "px";
      this.$refs.bar.style.opacity = 0;
      this.timer = setTimeout(() => {
        this.__remove();
      }, this.widthLeaveTime + this.opacityTime);
    },
    addTransition(type) {
      if (type == "enter") {
        this.$refs.bar.style.transition = `opacity ${this.opacityTime}ms linear, width ${this.widthEnterTime}ms ease-out`;
        this.$refs.bar.style.webkitTransition = `opacity ${this.opacityTime}ms linear, width ${this.widthEnterTime}ms ease-out`;
      } else if (type == "leave") {
        this.$refs.bar.style.transition = `opacity ${this.opacityTime}ms ${this.widthLeaveTime}ms linear, width ${this.widthLeaveTime}ms ease`;
        this.$refs.bar.style.webkitTransition = `opacity ${this.opacityTime}ms ${this.widthLeaveTime}ms linear, width ${this.widthLeaveTime}ms ease`;
      }
      this.$refs.bar.offsetWidth;
    },
    removeTransition() {
      this.$refs.bar.style.transition = "";
      this.$refs.bar.style.webkitTransition = "";
      this.$refs.bar.offsetWidth;
    }
  },
  beforeUnmount() {
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }
  }
};
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Teleport, { to: "body" }, [
    createElementVNode("div", {
      class: "mvi-loading-bar",
      ref: "bar",
      style: normalizeStyle($options.barStyle)
    }, null, 4)
  ]);
}
const LoadingBarComponent = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$f], ["__scopeId", "data-v-efd41e28"]]);
const LoadingBar = {
  initParams: (options) => {
    let opts = {};
    if (obj$1.common.isObject(options)) {
      opts.color = options.color;
      opts.zIndex = options.zIndex;
    } else if (typeof options == "string") {
      opts.color = options;
    }
    return opts;
  },
  showLoadingBar: (options) => {
    return new Promise((resolve, reject) => {
      if (LoadingBar.$el && LoadingBar.$instance) {
        LoadingBar.$instance.unmount();
        LoadingBar.$el.remove();
      }
      let opts = LoadingBar.initParams(options);
      let mountNode = obj$1.element.string2dom("<div></div>");
      document.body.appendChild(mountNode);
      const instance = createApp(LoadingBarComponent, {
        ...opts,
        __init: (vm) => {
          LoadingBar.$vm = vm;
        },
        __remove: () => {
          instance.unmount();
          mountNode.remove();
          resolve();
        }
      });
      instance.mount(mountNode);
      LoadingBar.$el = mountNode;
      LoadingBar.$instance = instance;
    });
  },
  hideLoadingBar: () => {
    if (LoadingBar.$vm) {
      LoadingBar.$vm.leave();
    }
  },
  install: (app) => {
    app.config.globalProperties.$showLoadingBar = LoadingBar.showLoadingBar;
    app.provide("$showLoadingBar", LoadingBar.showLoadingBar);
    app.config.globalProperties.$hideLoadingBar = LoadingBar.hideLoadingBar;
    app.provide("$hideLoadingBar", LoadingBar.hideLoadingBar);
  }
};
const list_vue_vue_type_style_index_0_scoped_72b97f74_lang = "";
const _sfc_main$e = {
  name: "m-list",
  emits: ["load", "update:loading", "update:error"],
  data() {
    return {
      scrollObj: null
    };
  },
  props: {
    loading: {
      type: Boolean,
      default: false
    },
    error: {
      type: Boolean,
      default: false
    },
    finished: {
      type: Boolean,
      default: false
    },
    loadingText: {
      type: String,
      default: "\u6B63\u5728\u52A0\u8F7D"
    },
    errorText: {
      type: String,
      default: "\u6570\u636E\u52A0\u8F7D\u5931\u8D25"
    },
    finishedText: {
      type: String,
      default: "\u6CA1\u6709\u66F4\u591A\u4E86"
    },
    immediateLoad: {
      type: Boolean,
      default: false
    },
    content: {
      type: String,
      default: "\u70B9\u6211\u52A0\u8F7D\u66F4\u591A"
    },
    scrollEl: {
      type: String,
      default: null
    }
  },
  mounted() {
    this.initScroll();
    if (this.immediateLoad) {
      this.doLoad();
    }
  },
  methods: {
    initScroll() {
      const el = document.body.querySelector(this.scrollEl);
      if (!el) {
        return;
      }
      if (this.scrollObj) {
        return;
      }
      this.scrollObj = new Scroll$1(el, {
        bottom: () => {
          if (this.finished || this.loading || this.error) {
            return;
          }
          this.doLoad();
        }
      });
      this.scrollObj.init();
    },
    doLoad() {
      if (this.finished) {
        return;
      }
      this.$emit("update:loading", true);
      this.$emit("update:error", false);
      this.$emit("load");
    }
  }
};
const _hoisted_1$8 = { class: "mvi-list" };
const _hoisted_2$8 = {
  key: 0,
  class: "mvi-list-finished"
};
const _hoisted_3$7 = { key: 1 };
const _hoisted_4$5 = {
  key: 1,
  class: "mvi-list-loading"
};
const _hoisted_5$4 = { key: 1 };
const _hoisted_6$4 = { key: 1 };
const _hoisted_7$3 = { key: 1 };
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$8, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true),
    $props.finished ? (openBlock(), createElementBlock("div", _hoisted_2$8, [
      _ctx.$slots.finished ? renderSlot(_ctx.$slots, "finished", { key: 0 }, void 0, true) : (openBlock(), createElementBlock("span", _hoisted_3$7, toDisplayString($props.finishedText), 1))
    ])) : $props.loading ? (openBlock(), createElementBlock("div", _hoisted_4$5, [
      _ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }, void 0, true) : (openBlock(), createElementBlock("span", _hoisted_5$4, toDisplayString($props.loadingText), 1))
    ])) : $props.error ? (openBlock(), createElementBlock("div", {
      key: 2,
      onClick: _cache[0] || (_cache[0] = (...args) => $options.doLoad && $options.doLoad(...args)),
      class: "mvi-list-error"
    }, [
      _ctx.$slots.error ? renderSlot(_ctx.$slots, "error", { key: 0 }, void 0, true) : (openBlock(), createElementBlock("span", _hoisted_6$4, toDisplayString($props.errorText), 1))
    ])) : $props.content || _ctx.$slots.content ? (openBlock(), createElementBlock("div", {
      key: 3,
      onClick: _cache[1] || (_cache[1] = (...args) => $options.doLoad && $options.doLoad(...args)),
      class: "mvi-list-content"
    }, [
      _ctx.$slots.content ? renderSlot(_ctx.$slots, "content", { key: 0 }, void 0, true) : (openBlock(), createElementBlock("span", _hoisted_7$3, toDisplayString($props.content), 1))
    ])) : createCommentVNode("", true)
  ]);
}
const List = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$e], ["__scopeId", "data-v-72b97f74"]]);
List.install = (app) => {
  app.component(List.name, List);
};
const skeleton_vue_vue_type_style_index_0_scoped_3e02f14d_lang = "";
const _sfc_main$d = {
  name: "m-skeleton",
  props: {
    loading: {
      type: Boolean,
      default: true
    },
    rows: {
      type: Number,
      default: 1,
      validator(value) {
        return value > 0;
      }
    },
    rowWidth: {
      type: [String, Array],
      default: null
    },
    avatar: {
      type: Boolean,
      default: false
    },
    title: {
      type: Boolean,
      default: false
    },
    titleWidth: {
      type: String,
      default: null
    },
    animation: {
      type: Boolean,
      default: false
    },
    round: {
      type: Boolean,
      default: false
    },
    avatarSize: {
      type: String,
      default: null
    },
    avatarRound: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    avatarStyle() {
      let style = {};
      if (this.avatarSize) {
        style.width = this.avatarSize;
        style.height = this.avatarSize;
      }
      return style;
    },
    rowStyle() {
      return (index) => {
        let style = {};
        if (this.rowWidth && typeof this.rowWidth == "string") {
          style.width = this.rowWidth;
        } else if (Array.isArray(this.rowWidth)) {
          style.width = this.rowWidth[index] || "";
        }
        return style;
      };
    },
    titleStyle() {
      let style = {};
      if (this.titleWidth) {
        style.width = this.titleWidth;
      }
      return style;
    },
    rowsArray() {
      let arr = [];
      for (let i = 0; i < this.rows; i++) {
        arr.push(i);
      }
      return arr;
    }
  }
};
const _hoisted_1$7 = { class: "mvi-skeleton-container" };
const _hoisted_2$7 = {
  key: 0,
  class: "mvi-skeleton-avatar"
};
const _hoisted_3$6 = { class: "mvi-skeleton-rows" };
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$7, [
    $props.loading ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(["mvi-skeleton", $props.animation ? "animation" : ""])
    }, [
      $props.avatar ? (openBlock(), createElementBlock("div", _hoisted_2$7, [
        createElementVNode("div", {
          class: normalizeClass(["mvi-skeleton-avatar-el", $props.avatarRound ? "round" : ""]),
          style: normalizeStyle($options.avatarStyle)
        }, null, 6)
      ])) : createCommentVNode("", true),
      createElementVNode("div", _hoisted_3$6, [
        $props.title ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["mvi-skeleton-title", $props.round ? "round" : ""]),
          style: normalizeStyle($options.titleStyle)
        }, null, 6)) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.rowsArray, (item) => {
          return openBlock(), createElementBlock("div", {
            style: normalizeStyle($options.rowStyle(item)),
            class: normalizeClass(["mvi-skeleton-row", $props.round ? "round" : ""])
          }, null, 6);
        }), 256))
      ])
    ], 2)) : renderSlot(_ctx.$slots, "default", { key: 1 }, void 0, true)
  ]);
}
const Skeleton = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d], ["__scopeId", "data-v-3e02f14d"]]);
Skeleton.install = (app) => {
  app.component(Skeleton.name, Skeleton);
};
const sign_vue_vue_type_style_index_0_scoped_e343f79d_lang = "";
const _sfc_main$c = {
  name: "m-sign",
  props: {
    color: {
      type: String,
      default: "#505050"
    },
    background: {
      type: String,
      default: "#fff"
    },
    width: {
      type: Number,
      default: 0.05
    }
  },
  data() {
    return {
      drawing: false,
      inCanvas: false
    };
  },
  setup() {
    const instance = getCurrentInstance();
    return {
      uid: instance.uid
    };
  },
  mounted() {
    this.init();
  },
  watch: {
    background() {
      this.clear();
    }
  },
  methods: {
    init() {
      this.$el.setAttribute("width", obj$1.element.getCssStyle(this.$el, "width"));
      this.$el.setAttribute("height", obj$1.element.getCssStyle(this.$el, "height"));
      this.clear();
      obj$1.event.on(document.documentElement, `mousemove.sign_${this.uid}`, this.canvasMouseMove);
      obj$1.event.on(document.documentElement, `mouseup.sign_${this.uid}`, this.canvasMouseUp);
    },
    canvasMouseDown(e) {
      this.drawing = true;
      this.inCanvas = true;
      const ctx = this.$el.getContext("2d");
      const rect = obj$1.element.getElementBounding(this.$el);
      ctx.beginPath();
      ctx.moveTo(e.pageX - rect.left, e.pageY - rect.top);
    },
    canvasMouseMove(e) {
      if (this.drawing && this.inCanvas) {
        const ctx = this.$el.getContext("2d");
        const rect = obj$1.element.getElementBounding(this.$el);
        ctx.lineTo(e.pageX - rect.left, e.pageY - rect.top);
        ctx.strokeStyle = this.color;
        ctx.lineWidth = obj$1.element.rem2px(this.width);
        ctx.stroke();
      }
    },
    canvasMouseUp(e) {
      this.drawing = false;
      const ctx = this.$el.getContext("2d");
      ctx.closePath();
    },
    canvasMouseEnter(e) {
      if (this.drawing) {
        this.inCanvas = true;
        const ctx = this.$el.getContext("2d");
        const rect = obj$1.element.getElementBounding(this.$el);
        ctx.beginPath();
        ctx.moveTo(e.pageX - rect.left, e.pageY - rect.top);
      }
    },
    canvasMouseLeave(e) {
      if (this.drawing) {
        const ctx = this.$el.getContext("2d");
        ctx.closePath();
        this.inCanvas = false;
      }
    },
    canvasTouchStart(e) {
      const ctx = this.$el.getContext("2d");
      const rect = obj$1.element.getElementBounding(this.$el);
      ctx.beginPath();
      ctx.moveTo(e.targetTouches[0].pageX - rect.left, e.targetTouches[0].pageY - rect.top);
    },
    canvasTouchMove(e) {
      if (e.cancelable) {
        e.preventDefault();
      }
      const ctx = this.$el.getContext("2d");
      const rect = obj$1.element.getElementBounding(this.$el);
      ctx.lineTo(e.targetTouches[0].pageX - rect.left, e.targetTouches[0].pageY - rect.top);
      ctx.strokeStyle = this.color;
      ctx.lineWidth = obj$1.element.rem2px(this.width);
      ctx.stroke();
    },
    canvasTouchEnd(e) {
      const ctx = this.$el.getContext("2d");
      ctx.closePath();
    },
    clear() {
      const ctx = this.$el.getContext("2d");
      ctx.beginPath();
      ctx.clearRect(0, 0, this.$el.width, this.$el.height);
      ctx.rect(0, 0, this.$el.width, this.$el.height);
      ctx.fillStyle = this.background;
      ctx.fill();
      ctx.closePath();
    },
    getImage() {
      const url = this.$el.toDataURL("image/png");
      return url;
    }
  },
  beforeUnmount() {
    obj$1.event.off(document.documentElement, `mousemove.sign_${this.uid} mouseup.sign_${this.uid}`);
  }
};
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("canvas", {
    class: "mvi-sign",
    onMousedown: _cache[0] || (_cache[0] = (...args) => $options.canvasMouseDown && $options.canvasMouseDown(...args)),
    onTouchstart: _cache[1] || (_cache[1] = (...args) => $options.canvasTouchStart && $options.canvasTouchStart(...args)),
    onTouchmove: _cache[2] || (_cache[2] = (...args) => $options.canvasTouchMove && $options.canvasTouchMove(...args)),
    onTouchend: _cache[3] || (_cache[3] = (...args) => $options.canvasTouchEnd && $options.canvasTouchEnd(...args)),
    onMouseleave: _cache[4] || (_cache[4] = (...args) => $options.canvasMouseLeave && $options.canvasMouseLeave(...args)),
    onMouseenter: _cache[5] || (_cache[5] = (...args) => $options.canvasMouseEnter && $options.canvasMouseEnter(...args))
  }, null, 32);
}
const Sign = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c], ["__scopeId", "data-v-e343f79d"]]);
Sign.install = (app) => {
  app.component(Sign.name, Sign);
};
const select_vue_vue_type_style_index_0_scoped_bca887f2_lang = "";
const _sfc_main$b = {
  name: "m-select",
  emits: ["update:modelValue", "change", "clear"],
  data() {
    return {
      hover: false,
      focus: false,
      target: null
    };
  },
  props: {
    modelValue: {
      type: [Object, Number, String, Array],
      default: null
    },
    options: {
      type: Array,
      default: []
    },
    placeholder: {
      type: String,
      default: ""
    },
    size: {
      type: String,
      default: "medium",
      validator(value) {
        return ["small", "medium", "large"].includes(value);
      }
    },
    layerProps: {
      type: Object,
      default: function() {
        return {};
      }
    },
    height: {
      type: String,
      default: null
    },
    activeType: {
      type: String,
      default: "info",
      validator(value) {
        return ["info", "success", "warn", "primary", "error"].includes(value);
      }
    },
    activeColor: {
      type: String,
      default: null,
      validator(value) {
        return obj$1.common.matchingText(value, "hex");
      }
    },
    disabled: {
      type: Boolean,
      default: false
    },
    icon: {
      type: String,
      default: "caret-down"
    },
    name: {
      type: String,
      default: null
    },
    round: {
      type: Boolean,
      default: false
    },
    square: {
      type: Boolean,
      default: false
    },
    multiple: {
      type: Boolean,
      default: false
    },
    filterMethod: {
      type: Function,
      default: null
    },
    showSelected: {
      type: Boolean,
      default: true
    },
    selectedIcon: {
      type: [String, Object],
      default: "success"
    },
    clearable: {
      type: Boolean,
      default: false
    },
    props: {
      type: Object,
      default: function() {
        return {
          label: "label",
          value: "value"
        };
      }
    }
  },
  setup() {
    const instance = getCurrentInstance();
    return {
      uid: instance.uid
    };
  },
  computed: {
    formData() {
      if (this.multiple && Array.isArray(this.modelValue)) {
        return this.modelValue.join(",");
      }
      return this.modelValue;
    },
    menuStyle() {
      let style = {};
      if (this.height) {
        style.maxHeight = this.height;
      }
      return style;
    },
    selectClass() {
      let cls = ["mvi-select", this.size];
      if (this.round) {
        cls.push("round");
      } else if (this.square) {
        cls.push("square");
      }
      return cls;
    },
    targetClass() {
      let cls = ["mvi-select-target"];
      if (this.activeType && !this.activeColor && this.focus) {
        cls.push(this.activeType);
      }
      return cls;
    },
    targetStyle() {
      let style = {};
      if (this.activeColor && this.focus) {
        style.borderColor = this.activeColor;
        const rgb = obj$1.color.hex2rgb(this.activeColor);
        style.boxShadow = `0 0 0.16rem rgba(${rgb[0]},${rgb[1]},${rgb[2]},0.5)`;
      }
      return style;
    },
    iconClass() {
      let cls = ["mvi-select-icon"];
      if (this.focus) {
        cls.push("active");
      }
      return cls;
    },
    selectLabel() {
      if (this.multiple) {
        let labels = [];
        this.cmpOptions.forEach((item) => {
          if (Array.isArray(this.modelValue)) {
            let flag = this.modelValue.some((i) => {
              return obj$1.common.equal(i, item.value);
            });
            if (flag) {
              labels.push(item.label);
            }
          }
        });
        if (typeof this.filterMethod == "function") {
          return this.filterMethod(labels);
        } else {
          return labels.join(" ");
        }
      } else {
        let label = "";
        this.cmpOptions.forEach((item) => {
          if (obj$1.common.equal(this.modelValue, item.value)) {
            label = item.label;
          }
        });
        if (typeof this.filterMethod == "function") {
          return this.filterMethod(label);
        } else {
          return label;
        }
      }
    },
    isSelect() {
      return (item) => {
        if (this.multiple) {
          let flag = this.modelValue.some((i) => {
            return obj$1.common.equal(i, item.value);
          });
          return this.showSelected && flag;
        }
        return false;
      };
    },
    parseIcon() {
      return (param) => {
        let icon = {
          spin: false,
          type: null,
          url: null,
          color: null,
          size: null
        };
        if (obj$1.common.isObject(param)) {
          if (typeof param.spin == "boolean") {
            icon.spin = param.spin;
          }
          if (typeof param.type == "string") {
            icon.type = param.type;
          }
          if (typeof param.url == "string") {
            icon.url = param.url;
          }
          if (typeof param.color == "string") {
            icon.color = param.color;
          }
          if (typeof param.size == "string") {
            icon.size = param.size;
          }
        } else if (typeof param == "string") {
          icon.type = param;
        }
        return icon;
      };
    },
    showClearIcon() {
      if (this.multiple) {
        if (this.modelValue.length != 0 && this.hover) {
          return true;
        }
        return false;
      } else {
        if (this.modelValue === "" || this.modelValue === null || this.modelValue === void 0 || !this.hover) {
          return false;
        }
        return true;
      }
    },
    layerRealProps() {
      return {
        placement: this.layerProps.placement ? this.layerProps.placement : "bottom-start",
        fixed: typeof this.layerProps.fixed == "boolean" ? this.layerProps.fixed : false,
        fixedAuto: typeof this.layerProps.fixedAuto == "boolean" ? this.layerProps.fixedAuto : false,
        width: this.layerProps.width,
        zIndex: obj$1.number.isNumber(this.layerProps.zIndex) ? this.layerProps.zIndex : 400,
        offset: this.layerProps.offset ? this.layerProps.offset : "0.1rem",
        animation: this.layerProps.animation,
        timeout: obj$1.number.isNumber(this.layerProps.timeout) ? this.layerProps.timeout : 200,
        showTriangle: typeof this.layerProps.showTriangle == "boolean" ? this.layerProps.showTriangle : false,
        shadow: typeof this.layerProps.shadow == "boolean" ? this.layerProps.shadow : true,
        border: typeof this.layerProps.border == "boolean" ? this.layerProps.border : false,
        borderColor: this.layerProps.borderColor
      };
    },
    cmpOptions() {
      let options = [];
      this.options.forEach((opt) => {
        let item = {};
        if (obj$1.common.isObject(opt)) {
          item.label = opt[this.props.label];
          item.value = opt[this.props.value];
          item.disabled = !!opt.disabled;
        } else {
          item.label = opt;
          item.value = opt;
          item.disabled = false;
        }
        options.push(item);
      });
      return options;
    }
  },
  components: {
    Layer,
    Icon
  },
  methods: {
    doClear(e) {
      e.stopPropagation();
      if (this.disabled) {
        return;
      }
      if (!this.clearable) {
        return;
      }
      if (this.focus) {
        this.focus = false;
      }
      if (this.multiple) {
        this.$emit("update:modelValue", []);
        this.$emit("clear", []);
      } else {
        this.$emit("update:modelValue", null);
        this.$emit("clear", null);
      }
    },
    layerShow() {
      if (!this.layerRealProps.width) {
        this.$refs.menu.style.width = this.$refs.target.offsetWidth + "px";
      }
    },
    optionClick(item) {
      if (this.disabled || item.disabled) {
        return;
      }
      if (this.multiple) {
        let arr = this.modelValue;
        if (!Array.isArray(arr)) {
          throw new TypeError("modelValue should be an array");
        }
        let flag = arr.some((tmp) => {
          return obj$1.common.equal(tmp, item.value);
        });
        if (flag) {
          arr = arr.filter((tmp) => {
            return !obj$1.common.equal(tmp, item.value);
          });
        } else {
          arr.push(item.value);
        }
        this.$emit("update:modelValue", arr);
        this.$emit(
          "change",
          this.cmpOptions.filter((tmp) => {
            return arr.some((tmp2) => {
              return obj$1.common.equal(tmp.value, tmp2);
            });
          })
        );
      } else {
        this.$emit("update:modelValue", item.value);
        this.$emit("change", item);
      }
      this.trigger();
    },
    trigger() {
      if (this.disabled) {
        return;
      }
      this.focus = !this.focus;
    }
  }
};
const _hoisted_1$6 = ["data-id", "disabled"];
const _hoisted_2$6 = ["data-id"];
const _hoisted_3$5 = ["data-placeholder", "innerHTML"];
const _hoisted_4$4 = ["onClick", "disabled"];
const _hoisted_5$3 = ["innerHTML"];
const _hoisted_6$3 = ["value", "name"];
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_Layer = resolveComponent("Layer");
  return openBlock(), createElementBlock("div", {
    "data-id": "mvi-select-" + $setup.uid,
    class: normalizeClass($options.selectClass),
    disabled: $props.disabled || null
  }, [
    createElementVNode("div", {
      onMouseenter: _cache[0] || (_cache[0] = ($event) => $data.hover = true),
      onMouseleave: _cache[1] || (_cache[1] = ($event) => $data.hover = false),
      "data-id": "mvi-select-target-" + $setup.uid,
      class: normalizeClass($options.targetClass),
      style: normalizeStyle($options.targetStyle),
      ref: "target",
      onClick: _cache[2] || (_cache[2] = (...args) => $options.trigger && $options.trigger(...args))
    }, [
      createElementVNode("span", {
        class: normalizeClass(["mvi-select-label", $options.selectLabel ? "" : "placeholder"]),
        "data-placeholder": $props.placeholder,
        innerHTML: $options.selectLabel
      }, null, 10, _hoisted_3$5),
      $props.clearable ? withDirectives((openBlock(), createBlock(_component_Icon, {
        key: 0,
        onClick: $options.doClear,
        class: "mvi-clear-icon",
        type: "times-o"
      }, null, 8, ["onClick"])), [
        [vShow, $options.showClearIcon]
      ]) : createCommentVNode("", true),
      withDirectives(createVNode(_component_Icon, {
        class: normalizeClass($options.iconClass),
        type: $props.icon
      }, null, 8, ["class", "type"]), [
        [vShow, !$props.clearable || !$options.showClearIcon]
      ])
    ], 46, _hoisted_2$6),
    createVNode(_component_Layer, {
      modelValue: $data.focus,
      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $data.focus = $event),
      target: `[data-id='mvi-select-target-${$setup.uid}']`,
      root: `[data-id='mvi-select-${$setup.uid}']`,
      placement: $options.layerRealProps.placement,
      offset: $options.layerRealProps.offset,
      fixed: $options.layerRealProps.fixed,
      "fixed-auto": $options.layerRealProps.fixedAuto,
      "z-index": $options.layerRealProps.zIndex,
      closable: "",
      "show-triangle": $options.layerRealProps.showTriangle,
      animation: $options.layerRealProps.animation,
      timeout: $options.layerRealProps.timeout,
      shadow: $options.layerRealProps.shadow,
      border: $options.layerRealProps.border,
      "border-color": $options.layerRealProps.borderColor,
      width: $options.layerRealProps.width,
      onShowing: $options.layerShow,
      ref: "layer"
    }, {
      default: withCtx(() => [
        createElementVNode("div", {
          class: "mvi-select-menu",
          ref: "menu",
          style: normalizeStyle($options.menuStyle)
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($options.cmpOptions, (item) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(["mvi-option", $props.size]),
              onClick: ($event) => $options.optionClick(item),
              disabled: item.disabled || null
            }, [
              createElementVNode("div", {
                class: "mvi-option-value",
                innerHTML: item.label
              }, null, 8, _hoisted_5$3),
              $options.isSelect(item) ? (openBlock(), createBlock(_component_Icon, {
                key: 0,
                type: $options.parseIcon($props.selectedIcon).type,
                spin: $options.parseIcon($props.selectedIcon).spin,
                size: $options.parseIcon($props.selectedIcon).size,
                url: $options.parseIcon($props.selectedIcon).url,
                color: $options.parseIcon($props.selectedIcon).color
              }, null, 8, ["type", "spin", "size", "url", "color"])) : createCommentVNode("", true)
            ], 10, _hoisted_4$4);
          }), 256))
        ], 4)
      ]),
      _: 1
    }, 8, ["modelValue", "target", "root", "placement", "offset", "fixed", "fixed-auto", "z-index", "show-triangle", "animation", "timeout", "shadow", "border", "border-color", "width", "onShowing"]),
    createElementVNode("input", {
      type: "hidden",
      value: $options.formData,
      name: $props.name
    }, null, 8, _hoisted_6$3)
  ], 10, _hoisted_1$6);
}
const Select = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b], ["__scopeId", "data-v-bca887f2"]]);
Select.install = (app) => {
  app.component(Select.name, Select);
};
const autocomplete_vue_vue_type_style_index_0_scoped_2944b7f3_lang = "";
const _sfc_main$a = {
  name: "m-autocomplete",
  data() {
    return {
      focus: false
    };
  },
  emits: ["update:modelValue", "focus", "blur", "input", "left-click", "right-click", "select", "clear"],
  props: {
    modelValue: {
      type: String,
      default: ""
    },
    placeholder: {
      type: String,
      default: ""
    },
    size: {
      type: String,
      default: "medium",
      validator(value) {
        return ["small", "medium", "large"].includes(value);
      }
    },
    list: {
      type: Array,
      default: function() {
        return [];
      }
    },
    activeType: {
      type: String,
      default: "info",
      validator(value) {
        return ["info", "success", "warn", "error", "primary"].includes(value);
      }
    },
    activeColor: {
      type: String,
      default: null,
      validator(value) {
        return obj$1.common.matchingText(value, "hex");
      }
    },
    filterMethod: {
      type: [Function, Boolean],
      default: false
    },
    clearable: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    layerProps: {
      type: Object,
      default: function() {
        return {};
      }
    },
    height: {
      type: String,
      default: null
    },
    name: {
      type: String,
      default: null
    },
    leftIcon: {
      type: [String, Object],
      default: null
    },
    rightIcon: {
      type: [String, Object],
      default: null
    },
    round: {
      type: Boolean,
      default: false
    },
    square: {
      type: Boolean,
      default: false
    },
    align: {
      type: String,
      default: "left",
      validator(value) {
        return ["left", "right", "center"].includes(value);
      }
    }
  },
  components: {
    Icon,
    Layer
  },
  setup() {
    const instance = getCurrentInstance();
    return {
      uid: instance.uid
    };
  },
  computed: {
    show() {
      return this.focus && this.cmpFilter.length != 0;
    },
    parseIcon() {
      return (param) => {
        let icon = {
          spin: false,
          type: null,
          url: null,
          color: null,
          size: null
        };
        if (obj$1.common.isObject(param)) {
          if (typeof param.spin == "boolean") {
            icon.spin = param.spin;
          }
          if (typeof param.type == "string") {
            icon.type = param.type;
          }
          if (typeof param.url == "string") {
            icon.url = param.url;
          }
          if (typeof param.color == "string") {
            icon.color = param.color;
          }
          if (typeof param.size == "string") {
            icon.size = param.size;
          }
        } else if (typeof param == "string") {
          icon.type = param;
        }
        return icon;
      };
    },
    showClearIcon() {
      if (this.disabled) {
        return false;
      }
      if (this.realValue && this.focus) {
        return true;
      }
      return false;
    },
    clearStyle() {
      let style = {};
      if (this.parseIcon(this.rightIcon).type || this.parseIcon(this.rightIcon).url) {
        style.borderRadius = 0;
      }
      return style;
    },
    menuStyle() {
      let style = {};
      if (this.height) {
        style.maxHeight = this.height;
      }
      return style;
    },
    cmpFilter() {
      if (typeof this.filterMethod == "function") {
        return this.filterMethod(this.realValue, this.list);
      }
      if (this.filterMethod) {
        return this.defaultFilter();
      }
      return this.list;
    },
    inputStyle() {
      let style = {};
      if (this.parseIcon(this.leftIcon).type || this.parseIcon(this.leftIcon).url) {
        style.paddingLeft = 0;
      }
      if (this.showClearIcon && this.clearable || this.parseIcon(this.rightIcon).type || this.parseIcon(this.rightIcon).url) {
        style.paddingRight = 0;
      }
      if (this.align) {
        style.textAlign = this.align;
      }
      return style;
    },
    autocompleteClass() {
      let cls = ["mvi-autocomplete", this.size];
      if (this.round) {
        cls.push("round");
      } else if (this.square) {
        cls.push("square");
      }
      return cls;
    },
    targetStyle() {
      let style = {};
      if (this.activeColor && this.focus) {
        style.borderColor = this.activeColor;
        const rgb = obj$1.color.hex2rgb(this.activeColor);
        style.boxShadow = `0 0 0.16rem rgba(${rgb[0]},${rgb[1]},${rgb[2]},0.5)`;
      }
      return style;
    },
    targetClass() {
      let cls = ["mvi-autocomplete-target"];
      if (this.activeType && !this.activeColor && this.focus) {
        cls.push(this.activeType);
      }
      return cls;
    },
    realValue: {
      set(value) {
        if (this.modelValue !== value) {
          this.$emit("update:modelValue", value);
        }
      },
      get() {
        return this.modelValue;
      }
    },
    layerRealProps() {
      return {
        placement: this.layerProps.placement ? this.layerProps.placement : "bottom-start",
        fixed: typeof this.layerProps.fixed == "boolean" ? this.layerProps.fixed : false,
        fixedAuto: typeof this.layerProps.fixedAuto == "boolean" ? this.layerProps.fixedAuto : false,
        width: this.layerProps.width,
        zIndex: obj$1.number.isNumber(this.layerProps.zIndex) ? this.layerProps.zIndex : 400,
        offset: this.layerProps.offset ? this.layerProps.offset : "0.1rem",
        animation: this.layerProps.animation,
        timeout: obj$1.number.isNumber(this.layerProps.timeout) ? this.layerProps.timeout : 200,
        showTriangle: typeof this.layerProps.showTriangle == "boolean" ? this.layerProps.showTriangle : false,
        shadow: typeof this.layerProps.shadow == "boolean" ? this.layerProps.shadow : true,
        border: typeof this.layerProps.border == "boolean" ? this.layerProps.border : false,
        borderColor: this.layerProps.borderColor
      };
    }
  },
  methods: {
    layerShow() {
      if (!this.layerRealProps.width) {
        this.$refs.menu.style.width = this.$refs.target.offsetWidth + "px";
      }
    },
    rightClick(e) {
      if (this.disabled) {
        return;
      }
      this.$emit("right-click", this.realValue);
    },
    leftClick(e) {
      if (this.disabled) {
        return;
      }
      this.$emit("left-click", this.realValue);
    },
    input() {
      if (this.disabled) {
        return;
      }
      this.focus = true;
      this.$refs.layer.reset();
      this.$emit("input", this.realValue);
    },
    inputBlur() {
      if (this.disabled) {
        return;
      }
      setTimeout(() => {
        this.focus = false;
        this.$emit("blur", this.realValue);
      }, 100);
    },
    inputFocus() {
      if (this.disabled) {
        return;
      }
      this.focus = true;
      this.$emit("focus", this.realValue);
    },
    doClear() {
      if (this.disabled) {
        return;
      }
      if (!this.clearable) {
        return;
      }
      setTimeout(() => {
        this.realValue = "";
        this.$emit("clear", "");
        this.$refs.input.focus();
      }, 110);
    },
    doSelect(item) {
      if (this.disabled) {
        return;
      }
      this.realValue = item;
      this.$emit("select", item);
      this.focus = false;
    },
    defaultFilter() {
      return this.list.filter((item) => {
        return String(item).toLocaleLowerCase().includes(this.realValue.toLocaleLowerCase());
      });
    }
  }
};
const _hoisted_1$5 = ["data-id", "disabled"];
const _hoisted_2$5 = ["data-id"];
const _hoisted_3$4 = ["placeholder", "name", "disabled"];
const _hoisted_4$3 = ["textContent", "onClick"];
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_Layer = resolveComponent("Layer");
  return openBlock(), createElementBlock("div", {
    "data-id": "mvi-autocomplete-" + $setup.uid,
    class: normalizeClass($options.autocompleteClass),
    disabled: $props.disabled || null
  }, [
    createElementVNode("div", {
      class: normalizeClass($options.targetClass),
      style: normalizeStyle($options.targetStyle),
      "data-id": "mvi-autocomplete-target-" + $setup.uid,
      ref: "target"
    }, [
      $options.parseIcon($props.leftIcon).type || $options.parseIcon($props.leftIcon).url ? (openBlock(), createElementBlock("div", {
        key: 0,
        onClick: _cache[0] || (_cache[0] = (...args) => $options.leftClick && $options.leftClick(...args)),
        class: "mvi-autocomplete-left-icon"
      }, [
        createVNode(_component_Icon, {
          type: $options.parseIcon($props.leftIcon).type,
          url: $options.parseIcon($props.leftIcon).url,
          spin: $options.parseIcon($props.leftIcon).spin,
          size: $options.parseIcon($props.leftIcon).size,
          color: $options.parseIcon($props.leftIcon).color
        }, null, 8, ["type", "url", "spin", "size", "color"])
      ])) : createCommentVNode("", true),
      withDirectives(createElementVNode("input", {
        ref: "input",
        onInput: _cache[1] || (_cache[1] = (...args) => $options.input && $options.input(...args)),
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $options.realValue = $event),
        type: "text",
        placeholder: $props.placeholder,
        style: normalizeStyle($options.inputStyle),
        name: $props.name,
        onFocus: _cache[3] || (_cache[3] = (...args) => $options.inputFocus && $options.inputFocus(...args)),
        onBlur: _cache[4] || (_cache[4] = (...args) => $options.inputBlur && $options.inputBlur(...args)),
        disabled: $props.disabled || null,
        autocomplete: "off"
      }, null, 44, _hoisted_3$4), [
        [vModelText, $options.realValue]
      ]),
      $props.clearable ? withDirectives((openBlock(), createElementBlock("div", {
        key: 1,
        onClick: _cache[5] || (_cache[5] = (...args) => $options.doClear && $options.doClear(...args)),
        class: "mvi-autocomplete-clear",
        style: normalizeStyle($options.clearStyle)
      }, [
        createVNode(_component_Icon, { type: "times-o" })
      ], 4)), [
        [vShow, $options.showClearIcon]
      ]) : createCommentVNode("", true),
      $options.parseIcon($props.rightIcon).type || $options.parseIcon($props.rightIcon).url ? (openBlock(), createElementBlock("div", {
        key: 2,
        class: "mvi-autocomplete-right-icon",
        onClick: _cache[6] || (_cache[6] = (...args) => $options.rightClick && $options.rightClick(...args))
      }, [
        createVNode(_component_Icon, {
          type: $options.parseIcon($props.rightIcon).type,
          url: $options.parseIcon($props.rightIcon).url,
          spin: $options.parseIcon($props.rightIcon).spin,
          size: $options.parseIcon($props.rightIcon).size,
          color: $options.parseIcon($props.rightIcon).color
        }, null, 8, ["type", "url", "spin", "size", "color"])
      ])) : createCommentVNode("", true)
    ], 14, _hoisted_2$5),
    createVNode(_component_Layer, {
      "model-value": $options.show,
      target: `[data-id='mvi-autocomplete-target-${$setup.uid}']`,
      root: `[data-id='mvi-autocomplete-${$setup.uid}']`,
      placement: $options.layerRealProps.placement,
      offset: $options.layerRealProps.offset,
      fixed: $options.layerRealProps.fixed,
      "z-index": $options.layerRealProps.zIndex,
      "fixed-auto": $options.layerRealProps.fixedAuto,
      ref: "layer",
      animation: $options.layerRealProps.animation,
      shadow: $options.layerRealProps.shadow,
      border: $options.layerRealProps.border,
      timeout: $options.layerRealProps.timeout,
      closable: false,
      "show-triangle": $options.layerRealProps.showTriangle,
      "border-color": $options.layerRealProps.borderColor,
      width: $options.layerRealProps.width,
      onShowing: $options.layerShow
    }, {
      default: withCtx(() => [
        createElementVNode("div", {
          class: "mvi-autocomplete-menu",
          style: normalizeStyle($options.menuStyle),
          ref: "menu"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($options.cmpFilter, (item) => {
            return openBlock(), createElementBlock("div", {
              class: "mvi-autocomplete-list",
              textContent: toDisplayString(item),
              onClick: ($event) => $options.doSelect(item)
            }, null, 8, _hoisted_4$3);
          }), 256))
        ], 4)
      ]),
      _: 1
    }, 8, ["model-value", "target", "root", "placement", "offset", "fixed", "z-index", "fixed-auto", "animation", "shadow", "border", "timeout", "show-triangle", "border-color", "width", "onShowing"])
  ], 10, _hoisted_1$5);
}
const Autocomplete = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a], ["__scopeId", "data-v-2944b7f3"]]);
Autocomplete.install = (app) => {
  app.component(Autocomplete.name, Autocomplete);
};
const dateChooser_vue_vue_type_style_index_0_scoped_56d5162c_lang = "";
const _sfc_main$9 = {
  name: "m-date-chooser",
  data() {
    return {
      show: false,
      view: "date",
      selectedDate: new Date()
    };
  },
  emits: ["update:modelValue", "change"],
  props: {
    modelValue: {
      type: Date,
      default: function() {
        return new Date();
      }
    },
    disabled: {
      type: Boolean,
      default: false
    },
    layerProps: {
      type: Object,
      default: function() {
        return {};
      }
    },
    closable: {
      type: Boolean,
      default: true
    },
    trigger: {
      type: String,
      default: "click",
      validator(value) {
        return ["hover", "click", "custom"].includes(value);
      }
    },
    mode: {
      type: String,
      default: "date",
      validator(value) {
        return ["year", "month", "date"].includes(value);
      }
    },
    monthText: {
      type: Array,
      default: function() {
        return ["\u4E00\u6708", "\u4E8C\u6708", "\u4E09\u6708", "\u56DB\u6708", "\u4E94\u6708", "\u516D\u6708", "\u4E03\u6708", "\u516B\u6708", "\u4E5D\u6708", "\u5341\u6708", "\u5341\u4E00\u6708", "\u5341\u4E8C\u6708"];
      }
    },
    weekText: {
      type: Array,
      default: function() {
        return ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"];
      }
    },
    startDate: {
      type: Date,
      default: function() {
        return dayjs("1970-01-01").toDate();
      }
    },
    endDate: {
      type: Date,
      default: function() {
        return dayjs("2099-01-01").toDate();
      }
    },
    active: {
      type: Boolean,
      default: true
    },
    type: {
      type: String,
      default: "info",
      validator(value) {
        return ["info", "primary", "error", "warn", "success"].includes(value);
      }
    },
    block: {
      type: Boolean,
      default: false
    },
    headerFormatter: {
      type: Function
    }
  },
  setup() {
    const instance = getCurrentInstance();
    return {
      uid: instance.uid
    };
  },
  computed: {
    layerRealProps() {
      return {
        placement: this.layerProps.placement ? this.layerProps.placement : "bottom-start",
        fixed: typeof this.layerProps.fixed == "boolean" ? this.layerProps.fixed : false,
        fixedAuto: typeof this.layerProps.fixedAuto == "boolean" ? this.layerProps.fixedAuto : false,
        width: this.layerProps.width,
        zIndex: obj$1.number.isNumber(this.layerProps.zIndex) ? this.layerProps.zIndex : 400,
        offset: this.layerProps.offset ? this.layerProps.offset : "0.2rem",
        animation: this.layerProps.animation,
        timeout: obj$1.number.isNumber(this.layerProps.timeout) ? this.layerProps.timeout : 200,
        showTriangle: typeof this.layerProps.showTriangle == "boolean" ? this.layerProps.showTriangle : false,
        shadow: typeof this.layerProps.shadow == "boolean" ? this.layerProps.shadow : true,
        border: typeof this.layerProps.border == "boolean" ? this.layerProps.border : false,
        borderColor: this.layerProps.borderColor
      };
    },
    years() {
      let arr = [];
      const year = this.selectedDate.getFullYear();
      const startYear = this.startDate.getFullYear();
      let index = Math.floor((year - startYear) / 12);
      for (let i = startYear + index * 12; i < startYear + index * 12 + 12; i++) {
        arr.push(dayjs(this.modelValue).year(i).toDate());
      }
      return arr;
    },
    formatShow() {
      return (type, date2) => {
        if (typeof this.headerFormatter == "function") {
          if (type == "year") {
            return this.headerFormatter.apply(this, [type, date2.getFullYear()]);
          }
          if (type == "month") {
            return this.headerFormatter.apply(this, [type, date2.getMonth() + 1]);
          }
        }
        if (type == "year") {
          return dayjs(date2).format("YYYY") + "\u5E74";
        }
        if (type == "month") {
          return dayjs(date2).format("MM") + "\u6708";
        }
      };
    }
  },
  components: {
    Layer,
    Icon,
    Calendar
  },
  created() {
    this.view = this.mode;
    this.selectedDate = this.modelValue;
  },
  mounted() {
    if (this.trigger == "hover") {
      obj$1.event.on(this.$el, "mouseenter.dateChooser", this.openCalendar);
      obj$1.event.on(this.$el, "mouseleave.dateChooser", this.closeCalendar);
    }
  },
  methods: {
    layerShow() {
      if (!this.layerRealProps.width) {
        this.$refs.panel.style.width = this.$refs.target.offsetWidth + "px";
      }
    },
    clickCalendar() {
      if (this.disabled) {
        return;
      }
      if (this.trigger == "click") {
        if (this.show) {
          this.closeCalendar();
        } else {
          this.openCalendar();
        }
      }
    },
    dateClick(date2) {
      this.$emit("update:modelValue", date2);
      this.$emit("change", date2);
      this.show = false;
    },
    yearClick(date2) {
      if (this.mode == "year") {
        this.$emit("update:modelValue", date2);
        this.$emit("change", date2);
        this.show = false;
        return;
      }
      setTimeout(() => {
        this.view = "month";
      }, 0);
    },
    monthClick(date2) {
      if (this.mode == "month") {
        this.$emit("update:modelValue", date2);
        this.$emit("change", date2);
        this.show = false;
        return;
      }
      setTimeout(() => {
        this.view = "date";
      }, 0);
    },
    updateYear(num) {
      this.selectedDate = dayjs(this.selectedDate).add(num, "year").toDate();
      this.$emit("update:modelValue", this.selectedDate);
      this.$emit("change", this.selectedDate);
    },
    updateMonth(num) {
      this.selectedDate = dayjs(this.selectedDate).add(num, "month").toDate();
      this.$emit("update:modelValue", this.selectedDate);
      this.$emit("change", this.selectedDate);
    },
    goYear() {
      setTimeout(() => {
        this.view = "year";
      }, 0);
    },
    goMonth() {
      setTimeout(() => {
        this.view = "month";
      }, 0);
    },
    openCalendar() {
      if (this.disabled) {
        return;
      }
      this.show = true;
    },
    closeCalendar() {
      if (this.disabled) {
        return;
      }
      this.show = false;
    }
  },
  beforeUnmount() {
    if (this.trigger == "hover") {
      obj$1.event.off(this.$el, "mouseenter.dateChooser mouseleave.dateChooser");
    }
  }
};
const _withScopeId = (n) => (pushScopeId("data-v-56d5162c"), n = n(), popScopeId(), n);
const _hoisted_1$4 = ["data-id"];
const _hoisted_2$4 = ["data-id"];
const _hoisted_3$3 = {
  class: "mvi-date-chooser-layer",
  ref: "panel"
};
const _hoisted_4$2 = {
  key: 0,
  class: "mvi-date-chooser-year-header"
};
const _hoisted_5$2 = { class: "mvi-date-chooser-year-center" };
const _hoisted_6$2 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("span", null, "-", -1));
const _hoisted_7$2 = {
  key: 1,
  class: "mvi-date-chooser-month-header"
};
const _hoisted_8$2 = {
  key: 2,
  class: "mvi-date-chooser-date-header"
};
const _hoisted_9$2 = { class: "mvi-date-chooser-date-left" };
const _hoisted_10$2 = { class: "mvi-date-chooser-date-center" };
const _hoisted_11$1 = { class: "mvi-date-chooser-date-right" };
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_Calendar = resolveComponent("Calendar");
  const _component_Layer = resolveComponent("Layer");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["mvi-date-chooser", $props.block ? "block" : ""]),
    "data-id": `mvi-date-chooser-${$setup.uid}`
  }, [
    createElementVNode("div", {
      class: "mvi-date-chooser-target",
      "data-id": `mvi-date-chooser-target-${$setup.uid}`,
      ref: "target",
      onClick: _cache[0] || (_cache[0] = (...args) => $options.clickCalendar && $options.clickCalendar(...args))
    }, [
      renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ], 8, _hoisted_2$4),
    createVNode(_component_Layer, {
      target: `[data-id='mvi-date-chooser-target-${$setup.uid}']`,
      root: `[data-id='mvi-date-chooser-${$setup.uid}']`,
      modelValue: $data.show,
      "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => $data.show = $event),
      placement: $options.layerRealProps.placement,
      fixed: $options.layerRealProps.fixed,
      "fixed-auto": $options.layerRealProps.fixedAuto,
      offset: $options.layerRealProps.offset,
      "z-index": $options.layerRealProps.zIndex,
      shadow: $options.layerRealProps.shadow,
      border: $options.layerRealProps.border,
      animation: $options.layerRealProps.animation,
      "border-color": $options.layerRealProps.borderColor,
      timeout: $options.layerRealProps.timeout,
      closable: $props.closable,
      "show-triangle": $options.layerRealProps.showTriangle,
      width: $options.layerRealProps.width,
      onShowing: $options.layerShow
    }, {
      default: withCtx(() => [
        createElementVNode("div", _hoisted_3$3, [
          $data.view == "year" ? (openBlock(), createElementBlock("div", _hoisted_4$2, [
            createElementVNode("div", {
              class: normalizeClass(["mvi-date-chooser-year-left", $props.type]),
              onClick: _cache[1] || (_cache[1] = ($event) => $options.updateYear(-1))
            }, [
              createVNode(_component_Icon, { type: "angle-double-left" })
            ], 2),
            createElementVNode("div", _hoisted_5$2, [
              createElementVNode("span", null, toDisplayString($options.formatShow("year", $options.years[0])), 1),
              _hoisted_6$2,
              createElementVNode("span", null, toDisplayString($options.formatShow("year", $options.years[$options.years.length - 1])), 1)
            ]),
            createElementVNode("div", {
              class: normalizeClass(["mvi-date-chooser-year-right", $props.type]),
              onClick: _cache[2] || (_cache[2] = ($event) => $options.updateYear(1))
            }, [
              createVNode(_component_Icon, { type: "angle-double-right" })
            ], 2)
          ])) : $data.view == "month" ? (openBlock(), createElementBlock("div", _hoisted_7$2, [
            createElementVNode("div", {
              class: normalizeClass(["mvi-date-chooser-month-left", $props.type]),
              onClick: _cache[3] || (_cache[3] = ($event) => $options.updateYear(-1))
            }, [
              createVNode(_component_Icon, { type: "angle-double-left" })
            ], 2),
            createElementVNode("div", {
              class: normalizeClass(["mvi-date-chooser-month-center", $props.type]),
              onClick: _cache[4] || (_cache[4] = (...args) => $options.goYear && $options.goYear(...args))
            }, toDisplayString($options.formatShow("year", $data.selectedDate)), 3),
            createElementVNode("div", {
              class: normalizeClass(["mvi-date-chooser-month-right", $props.type]),
              onClick: _cache[5] || (_cache[5] = ($event) => $options.updateYear(1))
            }, [
              createVNode(_component_Icon, { type: "angle-double-right" })
            ], 2)
          ])) : $data.view == "date" ? (openBlock(), createElementBlock("div", _hoisted_8$2, [
            createElementVNode("div", _hoisted_9$2, [
              createElementVNode("div", {
                class: normalizeClass($props.type),
                onClick: _cache[6] || (_cache[6] = ($event) => $options.updateYear(-1))
              }, [
                createVNode(_component_Icon, { type: "angle-double-left" })
              ], 2),
              createElementVNode("div", {
                class: normalizeClass($props.type),
                onClick: _cache[7] || (_cache[7] = ($event) => $options.updateMonth(-1))
              }, [
                createVNode(_component_Icon, { type: "angle-left" })
              ], 2)
            ]),
            createElementVNode("div", _hoisted_10$2, [
              createElementVNode("div", {
                class: normalizeClass($props.type),
                onClick: _cache[8] || (_cache[8] = (...args) => $options.goYear && $options.goYear(...args))
              }, toDisplayString($options.formatShow("year", $data.selectedDate)), 3),
              createElementVNode("div", {
                class: normalizeClass($props.type),
                onClick: _cache[9] || (_cache[9] = (...args) => $options.goMonth && $options.goMonth(...args))
              }, toDisplayString($options.formatShow("month", $data.selectedDate)), 3)
            ]),
            createElementVNode("div", _hoisted_11$1, [
              createElementVNode("div", {
                class: normalizeClass($props.type),
                onClick: _cache[10] || (_cache[10] = ($event) => $options.updateMonth(1))
              }, [
                createVNode(_component_Icon, { type: "angle-right" })
              ], 2),
              createElementVNode("div", {
                class: normalizeClass($props.type),
                onClick: _cache[11] || (_cache[11] = ($event) => $options.updateYear(1))
              }, [
                createVNode(_component_Icon, { type: "angle-double-right" })
              ], 2)
            ])
          ])) : createCommentVNode("", true),
          createVNode(_component_Calendar, {
            view: $data.view,
            modelValue: $data.selectedDate,
            "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => $data.selectedDate = $event),
            "month-text": $props.monthText,
            "week-text": $props.weekText,
            "start-date": $props.startDate,
            "end-date": $props.endDate,
            "non-current-click": false,
            active: $props.active,
            type: $props.type,
            onDateClick: $options.dateClick,
            onMonthClick: $options.monthClick,
            onYearClick: $options.yearClick,
            ref: "calendar"
          }, null, 8, ["view", "modelValue", "month-text", "week-text", "start-date", "end-date", "active", "type", "onDateClick", "onMonthClick", "onYearClick"])
        ], 512)
      ]),
      _: 1
    }, 8, ["target", "root", "modelValue", "placement", "fixed", "fixed-auto", "offset", "z-index", "shadow", "border", "animation", "border-color", "timeout", "closable", "show-triangle", "width", "onShowing"])
  ], 10, _hoisted_1$4);
}
const DateChooser = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9], ["__scopeId", "data-v-56d5162c"]]);
DateChooser.install = (app) => {
  app.component(DateChooser.name, DateChooser);
};
const field_vue_vue_type_style_index_0_scoped_d3cbe34d_lang = "";
const _sfc_main$8 = {
  name: "m-field",
  emits: ["update:modelValue", "prepend-click", "prefix-click", "append-click", "suffix-click", "focus", "blur", "input", "clear"],
  data() {
    return {
      focus: false
    };
  },
  props: {
    modelValue: {
      type: [String, Number],
      default: ""
    },
    disabled: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    placeholder: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      default: "text",
      validator(value) {
        return ["text", "password", "number", "tel", "textarea"].includes(value);
      }
    },
    size: {
      type: String,
      default: "medium",
      validator(value) {
        return ["small", "medium", "large"].includes(value);
      }
    },
    maxlength: {
      type: Number,
      default: -1
    },
    round: {
      type: Boolean,
      default: false
    },
    square: {
      type: Boolean,
      default: false
    },
    prefix: {
      type: [String, Object],
      default: null
    },
    suffix: {
      type: [String, Object],
      default: null
    },
    prepend: {
      type: [String, Object],
      default: null
    },
    append: {
      type: [String, Object],
      default: null
    },
    activeType: {
      type: String,
      default: "info",
      validator(value) {
        return ["info", "success", "warn", "primary", "error"].includes(value);
      }
    },
    activeColor: {
      type: String,
      default: null,
      validator(value) {
        return obj$1.common.matchingText(value, "hex");
      }
    },
    clearable: {
      type: Boolean,
      default: false
    },
    align: {
      type: String,
      default: "left",
      validator(value) {
        return ["left", "center", "right"].includes(value);
      }
    },
    name: {
      type: String,
      default: null
    },
    autofocus: {
      type: Boolean,
      default: false
    },
    inputMode: {
      type: [String, Boolean],
      default: false,
      validator(value) {
        return [false, "none", "text", "decimal", "numeric", "tel", "search", "email", "url"].includes(value);
      }
    },
    rows: {
      type: Number,
      default: 1
    },
    autosize: {
      type: [Boolean, Object],
      default: false
    }
  },
  computed: {
    parseIcon() {
      return (param) => {
        let icon = {
          spin: false,
          type: null,
          url: null,
          color: null,
          size: null
        };
        if (obj$1.common.isObject(param)) {
          if (typeof param.spin == "boolean") {
            icon.spin = param.spin;
          }
          if (typeof param.type == "string") {
            icon.type = param.type;
          }
          if (typeof param.url == "string") {
            icon.url = param.url;
          }
          if (typeof param.color == "string") {
            icon.color = param.color;
          }
          if (typeof param.size == "string") {
            icon.size = param.size;
          }
        } else if (typeof param == "string") {
          icon.type = param;
        }
        return icon;
      };
    },
    showClear() {
      if (this.disabled || this.readonly) {
        return false;
      }
      if (this.realValue && this.focus) {
        return true;
      }
      return false;
    },
    clearStyle() {
      return {
        borderRadius: this.showSuffix ? 0 : "",
        paddingRight: this.showSuffix ? 0 : ""
      };
    },
    inputStyle() {
      return {
        paddingLeft: this.showPrefix ? 0 : "",
        paddingRight: this.showSuffix ? 0 : "",
        textAlign: this.align ? this.align : ""
      };
    },
    fieldBodyStyle() {
      let style = {};
      if (this.focus && this.activeColor) {
        style.borderColor = this.activeColor;
        const rgb = obj$1.color.hex2rgb(this.activeColor);
        style.boxShadow = `0 0 0.16rem rgba(${rgb[0]},${rgb[1]},${rgb[2]},0.5)`;
      }
      return style;
    },
    fieldBodyClass() {
      let cls = ["mvi-field-body"];
      if (this.showPrepend) {
        cls.push("left-none-radius");
      }
      if (this.showAppend) {
        cls.push("right-none-radius");
      }
      if (!this.activeColor && this.activeType && this.focus) {
        cls.push(this.activeType);
      }
      return cls;
    },
    fieldClass() {
      let cls = ["mvi-field", this.size];
      if (this.type == "textarea") {
        return cls;
      }
      if (this.round) {
        cls.push("round");
      } else if (this.square) {
        cls.push("square");
      }
      return cls;
    },
    cmpType() {
      if (this.type == "number") {
        return "text";
      }
      return this.type;
    },
    rowsFilter() {
      let rows = this.rows;
      if (obj$1.common.isObject(this.autosize)) {
        if (obj$1.number.isNumber(this.autosize.minRows)) {
          if (this.rows < this.autosize.minRows) {
            rows = this.autosize.minRows;
          }
        }
        if (obj$1.number.isNumber(this.autosize.maxRows)) {
          if (this.rows > this.autosize.maxRows) {
            rows = this.autosize.maxRows;
          }
        }
      }
      return rows;
    },
    realValue: {
      set(value) {
        if (this.modelValue !== value) {
          this.$emit("update:modelValue", value);
        }
      },
      get() {
        let value = this.modelValue === null ? "" : this.modelValue.toString();
        if (this.type == "number") {
          value = value.replace(/\D/g, "");
        }
        if (this.maxlength > 0 && value.length > this.maxlength) {
          value = value.substr(0, this.maxlength);
        }
        if (this.modelValue !== value) {
          this.$emit("update:modelValue", value);
        }
        return value;
      }
    },
    showPrepend() {
      if (this.type == "textarea") {
        return false;
      }
      return this.parseIcon(this.prepend).type || this.parseIcon(this.prepend).url || this.$slots.prepend;
    },
    showPrefix() {
      if (this.type == "textarea") {
        return false;
      }
      return this.parseIcon(this.prefix).type || this.parseIcon(this.prefix).url || this.$slots.prefix;
    },
    showSuffix() {
      if (this.type == "textarea") {
        return false;
      }
      return this.parseIcon(this.suffix).type || this.parseIcon(this.suffix).url || this.$slots.suffix;
    },
    showPrepend() {
      if (this.type == "textarea") {
        return false;
      }
      return this.parseIcon(this.prepend).type || this.parseIcon(this.prepend).url || this.$slots.prepend;
    },
    showAppend() {
      if (this.type == "textarea") {
        return false;
      }
      return this.parseIcon(this.append).type || this.parseIcon(this.append).url || this.$slots.append;
    }
  },
  components: {
    Icon
  },
  watch: {
    realValue() {
      this.$nextTick(() => {
        if (this.$refs.textarea && (this.autosize == true || obj$1.common.isObject(this.autosize))) {
          this.autosizeSet();
        }
      });
    },
    rows() {
      this.$nextTick(() => {
        if (this.$refs.textarea) {
          this.setMaxMinHeight();
        }
      });
    },
    autosize() {
      this.$nextTick(() => {
        if (this.$refs.textarea) {
          this.setMaxMinHeight();
        }
      });
    }
  },
  mounted() {
    if (this.$refs.textarea) {
      this.setMaxMinHeight();
      if (this.autosize == true || obj$1.common.isObject(this.autosize)) {
        this.autosizeSet();
      }
    }
  },
  methods: {
    autosizeSet() {
      this.$refs.textarea.style.overflow = "hidden";
      this.$refs.textarea.style.height = "auto";
      this.$refs.textarea.scrollTop = 0;
      this.$refs.textarea.style.height = obj$1.element.getScrollHeight(this.$refs.textarea) + "px";
    },
    rows2Height(rows) {
      let lineHeight = Math.floor(parseFloat(obj$1.element.getCssStyle(this.$refs.textarea, "line-height")));
      return rows * lineHeight;
    },
    setMaxMinHeight() {
      if (obj$1.common.isObject(this.autosize)) {
        if (obj$1.number.isNumber(this.autosize.maxRows)) {
          let maxHeight = this.rows2Height(this.autosize.maxRows) + parseFloat(obj$1.element.getCssStyle(this.$refs.textarea, "padding-top")) + parseFloat(obj$1.element.getCssStyle(this.$refs.textarea, "padding-bottom"));
          this.$refs.textarea.style.maxHeight = maxHeight + "px";
        }
        if (obj$1.number.isNumber(this.autosize.minRows)) {
          let minHeight = this.rows2Height(this.autosize.minRows) + parseFloat(obj$1.element.getCssStyle(this.$refs.textarea, "padding-top")) + parseFloat(obj$1.element.getCssStyle(this.$refs.textarea, "padding-bottom"));
          this.$refs.textarea.style.minHeight = minHeight + "px";
        }
      } else {
        this.$refs.textarea.style.maxHeight = "";
        this.$refs.textarea.style.minHeight = "";
      }
    },
    inputFocus() {
      if (this.disabled) {
        return;
      }
      this.focus = true;
      this.$emit("focus", this.realValue);
    },
    inputBlur() {
      if (this.disabled) {
        return;
      }
      setTimeout(() => {
        this.focus = false;
        this.$emit("blur", this.realValue);
      }, 100);
    },
    input() {
      if (this.disabled) {
        return;
      }
      this.$emit("input", this.realValue);
    },
    prependClick() {
      if (this.disabled) {
        return;
      }
      this.$emit("prepend-click", this.realValue);
    },
    prefixClick() {
      if (this.disabled) {
        return;
      }
      this.$emit("prefix-click", this.realValue);
    },
    appendClick() {
      if (this.disabled) {
        return;
      }
      this.$emit("append-click", this.realValue);
    },
    suffixClick() {
      if (this.disabled) {
        return;
      }
      this.$emit("suffix-click", this.realValue);
    },
    doClear() {
      if (this.disabled) {
        return;
      }
      if (!this.clearable) {
        return;
      }
      setTimeout(() => {
        this.realValue = "";
        let el = this.$refs.input || this.$refs.textarea;
        el.focus();
        this.$emit("clear", this.realValue);
      }, 110);
    }
  }
};
const _hoisted_1$3 = ["disabled", "data-type"];
const _hoisted_2$3 = ["disabled", "readonly", "placeholder", "maxlength", "name", "autofocus", "rows"];
const _hoisted_3$2 = ["disabled", "readonly", "type", "placeholder", "inputmode", "maxlength", "name", "autofocus"];
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass($options.fieldClass),
    disabled: $props.disabled || null,
    "data-type": $props.type
  }, [
    $options.showPrepend ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "mvi-field-prepend",
      onClick: _cache[0] || (_cache[0] = (...args) => $options.prependClick && $options.prependClick(...args))
    }, [
      _ctx.$slots.prepend ? renderSlot(_ctx.$slots, "prepend", { key: 0 }, void 0, true) : (openBlock(), createBlock(_component_Icon, {
        key: 1,
        type: $options.parseIcon(this.prepend).type,
        url: $options.parseIcon(this.prepend).url,
        spin: $options.parseIcon(this.prepend).spin,
        size: $options.parseIcon(this.prepend).size,
        color: $options.parseIcon(this.prepend).color
      }, null, 8, ["type", "url", "spin", "size", "color"]))
    ])) : createCommentVNode("", true),
    createElementVNode("div", {
      class: normalizeClass($options.fieldBodyClass),
      style: normalizeStyle($options.fieldBodyStyle)
    }, [
      $options.showPrefix ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "mvi-field-prefix",
        onClick: _cache[1] || (_cache[1] = (...args) => $options.prefixClick && $options.prefixClick(...args))
      }, [
        _ctx.$slots.prefix ? renderSlot(_ctx.$slots, "prefix", { key: 0 }, void 0, true) : (openBlock(), createBlock(_component_Icon, {
          key: 1,
          type: $options.parseIcon(this.prefix).type,
          url: $options.parseIcon(this.prefix).url,
          spin: $options.parseIcon(this.prefix).spin,
          size: $options.parseIcon(this.prefix).size,
          color: $options.parseIcon(this.prefix).color
        }, null, 8, ["type", "url", "spin", "size", "color"]))
      ])) : createCommentVNode("", true),
      $props.type == "textarea" ? withDirectives((openBlock(), createElementBlock("textarea", {
        key: 1,
        ref: "textarea",
        disabled: $props.disabled || null,
        readonly: $props.readonly || null,
        class: "mvi-field-input",
        style: normalizeStyle($options.inputStyle),
        placeholder: $props.placeholder,
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $options.realValue = $event),
        autocomplete: "off",
        onFocus: _cache[3] || (_cache[3] = (...args) => $options.inputFocus && $options.inputFocus(...args)),
        onBlur: _cache[4] || (_cache[4] = (...args) => $options.inputBlur && $options.inputBlur(...args)),
        maxlength: $props.maxlength,
        name: $props.name,
        autofocus: $props.autofocus,
        rows: $options.rowsFilter,
        onInput: _cache[5] || (_cache[5] = (...args) => $options.input && $options.input(...args))
      }, null, 44, _hoisted_2$3)), [
        [vModelText, $options.realValue]
      ]) : withDirectives((openBlock(), createElementBlock("input", {
        key: 2,
        ref: "input",
        disabled: $props.disabled || null,
        readonly: $props.readonly || null,
        class: "mvi-field-input",
        style: normalizeStyle($options.inputStyle),
        type: $options.cmpType,
        placeholder: $props.placeholder,
        "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $options.realValue = $event),
        autocomplete: "off",
        inputmode: $props.inputMode,
        onFocus: _cache[7] || (_cache[7] = (...args) => $options.inputFocus && $options.inputFocus(...args)),
        onBlur: _cache[8] || (_cache[8] = (...args) => $options.inputBlur && $options.inputBlur(...args)),
        maxlength: $props.maxlength,
        name: $props.name,
        autofocus: $props.autofocus,
        onInput: _cache[9] || (_cache[9] = (...args) => $options.input && $options.input(...args))
      }, null, 44, _hoisted_3$2)), [
        [vModelDynamic, $options.realValue]
      ]),
      $props.clearable && $props.type != "textarea" ? withDirectives((openBlock(), createElementBlock("div", {
        key: 3,
        class: "mvi-field-clear",
        style: normalizeStyle($options.clearStyle),
        onClick: _cache[10] || (_cache[10] = (...args) => $options.doClear && $options.doClear(...args))
      }, [
        createVNode(_component_Icon, { type: "times-o" })
      ], 4)), [
        [vShow, $options.showClear]
      ]) : createCommentVNode("", true),
      $options.showSuffix ? (openBlock(), createElementBlock("div", {
        key: 4,
        class: "mvi-field-suffix",
        onClick: _cache[11] || (_cache[11] = (...args) => $options.suffixClick && $options.suffixClick(...args))
      }, [
        _ctx.$slots.suffix ? renderSlot(_ctx.$slots, "suffix", { key: 0 }, void 0, true) : (openBlock(), createBlock(_component_Icon, {
          key: 1,
          type: $options.parseIcon(this.suffix).type,
          url: $options.parseIcon(this.suffix).url,
          spin: $options.parseIcon(this.suffix).spin,
          size: $options.parseIcon(this.suffix).size,
          color: $options.parseIcon(this.suffix).color
        }, null, 8, ["type", "url", "spin", "size", "color"]))
      ])) : createCommentVNode("", true)
    ], 6),
    $options.showAppend ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: "mvi-field-append",
      onClick: _cache[12] || (_cache[12] = (...args) => $options.appendClick && $options.appendClick(...args))
    }, [
      _ctx.$slots.append ? renderSlot(_ctx.$slots, "append", { key: 0 }, void 0, true) : (openBlock(), createBlock(_component_Icon, {
        key: 1,
        type: $options.parseIcon(this.append).type,
        url: $options.parseIcon(this.append).url,
        spin: $options.parseIcon(this.append).spin,
        size: $options.parseIcon(this.append).size,
        color: $options.parseIcon(this.append).color
      }, null, 8, ["type", "url", "spin", "size", "color"]))
    ])) : createCommentVNode("", true)
  ], 10, _hoisted_1$3);
}
const Field = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8], ["__scopeId", "data-v-d3cbe34d"]]);
Field.install = (app) => {
  app.component(Field.name, Field);
};
var __defProp = Object.defineProperty;
var __defNormalProp = (obj2, key, value) => key in obj2 ? __defProp(obj2, key, { enumerable: true, configurable: true, writable: true, value }) : obj2[key] = value;
var __publicField = (obj2, key, value) => {
  __defNormalProp(obj2, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const number = {
  formatNumber(num) {
    if (this.isNumber(num)) {
      return num.toString().replace(/(\d)(?=(?:\d{3})+$)/g, "$1,");
    } else {
      return num;
    }
  },
  isNumber(num) {
    if (typeof num == "number" && !isNaN(num)) {
      return true;
    } else {
      return false;
    }
  },
  add(...values) {
    return values.reduce((num, value) => {
      let r1 = 0;
      let r2 = 0;
      let m = 0;
      try {
        r1 = num.toString().split(".")[1].length;
      } catch (e) {
      }
      try {
        r2 = value.toString().split(".")[1].length;
      } catch (e) {
      }
      m = Math.pow(10, Math.max(r1, r2));
      return (num * m + value * m) / m;
    });
  },
  subtract(...values) {
    return values.reduce((num, value) => {
      let r1 = 0;
      let r2 = 0;
      let m = 0;
      try {
        r1 = num.toString().split(".")[1].length;
      } catch (e) {
      }
      try {
        r2 = value.toString().split(".")[1].length;
      } catch (e) {
      }
      m = Math.pow(10, Math.max(r1, r2));
      return (num * m - value * m) / m;
    });
  },
  mutiply(...values) {
    return values.reduce((num, value) => {
      let m = 0;
      let s1 = num.toString();
      let s2 = value.toString();
      try {
        m += s1.split(".")[1].length;
      } catch (e) {
      }
      try {
        m += s2.split(".")[1].length;
      } catch (e) {
      }
      return Number(s1.replace(".", "")) * Number(s2.replace(".", "")) / Math.pow(10, m);
    });
  },
  divide(...values) {
    return values.reduce((num, value) => {
      let t1 = 0;
      let t2 = 0;
      let s1 = num.toString();
      let s2 = value.toString();
      try {
        t1 = s1.split(".")[1].length;
      } catch (e) {
      }
      try {
        t2 = s2.split(".")[1].length;
      } catch (e) {
      }
      s1 = Number(s1.replace(".", ""));
      s2 = Number(s2.replace(".", ""));
      return s1 / s2 * Math.pow(10, t2 - t1);
    });
  }
};
const string = {
  insert(original, str, index) {
    if (!original || typeof original != "string") {
      throw new TypeError("The first argument must be a string");
    }
    if (typeof str != "string") {
      throw new TypeError("The second argument must be a string");
    }
    if (!number.isNumber(index)) {
      throw new TypeError("The third argument must be a number");
    }
    if (index < 0) {
      throw new Error("The third argument cannot be less than 0");
    }
    return original.substring(0, index) + str + original.substring(index, original.length);
  },
  delete(original, index, num) {
    if (!original || typeof original != "string") {
      throw new TypeError("The first argument must be a string");
    }
    if (!number.isNumber(index)) {
      throw new TypeError("The second argument must be a number");
    }
    if (index < 0) {
      throw new Error("The second argument cannot be less than 0");
    }
    if (!number.isNumber(num)) {
      throw new TypeError("The third argument must be a number");
    }
    if (num < 0) {
      throw new Error("The third argument cannot be less than 0");
    }
    return original.substring(0, index) + original.substring(index + num, original.length);
  },
  replace(original, start, end, str) {
    if (!original || typeof original != "string") {
      throw new TypeError("The first argument must be a string");
    }
    if (!number.isNumber(start)) {
      throw new TypeError("The second argument must be a number");
    }
    if (start < 0) {
      throw new Error("The second argument cannot be less than 0");
    }
    if (!number.isNumber(end)) {
      throw new TypeError("The third argument must be a number");
    }
    if (end < 0) {
      throw new Error("The third argument cannot be less than 0");
    }
    if (typeof str != "string") {
      throw new TypeError("The fourth argument must be a string");
    }
    return original.substring(0, start) + str + original.substring(end, original.length);
  },
  trim(str, global2) {
    if (typeof str != "string") {
      throw new TypeError("The first argument must be a string");
    }
    let result = str.replace(/(^\s+)|(\s+$)/g, "");
    if (global2) {
      result = result.replace(/\s/g, "");
    }
    return result;
  }
};
const element = {
  isWindow(data2) {
    return data2 && data2 instanceof Window;
  },
  getElementPoint(el, root) {
    if (!this.isElement(el)) {
      throw new TypeError("The first argument must be an element");
    }
    if (!this.isElement(root)) {
      root = document.body;
    }
    if (!this.isContains(root, el)) {
      throw new Error("The second argument and the first argument have no hierarchical relationship");
    }
    let obj2 = el;
    let offsetTop = 0;
    let offsetLeft = 0;
    while (this.isElement(el) && this.isContains(root, el) && root !== el) {
      offsetTop += el.offsetTop;
      offsetLeft += el.offsetLeft;
      el = el.offsetParent;
    }
    let offsetRight = root.offsetWidth - offsetLeft - obj2.offsetWidth;
    let offsetBottom = root.offsetHeight - offsetTop - obj2.offsetHeight;
    return {
      top: offsetTop,
      left: offsetLeft,
      right: offsetRight,
      bottom: offsetBottom
    };
  },
  isContains(parentNode, childNode) {
    if (!this.isElement(parentNode)) {
      throw new TypeError("The first argument must be an element");
    }
    if (!this.isElement(childNode, true)) {
      throw new TypeError("The second argument must be an element");
    }
    if (parentNode === childNode) {
      return true;
    }
    if (parentNode.contains) {
      return parentNode.contains(childNode);
    }
    if (parentNode.compareDocumentPosition) {
      return !!(parentNode.compareDocumentPosition(childNode) & 16);
    }
  },
  isParentNode(parentNode, childNode) {
    if (!this.isElement(parentNode)) {
      throw new TypeError("The first argument must be an element");
    }
    if (!this.isElement(childNode, true)) {
      throw new TypeError("The second argument must be an element");
    }
    if (parentNode === childNode) {
      return false;
    }
    return childNode.parentNode === parentNode;
  },
  children(el, selector) {
    if (!this.isElement(el)) {
      throw new TypeError("The first argument must be an element");
    }
    if (selector && typeof selector != "string") {
      throw new TypeError("The second argument must be a string");
    }
    const res = el.querySelectorAll(selector || "*");
    return [...res].filter((ele) => {
      return ele.parentNode === el;
    });
  },
  siblings(el, selector) {
    if (!this.isElement(el)) {
      throw new TypeError("The first argument must be an element");
    }
    if (selector && typeof selector != "string") {
      throw new TypeError("The second argument must be a string");
    }
    if (!el.parentNode) {
      return [];
    }
    const res = el.parentNode.querySelectorAll(selector || "*");
    return [...res].filter((ele) => {
      return ele.parentNode === el.parentNode && ele != el;
    });
  },
  rem2px(num) {
    if (!number.isNumber(num)) {
      throw new TypeError("The argument must be a number");
    }
    let fs = this.getCssStyle(document.documentElement, "font-size");
    return number.mutiply(num, parseFloat(fs));
  },
  px2rem(num) {
    if (!number.isNumber(num)) {
      throw new TypeError("The argument must be a number");
    }
    let fs = this.getCssStyle(document.documentElement, "font-size");
    return number.divide(num, parseFloat(fs));
  },
  width(el) {
    if (typeof el == "string" && el) {
      el = document.body.querySelector(el);
    }
    if (!this.isElement(el)) {
      el = document.body;
    }
    let clientWidth = el.clientWidth;
    let paddingLeft_width = parseFloat(this.getCssStyle(el, "padding-left"));
    let paddingRight_width = parseFloat(this.getCssStyle(el, "padding-right"));
    return number.subtract(clientWidth, paddingLeft_width, paddingRight_width);
  },
  height(el) {
    if (typeof el == "string" && el) {
      el = document.body.querySelector(el);
    }
    if (!this.isElement(el)) {
      el = document.body;
    }
    let clientHeight = el.clientHeight;
    let paddingTop_height = parseFloat(this.getCssStyle(el, "padding-top"));
    let paddingBottom_height = parseFloat(this.getCssStyle(el, "padding-bottom"));
    return number.subtract(clientHeight, paddingTop_height, paddingBottom_height);
  },
  removeClass(el, className) {
    if (!this.isElement(el)) {
      throw new TypeError("The first argument must be an element");
    }
    if (!className || typeof className != "string") {
      throw new TypeError("The second argument must be a string");
    }
    let classList = el.classList;
    let classArray = string.trim(className).split(/\s+/);
    classArray.forEach((item, index) => {
      classList.remove(item);
    });
  },
  addClass(el, className) {
    if (!this.isElement(el)) {
      throw new TypeError("The first argument must be an element");
    }
    if (!className || typeof className != "string") {
      throw new TypeError("The second argument must be a string");
    }
    let classList = el.classList;
    let classArray = string.trim(className).split(/\s+/);
    classArray.forEach((item, index) => {
      classList.add(item);
    });
  },
  hasClass(el, className) {
    if (!this.isElement(el)) {
      throw new TypeError("The first argument must be an element");
    }
    if (!className || typeof className != "string") {
      throw new TypeError("The second argument must be a string");
    }
    let classList = el.classList;
    let classArray = string.trim(className).split(/\s+/);
    return classArray.every((item, index) => {
      return classList.contains(item);
    });
  },
  scrollTopBottomTrigger(el, callback) {
    if (typeof el == "string" && el) {
      el = document.body.querySelector(el);
    }
    let scrollEle = window;
    if (this.isElement(el) && el != document.body && el != document.documentElement) {
      scrollEle = el;
    }
    if (typeof el == "function") {
      callback = el;
    }
    let flag = true;
    scrollEle.addEventListener("scroll", (e) => {
      if (this.getScrollTop(scrollEle) <= 0) {
        let options = {
          state: "top",
          target: scrollEle
        };
        if (!flag) {
          return;
        }
        if (typeof callback == "function") {
          flag = false;
          callback(options);
        }
      } else {
        let options = {
          state: "bottom",
          target: scrollEle
        };
        let height = 0;
        if (scrollEle == window) {
          height = window.innerHeight;
        } else {
          height = scrollEle.clientHeight;
        }
        if (number.add(this.getScrollTop(scrollEle), height) + 1 >= this.getScrollHeight(scrollEle) && height != this.getScrollHeight(scrollEle)) {
          if (!flag) {
            return;
          }
          if (typeof callback == "function") {
            flag = false;
            callback(options);
          }
        } else {
          flag = true;
        }
      }
    });
  },
  getScrollWidth(el) {
    if (typeof el == "string" && el) {
      el = document.body.querySelector(el);
    }
    let scrollWidth = 0;
    if (this.isElement(el) && el != document.documentElement && el != document.body) {
      scrollWidth = el.scrollWidth;
    } else {
      if (document.documentElement.scrollWidth == 0 || document.body.scrollWidth == 0) {
        scrollWidth = document.documentElement.scrollWidth || document.body.scrollWidth;
      } else {
        scrollWidth = document.documentElement.scrollWidth > document.body.scrollWidth ? document.documentElement.scrollWidth : document.body.scrollWidth;
      }
    }
    return scrollWidth;
  },
  getScrollHeight(el) {
    if (typeof el == "string" && el) {
      el = document.body.querySelector(el);
    }
    let scrollHeight = 0;
    if (this.isElement(el) && el != document.documentElement && el != document.body) {
      scrollHeight = el.scrollHeight;
    } else {
      if (document.documentElement.scrollHeight == 0 || document.body.scrollHeight == 0) {
        scrollHeight = document.documentElement.scrollHeight || document.body.scrollHeight;
      } else {
        scrollHeight = document.documentElement.scrollHeight > document.body.scrollHeight ? document.documentElement.scrollHeight : document.body.scrollHeight;
      }
    }
    return scrollHeight;
  },
  setScrollTop(options) {
    let isWindow = false;
    let el = options.el;
    if (typeof el == "string" && el) {
      el = document.body.querySelector(el);
    }
    let number$12 = options.number || 0;
    let time = options.time || 0;
    if (!this.isElement(el) || el == document.body || el == document.documentElement || el == window) {
      isWindow = true;
    }
    return new Promise((resolve, reject) => {
      if (time <= 0) {
        if (isWindow) {
          document.documentElement.scrollTop = document.body.scrollTop = number$12;
        } else {
          el.scrollTop = number$12;
        }
        resolve();
      } else {
        let spacingTime = 10;
        let spacingIndex = number.divide(time, spacingTime);
        let nowTop = this.getScrollTop(el);
        let everTop = number.divide(number.subtract(number$12, nowTop), spacingIndex);
        let scrollTimer = setInterval(() => {
          if (spacingIndex > 0) {
            spacingIndex--;
            if (isWindow) {
              document.documentElement.scrollTop = document.body.scrollTop = nowTop = number.add(nowTop, everTop);
            } else {
              el.scrollTop = nowTop = number.add(nowTop, everTop);
            }
          } else {
            clearInterval(scrollTimer);
            resolve();
          }
        }, spacingTime);
      }
    });
  },
  getScrollTop(el) {
    if (typeof el == "string" && el) {
      el = document.body.querySelector(el);
    }
    let scrollTop = 0;
    if (this.isElement(el) && el != document.body && el != document.documentElement && el != window) {
      scrollTop = el.scrollTop;
    } else {
      if (document.documentElement.scrollTop == 0 || document.body.scrollTop == 0) {
        scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
      } else {
        scrollTop = document.documentElement.scrollTop > document.body.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop;
      }
    }
    return scrollTop;
  },
  getScrollLeft(el) {
    if (typeof el == "string" && el) {
      el = document.body.querySelector(el);
    }
    let scrollLeft = 0;
    if (this.isElement(el) && el != document.body && el != document.documentElement && el != window) {
      scrollLeft = el.scrollLeft;
    } else {
      if (document.documentElement.scrollLeft == 0 || document.body.scrollLeft == 0) {
        scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;
      } else {
        scrollLeft = document.documentElement.scrollLeft > document.body.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft;
      }
    }
    return scrollLeft;
  },
  setScrollLeft(options) {
    let isWindow = false;
    let el = options.el;
    if (typeof el == "string" && el) {
      el = document.body.querySelector(el);
    }
    let number$12 = options.number || 0;
    let time = options.time || 0;
    if (!this.isElement(el) || el == document.body || el == document.documentElement || el == window) {
      isWindow = true;
    }
    return new Promise((resolve, reject) => {
      if (time <= 0) {
        if (isWindow) {
          document.documentElement.scrollLeft = document.body.scrollLeft = number$12;
        } else {
          el.scrollLeft = number$12;
        }
        resolve();
      } else {
        let spacingTime = 10;
        let spacingIndex = number.divide(time, spacingTime);
        let nowLeft = this.getScrollLeft(el);
        let everLeft = number.divide(number.subtract(number$12, nowLeft), spacingIndex);
        let scrollTimer = setInterval(() => {
          if (spacingIndex > 0) {
            spacingIndex--;
            if (isWindow) {
              document.documentElement.scrollLeft = document.body.scrollLeft = nowLeft = number.add(nowLeft, everLeft);
            } else {
              el.scrollLeft = nowLeft = number.add(nowLeft, everLeft);
            }
          } else {
            clearInterval(scrollTimer);
            resolve();
          }
        }, spacingTime);
      }
    });
  },
  getCssStyle(el, cssName) {
    if (!this.isElement(el)) {
      throw new TypeError("The first argument must be an element");
    }
    if (!cssName || typeof cssName != "string") {
      throw new TypeError("The second argument must be a string");
    }
    let cssText = "";
    if (document.defaultView && document.defaultView.getComputedStyle) {
      cssText = document.defaultView.getComputedStyle(el)[cssName];
    } else {
      cssText = el.currentStyle[cssName];
    }
    return cssText;
  },
  getCssSelector(selector) {
    if (!selector || typeof selector != "string") {
      throw new TypeError("The argument must be a selector string");
    }
    if (/^#{1}/.test(selector)) {
      return {
        type: "id",
        value: selector.substr(1)
      };
    }
    if (/^\./.test(selector)) {
      return {
        type: "class",
        value: selector.substr(1)
      };
    }
    if (/^\[(.+)\]$/.test(selector)) {
      let type = "attribute";
      let value = "";
      let attribute = string.trim(selector, true).substring(1, string.trim(selector, true).length - 1);
      let arry = attribute.split("=");
      if (arry.length == 1) {
        value = arry[0];
      }
      if (arry.length == 2) {
        value = {
          attributeName: arry[0],
          attributeValue: arry[1].replace(/\'/g, "").replace(/\"/g, "")
        };
      }
      return {
        type,
        value
      };
    }
    return {
      type: "tag",
      value: selector
    };
  },
  getElementBounding(el) {
    if (typeof el == "string" && el) {
      el = document.body.querySelector(el);
    }
    if (!this.isElement(el)) {
      el = document.body;
    }
    let point = el.getBoundingClientRect();
    let top = point.top;
    let bottom = number.subtract(document.documentElement.clientHeight || window.innerHeight, point.bottom);
    let left = point.left;
    let right = number.subtract(document.documentElement.clientWidth || window.innerWidth, point.right);
    return {
      top,
      bottom,
      left,
      right
    };
  },
  isElement(el) {
    return el && el instanceof Node && el.nodeType === 1;
  },
  string2dom(str, parentTag = "div") {
    if (!str || typeof str != "string") {
      throw new TypeError("The argument must be an HTML string");
    }
    let parentEle = document.createElement(parentTag);
    parentEle.innerHTML = str;
    if (parentEle.children.length == 1) {
      return parentEle.children[0];
    } else {
      return parentEle.children;
    }
  }
};
const dataName = "_dap-datas";
const data = {
  remove(el, key) {
    if (!(el instanceof Document) && !element.isElement(el) && !element.isWindow(el)) {
      throw new TypeError("The first argument must be an element node or window or document");
    }
    let data2 = el[dataName] || {};
    if (key === void 0 || key === null || key === "") {
      el[dataName] = {};
    } else {
      delete data2[key];
      el[dataName] = data2;
    }
  },
  has(el, key) {
    if (!(el instanceof Document) && !element.isElement(el) && !element.isWindow(el)) {
      throw new TypeError("The first argument must be an element node or window or document");
    }
    if (key === void 0 || key === null || key === "") {
      throw new TypeError("The second parameter must be a unique key");
    }
    let data2 = el[dataName] || {};
    return data2.hasOwnProperty(key);
  },
  get(el, key) {
    if (!(el instanceof Document) && !element.isElement(el) && !element.isWindow(el)) {
      throw new TypeError("The first argument must be an element node or window or document");
    }
    let data2 = el[dataName] || {};
    if (key === void 0 || key === null || key === "") {
      return data2;
    } else {
      return data2[key];
    }
  },
  set(el, key, value) {
    if (!(el instanceof Document) && !element.isElement(el) && !element.isWindow(el)) {
      throw new TypeError("The first argument must be an element node or window or document");
    }
    if (key === void 0 || key === null || key === "") {
      throw new TypeError("The second parameter must be a unique key");
    }
    let data2 = el[dataName] || {};
    data2[key] = value;
    el[dataName] = data2;
  }
};
const common = {
  matchingText(text, params) {
    if (!text || typeof text != "string") {
      throw new TypeError("The first argument must be a string");
    }
    if (!params || typeof params != "string") {
      throw new TypeError("The second argument must be a string");
    }
    let reg = null;
    if (params == "Chinese") {
      reg = /^[\u4e00-\u9fa5]+$/;
    }
    if (params == "chinese") {
      reg = /[\u4e00-\u9fa5]/;
    }
    if (params == "email") {
      reg = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/;
    }
    if (params == "userName") {
      reg = /^[a-zA-Z0-9_]{4,16}$/;
    }
    if (params == "int+") {
      reg = /^\d+$/;
    }
    if (params == "int-") {
      reg = /^-\d+$/;
    }
    if (params == "int") {
      reg = /^-?\d+$/;
    }
    if (params == "pos") {
      reg = /^\d*\.?\d+$/;
    }
    if (params == "neg") {
      reg = /^-\d*\.?\d+$/;
    }
    if (params == "number") {
      reg = /^-?\d*\.?\d+$/;
    }
    if (params == "phone") {
      reg = /^1[0-9]\d{9}$/;
    }
    if (params == "idCard") {
      reg = /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;
    }
    if (params == "url") {
      reg = /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;
    }
    if (params == "IPv4") {
      reg = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
    }
    if (params == "hex") {
      reg = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;
    }
    if (params == "date") {
      let reg1 = /^((\d{4})(-)(\d{2})(-)(\d{2}))$/;
      let reg2 = /^(\d{4})(\/)(\d{2})(\/)(\d{2})$/;
      let reg3 = /^(\d{4})(\.)(\d{2})(\.)(\d{2})$/;
      let reg4 = /^(\d{4})(年)(\d{2})(月)(\d{2})(日)$/;
      return reg1.test(text) || reg2.test(text) || reg3.test(text) || reg4.test(text);
    }
    if (params == "time") {
      reg = /^(20|21|22|23|[0-1]\d):[0-5]\d:[0-5]\d$/;
    }
    if (params == "QQ") {
      reg = /^[1-9][0-9]{4,10}$/;
    }
    if (params == "weixin") {
      reg = /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/;
    }
    if (params == "plate") {
      reg = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/;
    }
    if (!reg) {
      throw new Error("The second parameter is out of scope");
    }
    return reg.test(text);
  },
  getUrlParams(name) {
    if (!name || typeof name != "string") {
      throw new TypeError("The argument must be a string");
    }
    let reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)");
    let search = window.location.search.substr(1);
    if (!search) {
      let arr = window.location.hash.split("?");
      if (arr.length == 2) {
        search = arr[1];
      }
    }
    let r = search.match(reg);
    if (r) {
      return decodeURIComponent(r[2]);
    }
    return null;
  },
  isEmptyObject(obj2) {
    if (this.isObject(obj2)) {
      if (Object.keys(obj2).length == 0) {
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  },
  equal(a, b) {
    if (typeof a !== typeof b) {
      return false;
    }
    if (this.isObject(a) && this.isObject(b)) {
      a = Object.assign({}, a);
      b = Object.assign({}, b);
      let aProps = Object.getOwnPropertyNames(a);
      let bProps = Object.getOwnPropertyNames(b);
      if (aProps.length != bProps.length) {
        return false;
      }
      let length = aProps.length;
      for (let i = 0; i < length; i++) {
        let propName = aProps[i];
        let propA = a[propName];
        let propB = b[propName];
        if (this.isObject(propA)) {
          if (this.equal(propA, propB)) {
            return true;
          } else {
            return false;
          }
        } else if (propA !== propB) {
          return false;
        }
      }
      return true;
    } else {
      return a === b;
    }
  },
  isObject(val) {
    if (typeof val === "object" && val) {
      return true;
    }
    return false;
  },
  copyText(text) {
    if (!text || typeof text != "string") {
      throw new TypeError("No text to copy is defined");
    }
    let el = element.string2dom('<input type="text" />');
    document.body.appendChild(el);
    el.value = text;
    el.select();
    document.execCommand("copy");
    document.body.removeChild(el);
  }
};
const parseEventName = (eventName) => {
  let eventNames = eventName.split(/[\s]+/g);
  let result = [];
  eventNames.forEach((name) => {
    let arr = name.split(".");
    let obj2 = {
      eventName: arr[0]
    };
    if (arr.length > 1) {
      obj2.guid = arr[1];
    }
    result.push(obj2);
  });
  return result;
};
const updateEvents = (events) => {
  let obj2 = {};
  let keys = Object.keys(events);
  keys.forEach((key) => {
    if (events[key]) {
      obj2[key] = events[key];
    }
  });
  return obj2;
};
const bindSingleListener = (el, eventName, guid, fn, options) => {
  let events = data.get(el, "dap-defined-events") || {};
  if (!guid) {
    guid = data.get(el, "dap-event-guid") || 0;
    data.set(el, "dap-event-guid", guid + 1);
  }
  guid = eventName + "." + guid;
  if (events[guid] && events[guid].type == eventName) {
    el.removeEventListener(eventName, events[guid].fn, events[guid].options);
  }
  el.addEventListener(eventName, fn, options);
  events[guid] = {
    type: eventName,
    fn,
    options
  };
  data.set(el, "dap-defined-events", events);
};
const unbindSingleListener = (el, eventName, guid) => {
  let events = data.get(el, "dap-defined-events") || {};
  let keys = Object.keys(events);
  let length = keys.length;
  for (let i = 0; i < length; i++) {
    let key = keys[i];
    if (events[key].type == eventName) {
      if (guid) {
        if (key == eventName + "." + guid) {
          el.removeEventListener(events[key].type, events[key].fn, events[key].options);
          events[key] = void 0;
        }
      } else {
        el.removeEventListener(events[key].type, events[key].fn, events[key].options);
        events[key] = void 0;
      }
    }
  }
  events = updateEvents(events);
  data.set(el, "dap-defined-events", events);
};
const event = {
  on(el, eventName, fn, options) {
    if (!(el instanceof Document) && !element.isElement(el) && !element.isWindow(el)) {
      throw new TypeError("The first argument must be an element node or window or document");
    }
    if (!eventName || typeof eventName != "string") {
      throw new TypeError("The second argument must be a string");
    }
    if (!fn || typeof fn != "function") {
      throw new TypeError("The third argument must be a function");
    }
    if (!common.isObject(options)) {
      options = {};
    }
    const result = parseEventName(eventName);
    result.forEach((res) => {
      bindSingleListener(el, res.eventName, res.guid, fn.bind(el), options);
    });
  },
  off(el, eventName) {
    if (!(el instanceof Document) && !element.isElement(el) && !element.isWindow(el)) {
      throw new TypeError("The first argument must be an element node or window or document");
    }
    let events = data.get(el, "dap-defined-events");
    if (!events) {
      return;
    }
    if (!eventName) {
      let keys = Object.keys(events);
      let length = keys.length;
      for (let i = 0; i < length; i++) {
        let key = keys[i];
        el.removeEventListener(events[key].type, events[key].fn, events[key].options);
      }
      data.remove(el, "dap-defined-events");
      data.remove(el, "dap-event-guid");
      return;
    }
    const result = parseEventName(eventName);
    result.forEach((res) => {
      unbindSingleListener(el, res.eventName, res.guid);
    });
  },
  get(el) {
    if (!(el instanceof Document) && !element.isElement(el) && !element.isWindow(el)) {
      throw new TypeError("The first argument must be an element node or window or document");
    }
    let events = data.get(el, "dap-defined-events");
    if (!events) {
      return;
    }
    return events;
  }
};
const date = {
  getPrevMonths(date2, num) {
    if (!date2 || !(date2 instanceof Date)) {
      date2 = /* @__PURE__ */ new Date();
    }
    if (!number.isNumber(num)) {
      num = 1;
    }
    let dateArray = [date2];
    for (let i = 0; i < num - 1; i++) {
      let y = date2.getFullYear();
      let m = date2.getMonth();
      if (m == 0) {
        m = 12;
        y--;
      }
      let d = /* @__PURE__ */ new Date();
      d.setMonth(m - 1);
      d.setFullYear(y);
      dateArray.push(d);
      date2 = d;
    }
    return dateArray;
  },
  getNextMonths(date2, num) {
    if (!date2 || !(date2 instanceof Date)) {
      date2 = /* @__PURE__ */ new Date();
    }
    if (!number.isNumber(num)) {
      num = 1;
    }
    let dateArray = [date2];
    for (let i = 0; i < num - 1; i++) {
      let y = date2.getFullYear();
      let m = date2.getMonth();
      if (m == 11) {
        m = -1;
        y++;
      }
      let d = /* @__PURE__ */ new Date();
      d.setMonth(m + 1);
      d.setFullYear(y);
      dateArray.push(d);
      date2 = d;
    }
    return dateArray;
  },
  getDateAfter(date2, num) {
    if (!date2 || !(date2 instanceof Date)) {
      date2 = /* @__PURE__ */ new Date();
    }
    if (!number.isNumber(num)) {
      num = 1;
    }
    return new Date(date2.getTime() + num * 24 * 60 * 60 * 1e3);
  },
  getDateBefore(date2, num) {
    if (!date2 || !(date2 instanceof Date)) {
      date2 = /* @__PURE__ */ new Date();
    }
    if (!number.isNumber(num)) {
      num = 1;
    }
    return new Date(date2.getTime() - num * 24 * 60 * 60 * 1e3);
  },
  getDays(year, month) {
    if (!number.isNumber(year)) {
      throw new TypeError("The first parameter must be a number representing the year");
    }
    if (!number.isNumber(month)) {
      throw new TypeError("The second argument must be a number representing the month");
    }
    year = parseInt(year);
    month = parseInt(month);
    let d = new Date(year, month, 0);
    return d.getDate();
  }
};
const color = {
  rgb2hsv(rgb) {
    if (!Array.isArray(rgb) || rgb.length != 3) {
      throw new TypeError("Invalid argument");
    }
    let h2 = 0;
    let s = 0;
    let v = 0;
    let r = rgb[0] >= 255 ? 255 : rgb[0];
    let g = rgb[1] >= 255 ? 255 : rgb[1];
    let b = rgb[2] >= 255 ? 255 : rgb[2];
    r = r <= 0 ? 0 : r;
    g = g <= 0 ? 0 : g;
    b = b <= 0 ? 0 : b;
    let max = Math.max(r, g, b);
    let min = Math.min(r, g, b);
    v = max / 255;
    if (max === 0) {
      s = 0;
    } else {
      s = 1 - min / max;
    }
    if (max === min) {
      h2 = 0;
    } else if (max === r && g >= b) {
      h2 = 60 * ((g - b) / (max - min)) + 0;
    } else if (max === r && g < b) {
      h2 = 60 * ((g - b) / (max - min)) + 360;
    } else if (max === g) {
      h2 = 60 * ((b - r) / (max - min)) + 120;
    } else if (max === b) {
      h2 = 60 * ((r - g) / (max - min)) + 240;
    }
    h2 = parseInt(h2);
    s = parseInt(s * 100);
    v = parseInt(v * 100);
    return [h2, s, v];
  },
  hsv2rgb(hsv) {
    if (!Array.isArray(hsv) || hsv.length != 3) {
      throw new TypeError("Invalid argument");
    }
    let h2 = hsv[0] >= 360 || hsv[0] <= 0 ? 0 : hsv[0];
    let s = hsv[1] >= 100 ? 100 : hsv[1];
    s = s <= 0 ? 0 : s;
    let v = hsv[2] >= 100 ? 100 : hsv[2];
    v = v <= 0 ? 0 : v;
    s = s / 100;
    v = v / 100;
    let r = 0;
    let g = 0;
    let b = 0;
    let i = parseInt(h2 / 60 % 6);
    let f = h2 / 60 - i;
    let p = v * (1 - s);
    let q = v * (1 - f * s);
    let t = v * (1 - (1 - f) * s);
    switch (i) {
      case 0:
        r = v;
        g = t;
        b = p;
        break;
      case 1:
        r = q;
        g = v;
        b = p;
        break;
      case 2:
        r = p;
        g = v;
        b = t;
        break;
      case 3:
        r = p;
        g = q;
        b = v;
        break;
      case 4:
        r = t;
        g = p;
        b = v;
        break;
      case 5:
        r = v;
        g = p;
        b = q;
        break;
    }
    r = parseInt(r * 255);
    g = parseInt(g * 255);
    b = parseInt(b * 255);
    return [r, g, b];
  },
  rgb2hex(rgb) {
    if (!Array.isArray(rgb) || rgb.length != 3) {
      throw new TypeError("Invalid argument");
    }
    let r = rgb[0];
    let g = rgb[1];
    let b = rgb[2];
    let hex = "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    return hex;
  },
  hex2rgb(hex) {
    if (!hex || typeof hex != "string") {
      throw new TypeError("The argument must be a string");
    }
    let color2 = hex.toLowerCase();
    if (!common.matchingText(color2, "hex")) {
      throw new TypeError("The argument must be a hexadecimal color value");
    }
    if (color2.length === 4) {
      let colorNew = "#";
      for (let i = 1; i < 4; i += 1) {
        colorNew += color2.slice(i, i + 1).concat(color2.slice(i, i + 1));
      }
      color2 = colorNew;
    }
    let colorChange = [];
    for (let i = 1; i < 7; i += 2) {
      colorChange.push(parseInt("0x" + color2.slice(i, i + 2)));
    }
    return colorChange;
  }
};
const file = {
  getImageUrl(file2) {
    if (!file2 || !(file2 instanceof File)) {
      throw new TypeError("The argument must be a File object");
    }
    return window.URL.createObjectURL(file2);
  },
  dataFileToBase64(file2) {
    return new Promise((resolve, reject) => {
      if (!file2 || !(file2 instanceof File)) {
        reject(new TypeError("The argument must be a File object"));
      }
      let reader = new FileReader();
      reader.readAsDataURL(file2);
      reader.onloadend = () => {
        let dataURL = reader.result;
        resolve(dataURL);
      };
    });
  },
  dataBase64toFile(base64String, fileName) {
    if (!base64String || typeof base64String != "string") {
      throw new TypeError("The first argument must be a string");
    }
    if (!fileName || typeof fileName != "string") {
      throw new TypeError("The second argument must be a string");
    }
    let arr = base64String.split(",");
    let mime = arr[0].match(/:(.*?);/)[1];
    let bstr = atob(arr[1]);
    let n = bstr.length;
    let u8arr = new Uint8Array(n);
    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }
    return new File([u8arr], fileName, {
      type: mime
    });
  }
};
const platform = {
  language() {
    return window.navigator.browserLanguage || window.navigator.language;
  },
  device() {
    const userAgent = window.navigator.userAgent;
    return {
      PC: !userAgent.match(/AppleWebKit.*Mobile.*/),
      Mobile: !!userAgent.match(/AppleWebKit.*Mobile.*/),
      iPhone: userAgent.includes("iPhone"),
      Phone: userAgent.includes("Android") && /(?:Mobile)/.test(userAgent) || userAgent.includes("iPhone") || /(?:Windows Phone)/.test(userAgent),
      iPad: userAgent.includes("iPad"),
      Tablet: userAgent.includes("iPad") || userAgent.includes("Android") && !/(?:Mobile)/.test(userAgent) || userAgent.includes("Firefox") && /(?:Tablet)/.test(userAgent),
      WindowsPhone: /(?:Windows Phone)/.test(userAgent)
    };
  },
  browser() {
    const userAgent = window.navigator.userAgent;
    return {
      Edge: !!userAgent.match(/Edg\/([\d.]+)/),
      weixin: userAgent.includes("MicroMessenger"),
      QQ: userAgent.includes("QQ"),
      QQBrowser: userAgent.includes("MQQBrowser"),
      UC: userAgent.includes("UCBrowser"),
      Chrome: userAgent.includes("Chrome"),
      Firefox: userAgent.includes("Firefox"),
      sougou: userAgent.toLocaleLowerCase().includes("se 2.x") || userAgent.toLocaleLowerCase().includes("metasr") || userAgent.toLocaleLowerCase().includes("sogou"),
      Safari: userAgent.includes("Safari") && !userAgent.includes("Chrome")
    };
  },
  browserKernel() {
    const userAgent = window.navigator.userAgent;
    if (userAgent.includes("Presto")) {
      return "opera";
    } else if (userAgent.includes("AppleWebKit")) {
      return "webkit";
    } else if (userAgent.includes("Gecko") && !userAgent.includes("KHTML")) {
      return "gecko";
    }
    return "";
  },
  os() {
    const userAgent = window.navigator.userAgent;
    return {
      Windows: userAgent.includes("Windows"),
      Windows_CPU: function() {
        if (userAgent.toLocaleLowerCase().includes("win64") || userAgent.toLocaleLowerCase().includes("wow64")) {
          return "x64";
        } else if (userAgent.toLocaleLowerCase().includes("win32") || userAgent.toLocaleLowerCase().includes("wow32")) {
          return "x32";
        }
        return "";
      }(),
      Windows_Version: function() {
        if (userAgent.includes("Windows NT 6.1") || userAgent.includes("Windows 7")) {
          return "Win7";
        } else if (userAgent.includes("Windows NT 6.3") || userAgent.includes("Windows NT 6.2") || userAgent.includes("Windows NT 8")) {
          return "Win8";
        } else if (userAgent.includes("Windows NT 10") || userAgent.includes("Windows NT 6.4")) {
          return "Win10";
        }
        return "";
      }(),
      Mac: userAgent.includes("Macintosh"),
      Mac_Version: function() {
        if (userAgent.includes("Macintosh")) {
          const matches = userAgent.match(/Mac OS X ([^\s]+)\)/);
          if (matches && matches[1]) {
            return matches[1].split(/_|\./).join(".");
          }
        }
        return "";
      }(),
      ios: !!userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),
      ios_Version: function() {
        if (!!userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/)) {
          const matches = userAgent.match(/CPU.+OS ([^\s]+) like Mac OS X/);
          if (matches && matches[1]) {
            return matches[1].split(/_|\./).join(".");
          }
        }
        return "";
      }(),
      Android: userAgent.includes("Android"),
      Android_Version: function() {
        const matches = userAgent.match(/Android ([^\s]+);/);
        if (matches && matches[1]) {
          return matches[1].split(/_|\./).join(".");
        }
        return "";
      }(),
      Linux: userAgent.includes("Linux"),
      HarmonyOS: userAgent.includes("HarmonyOS"),
      Ubuntu: userAgent.includes("Ubuntu")
    };
  }
};
const speech = {
  start(text, params) {
    if (!window.SpeechSynthesisUtterance || !window.speechSynthesis) {
      throw new Error("The current browser does not support this syntax");
    }
    let defaultParams = {
      pitch: 0.8,
      rate: 1,
      volume: 1,
      start: function() {
      },
      end: function() {
      },
      pause: function() {
      },
      resume: function() {
      },
      error: function() {
      }
    };
    if (!common.isObject(params)) {
      params = {};
    }
    if (number.isNumber(params.pitch)) {
      defaultParams.pitch = params.pitch;
    }
    if (number.isNumber(params.rate)) {
      defaultParams.rate = params.rate;
    }
    if (number.isNumber(params.volume)) {
      defaultParams.volume = params.volume;
    }
    if (typeof params.start == "function") {
      defaultParams.start = params.start;
    }
    if (typeof params.end == "function") {
      defaultParams.end = params.end;
    }
    if (typeof params.pause == "function") {
      defaultParams.pause = params.pause;
    }
    if (typeof params.resume == "function") {
      defaultParams.resume = params.resume;
    }
    if (typeof params.error == "function") {
      defaultParams.error = params.error;
    }
    const speech2 = new SpeechSynthesisUtterance();
    speech2.text = text;
    speech2.pitch = defaultParams.pitch;
    speech2.rate = defaultParams.rate;
    speech2.volume = defaultParams.volume;
    speech2.lang = "zh-CN";
    speech2.onstart = (event2) => {
      defaultParams.start.apply(speech2, [
        event2,
        {
          text,
          pitch: defaultParams.pitch,
          rate: defaultParams.rate,
          volume: defaultParams.volume
        }
      ]);
    };
    speech2.onend = (event2) => {
      defaultParams.end.apply(speech2, [
        event2,
        {
          text,
          pitch: defaultParams.pitch,
          rate: defaultParams.rate,
          volume: defaultParams.volume
        }
      ]);
    };
    speech2.onpause = (event2) => {
      defaultParams.pause.apply(speech2, [
        event2,
        {
          text,
          pitch: defaultParams.pitch,
          rate: defaultParams.rate,
          volume: defaultParams.volume
        }
      ]);
    };
    speech2.onresume = (event2) => {
      defaultParams.resume.apply(speech2, [
        event2,
        {
          text,
          pitch: defaultParams.pitch,
          rate: defaultParams.rate,
          volume: defaultParams.volume
        }
      ]);
    };
    speech2.onerror = (event2) => {
      defaultParams.error.apply(speech2, [
        event2,
        {
          text,
          pitch: defaultParams.pitch,
          rate: defaultParams.rate,
          volume: defaultParams.volume
        }
      ]);
    };
    window.speechSynthesis.speak(speech2);
  },
  stop() {
    if (!window.SpeechSynthesisUtterance || !window.speechSynthesis) {
      throw new Error("The current browser does not support this syntax");
    }
    window.speechSynthesis.cancel();
  },
  pause() {
    if (!window.SpeechSynthesisUtterance || !window.speechSynthesis) {
      throw new Error("The current browser does not support this syntax");
    }
    window.speechSynthesis.pause();
  },
  resume() {
    if (!window.SpeechSynthesisUtterance || !window.speechSynthesis) {
      throw new Error("The current browser does not support this syntax");
    }
    window.speechSynthesis.resume();
  }
};
const obj = { number, data, element, event, common, date, color, file, string, platform, speech };
const Util = {
  getAttributes(el) {
    let o = {};
    const length = el.attributes.length;
    for (let i = 0; i < length; i++) {
      const attribute = el.attributes[i];
      if (!/(^on)|(^style$)|(^contenteditable$)/g.test(attribute.nodeName)) {
        o[attribute.nodeName] = attribute.nodeValue;
      }
    }
    return o;
  },
  getStyles(el) {
    let o = {};
    if (el.getAttribute("style")) {
      const styles = el.getAttribute("style");
      let i = 0;
      let start = 0;
      let splitStyles = [];
      while (i < styles.length) {
        if (styles[i] == ";" && styles.substring(i + 1, i + 8) != "base64,") {
          splitStyles.push(styles.substring(start, i));
          start = i + 1;
        }
        if (i == styles.length - 1 && start < i) {
          splitStyles.push(styles.substring(start, i));
        }
        i++;
      }
      splitStyles.forEach((style) => {
        const index = style.indexOf(":");
        const property = style.substring(0, index).trim();
        const value = style.substring(index + 1).trim();
        o[property] = value;
      });
    }
    return o;
  },
  createUniqueKey() {
    let key = obj.data.get(window, "data-alex-editor-key") || 0;
    key++;
    obj.data.set(window, "data-alex-editor-key", key);
    return key;
  },
  isSpaceText(val) {
    return /^[\uFEFF]+$/g.test(val);
  },
  clone(data2) {
    if (obj.common.isObject(data2) || Array.isArray(data2)) {
      return JSON.parse(JSON.stringify(data2));
    }
    return data2;
  },
  isContains(parent, target) {
    if (target.nodeType == 3) {
      return obj.element.isContains(parent, target.parentNode);
    }
    return obj.element.isContains(parent, target);
  },
  blobToBase64(blob) {
    return new Promise((resolve) => {
      const fileReader = new FileReader();
      fileReader.onload = (e) => {
        resolve(e.target.result);
      };
      fileReader.readAsDataURL(blob);
    });
  },
  createGuid() {
    let key = obj.data.get(window, "data-alex-editor-guid") || 0;
    key++;
    obj.data.set(window, "data-alex-editor-guid", key);
    return key;
  }
};
const _AlexElement = class {
  constructor(type, parsedom, marks, styles, textContent) {
    this.key = Util.createUniqueKey();
    this.type = type;
    this.parsedom = parsedom;
    this.marks = marks;
    this.styles = styles;
    this.textContent = textContent;
    this.children = null;
    this.parent = null;
    this.behavior = "default";
    this._elm = null;
  }
  isBlock() {
    return this.type == "block";
  }
  isInblock() {
    return this.type == "inblock";
  }
  isInline() {
    return this.type == "inline";
  }
  isClosed() {
    return this.type == "closed";
  }
  isText() {
    return this.type == "text";
  }
  isBreak() {
    return this.isClosed() && this.parsedom == "br";
  }
  isEmpty() {
    if (this.isText()) {
      return !this.textContent;
    }
    if (this.isBlock() || this.isInblock() || this.isInline()) {
      if (!this.hasChildren()) {
        return true;
      }
      const allEmpty = this.children.every((el) => {
        return !el || el.isEmpty();
      });
      return allEmpty;
    }
    return false;
  }
  isSpaceText() {
    return this.isText() && !this.isEmpty() && Util.isSpaceText(this.textContent);
  }
  isEqual(element2) {
    if (!_AlexElement.isElement(element2)) {
      return false;
    }
    return this.key == element2.key;
  }
  isContains(element2) {
    if (this.isEqual(element2)) {
      return true;
    }
    if (element2.isBlock()) {
      return false;
    }
    return this.isContains(element2.parent);
  }
  isOnlyHasBreak() {
    if (this.hasChildren()) {
      return this.children.every((item) => {
        return item.isBreak() || item.isEmpty();
      });
    }
    return false;
  }
  isPreStyle() {
    const block2 = this.getBlock();
    const inblock2 = this.getInblock();
    if (inblock2) {
      if (inblock2.parsedom == "pre") {
        return true;
      }
      if (inblock2.hasStyles() && (inblock2.styles["white-space"] == "pre" || inblock2.styles["white-space"] == "pre-wrap")) {
        return true;
      }
      return inblock2.parent.isPreStyle();
    } else {
      if (block2.parsedom == "pre") {
        return true;
      }
      if (block2.hasStyles() && (block2.styles["white-space"] == "pre" || block2.styles["white-space"] == "pre-wrap")) {
        return true;
      }
      return false;
    }
  }
  hasMarks() {
    if (!this.marks) {
      return false;
    }
    if (obj.common.isObject) {
      return !obj.common.isEmptyObject(this.marks);
    }
    return false;
  }
  hasStyles() {
    if (!this.styles) {
      return false;
    }
    if (obj.common.isObject(this.styles)) {
      return !obj.common.isEmptyObject(this.styles);
    }
    return false;
  }
  hasChildren() {
    if (this.isClosed() || this.isText()) {
      return false;
    }
    if (Array.isArray(this.children)) {
      return !!this.children.length;
    }
    return false;
  }
  hasContains(element2) {
    return this.isContains(element2) || element2.isContains(this);
  }
  clone(deep = true) {
    if (typeof deep != "boolean") {
      throw new Error("The parameter must be a Boolean");
    }
    let el = new _AlexElement(this.type, this.parsedom, Util.clone(this.marks), Util.clone(this.styles), this.textContent);
    el.behavior = this.behavior;
    if (deep && this.hasChildren()) {
      this.children.forEach((child) => {
        let clonedChild = child.clone(deep);
        if (el.hasChildren()) {
          el.children.push(clonedChild);
        } else {
          el.children = [clonedChild];
        }
        clonedChild.parent = el;
      });
    }
    return el;
  }
  convertToBlock() {
    if (this.isBlock()) {
      throw new Error('This element is already of type "block"');
    }
    let element2 = this.clone();
    this.type = "block";
    this.parsedom = _AlexElement.BLOCK_NODE;
    this.marks = null;
    this.styles = null;
    this.textContent = null;
    this.children = [element2];
    element2.parent = this;
  }
  toEmpty() {
    if (this.isEmpty()) {
      return;
    }
    if (this.isText()) {
      this.marks = null;
      this.styles = null;
      this.textContent = null;
      this._elm = null;
    } else if (this.isClosed()) {
      this.type = "text";
      this.parsedom = null;
      this.marks = null;
      this.styles = null;
      this.textContent = null;
      this._elm = null;
    } else if (this.hasChildren()) {
      this.children.forEach((el) => {
        el.toEmpty();
      });
    }
  }
  getBlock() {
    if (this.isBlock()) {
      return this;
    }
    return this.parent.getBlock();
  }
  getInblock() {
    if (this.isInblock()) {
      return this;
    }
    if (this.isBlock()) {
      return null;
    }
    return this.parent.getInblock();
  }
  getInline() {
    if (this.isInline()) {
      return this;
    }
    if (this.isBlock()) {
      return null;
    }
    return this.parent.getInline();
  }
  isEqualStyles(element2) {
    if (!this.hasStyles() && !element2.hasStyles()) {
      return true;
    }
    if (this.hasStyles() && element2.hasStyles() && obj.common.equal(this.styles, element2.styles)) {
      return true;
    }
    return false;
  }
  isEqualMarks(element2) {
    if (!this.hasMarks() && !element2.hasMarks()) {
      return true;
    }
    if (this.hasMarks() && element2.hasMarks() && obj.common.equal(this.marks, element2.marks)) {
      return true;
    }
    return false;
  }
  __getDiffMarks(element2) {
    if (this.hasMarks()) {
      if (element2.hasMarks()) {
        const selfMarkNames = Object.keys(this.marks);
        const thatMarkNames = Object.keys(element2.marks);
        return {
          more: selfMarkNames.filter((item) => {
            return (!thatMarkNames.includes(item) || element2.marks[item] != this.marks[item]) && !/(^on)|(^style$)|(^contenteditable$)/g.test(item);
          }),
          less: thatMarkNames.filter((item) => {
            return (!selfMarkNames.includes(item) || element2.marks[item] != this.marks[item]) && !/(^on)|(^style$)|(^contenteditable$)/g.test(item);
          })
        };
      } else {
        return {
          more: Object.keys(this.marks).filter((item) => {
            return !/(^on)|(^style$)|(^contenteditable$)/g.test(item);
          }),
          less: []
        };
      }
    } else {
      if (element2.hasMarks()) {
        return {
          more: [],
          less: Object.keys(element2.marks).filter((item) => {
            return !/(^on)|(^style$)|(^contenteditable$)/g.test(item);
          })
        };
      } else {
        return {
          more: [],
          less: []
        };
      }
    }
  }
  __getDiffStyles(element2) {
    if (this.hasStyles()) {
      if (element2.hasStyles()) {
        const selfStyleNames = Object.keys(this.styles);
        const thatStyleNames = Object.keys(element2.styles);
        return {
          more: selfStyleNames.filter((item) => {
            return !thatStyleNames.includes(item) || element2.styles[item] != this.styles[item];
          }),
          less: thatStyleNames.filter((item) => {
            return !selfStyleNames.includes(item) || element2.styles[item] != this.styles[item];
          })
        };
      } else {
        return {
          more: Object.keys(this.styles),
          less: []
        };
      }
    } else {
      if (element2.hasStyles()) {
        return {
          more: [],
          less: Object.keys(element2.styles)
        };
      } else {
        return {
          more: [],
          less: []
        };
      }
    }
  }
  __renderElement() {
    let el = null;
    if (this.isText()) {
      el = document.createElement(_AlexElement.TEXT_NODE);
      const text = document.createTextNode(this.textContent);
      el.appendChild(text);
    } else {
      el = document.createElement(this.parsedom);
      if (this.hasChildren()) {
        this.children.forEach((child) => {
          child.__renderElement();
          el.appendChild(child._elm);
        });
      }
    }
    if (this.hasMarks()) {
      Object.keys(this.marks).forEach((key) => {
        if (!/(^on)|(^style$)|(^contenteditable$)/g.test(key)) {
          el.setAttribute(key, this.marks[key]);
        }
      });
    }
    if (this.hasStyles()) {
      Object.keys(this.styles).forEach((key) => {
        el.style.setProperty(key, this.styles[key]);
      });
    }
    obj.data.set(el, "data-alex-editor-key", this.key);
    this._elm = el;
  }
  __fullClone() {
    let el = new _AlexElement(this.type, this.parsedom, Util.clone(this.marks), Util.clone(this.styles), this.textContent);
    el.behavior = this.behavior;
    el.key = this.key;
    el._elm = this._elm;
    if (this.hasChildren()) {
      this.children.forEach((child) => {
        let clonedChild = child.__fullClone();
        if (el.hasChildren()) {
          el.children.push(clonedChild);
        } else {
          el.children = [clonedChild];
        }
        clonedChild.parent = el;
      });
    }
    return el;
  }
  __getLink() {
    if (this.parsedom == "a") {
      return this;
    }
    if (this.isBlock()) {
      return null;
    }
    return this.parent.__getLink();
  }
  static isElement(val) {
    return val instanceof _AlexElement;
  }
  static flatElements(elements) {
    const fn = (arr) => {
      let result = [];
      let index = 0;
      const length = arr.length;
      while (index < length) {
        result.push(arr[index]);
        if (arr[index].hasChildren()) {
          result.push(...fn(arr[index].children));
        }
        index++;
      }
      return result;
    };
    return fn(elements);
  }
  static getSpaceElement() {
    return new _AlexElement("text", null, null, null, "\uFEFF");
  }
};
let AlexElement = _AlexElement;
__publicField(AlexElement, "BLOCK_NODE", "p");
__publicField(AlexElement, "TEXT_NODE", "span");
__publicField(AlexElement, "VOID_NODES", ["colgroup", "col"]);
class AlexPoint {
  constructor(element2, offset) {
    this.element = element2;
    this.offset = offset;
    this.__init();
  }
  __init() {
    if (this.element.isText() || this.element.isClosed()) {
      if (AlexElement.VOID_NODES.includes(this.element.parsedom)) {
        throw new Error("Invisible element cannot be set as focal point");
      }
      return;
    }
    if (this.offset == 0) {
      this.moveToStart(this.element);
    } else {
      this.moveToEnd(this.element);
    }
  }
  static isPoint(val) {
    return val instanceof AlexPoint;
  }
  isEqual(point) {
    if (!AlexPoint.isPoint(point)) {
      return false;
    }
    return this.element.isEqual(point.element) && this.offset == point.offset;
  }
  moveToEnd(element2) {
    if (!AlexElement.isElement(element2)) {
      throw new Error("The argument must be an AlexElement instance");
    }
    if (element2.isEmpty()) {
      throw new Error("The argument cannot be an empty element");
    }
    if (element2.isText()) {
      this.element = element2;
      this.offset = element2.textContent.length;
    } else if (element2.isClosed()) {
      if (AlexElement.VOID_NODES.includes(element2.parsedom)) {
        throw new Error("Invisible element cannot be set as focal point");
      }
      this.element = element2;
      this.offset = 1;
    } else if (element2.hasChildren()) {
      const flatElements = AlexElement.flatElements(element2.children).filter((el) => {
        return !el.isEmpty() && !AlexElement.VOID_NODES.includes(el.parsedom);
      });
      const length = flatElements.length;
      this.moveToEnd(flatElements[length - 1]);
    }
  }
  moveToStart(element2) {
    if (!AlexElement.isElement(element2)) {
      throw new Error("The argument must be an AlexElement instance");
    }
    if (element2.isEmpty()) {
      throw new Error("The argument cannot be an empty element");
    }
    if (element2.isText()) {
      this.element = element2;
      this.offset = 0;
    } else if (element2.isClosed()) {
      if (AlexElement.VOID_NODES.includes(element2.parsedom)) {
        throw new Error("Invisible element cannot be set as focal point");
      }
      this.element = element2;
      this.offset = 0;
    } else if (element2.hasChildren()) {
      const flatElements = AlexElement.flatElements(element2.children).filter((el) => {
        return !el.isEmpty() && !AlexElement.VOID_NODES.includes(el.parsedom);
      });
      this.moveToStart(flatElements[0]);
    }
  }
}
class AlexRange {
  constructor(anchor, focus) {
    this.anchor = anchor;
    this.focus = focus;
  }
}
class AlexHistory {
  constructor() {
    this.records = [];
    this.current = -1;
  }
  push(stack, range) {
    if (this.current < this.records.length - 1) {
      this.records.length = this.current + 1;
    }
    const newStack = stack.map((ele) => {
      return ele.__fullClone();
    });
    const anchorElement = AlexElement.flatElements(newStack).find((ele) => {
      return ele.key == range.anchor.element.key;
    });
    const focusElement = AlexElement.flatElements(newStack).find((ele) => {
      return ele.key == range.focus.element.key;
    });
    const anchor = new AlexPoint(anchorElement, range.anchor.offset);
    const focus = new AlexPoint(focusElement, range.focus.offset);
    const newRange = new AlexRange(anchor, focus);
    this.records.push({
      stack: newStack,
      range: newRange
    });
    this.current += 1;
  }
  get(type) {
    if (type == -1) {
      if (this.current <= 0) {
        return null;
      }
      this.current -= 1;
    } else if (type == 1) {
      if (this.current >= this.records.length - 1) {
        return null;
      }
      this.current += 1;
    }
    const { stack, range } = this.records[this.current];
    const newStack = stack.map((ele) => {
      return ele.__fullClone();
    });
    const anchorElement = AlexElement.flatElements(newStack).find((ele) => {
      return ele.key == range.anchor.element.key;
    });
    const focusElement = AlexElement.flatElements(newStack).find((ele) => {
      return ele.key == range.focus.element.key;
    });
    const anchor = new AlexPoint(anchorElement, range.anchor.offset);
    const focus = new AlexPoint(focusElement, range.focus.offset);
    const newRange = new AlexRange(anchor, focus);
    return {
      stack: newStack,
      range: newRange
    };
  }
}
const { Mac } = obj.platform.os();
const Keyboard = {
  Undo(e) {
    if (Mac) {
      return e.keyCode == 90 && e.metaKey && !e.ctrlKey && !e.shiftKey && !e.altKey;
    }
    return e.keyCode == 90 && e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey;
  },
  Redo(e) {
    if (Mac) {
      return e.keyCode == 90 && e.metaKey && e.shiftKey && !e.ctrlKey && !e.altKey;
    }
    return e.keyCode == 89 && e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey;
  }
};
const block = [
  {
    parsedom: "p"
  },
  {
    parsedom: "div"
  },
  {
    parsedom: "table"
  },
  {
    parsedom: "ul"
  },
  {
    parsedom: "ol"
  },
  {
    parsedom: "h1"
  },
  {
    parsedom: "h2"
  },
  {
    parsedom: "h3"
  },
  {
    parsedom: "h4"
  },
  {
    parsedom: "h5"
  },
  {
    parsedom: "h6"
  },
  {
    parsedom: "blockquote"
  },
  {
    parsedom: "pre"
  },
  {
    parsedom: "address",
    parse: true
  },
  {
    parsedom: "article",
    parse: true
  },
  {
    parsedom: "aside",
    parse: true
  },
  {
    parsedom: "nav",
    parse: true
  },
  {
    parsedom: "section",
    parse: true
  }
];
const inblock = [
  {
    parsedom: "li",
    block: true
  },
  {
    parsedom: "tfoot"
  },
  {
    parsedom: "tbody"
  },
  {
    parsedom: "thead"
  },
  {
    parsedom: "tr"
  },
  {
    parsedom: "th"
  },
  {
    parsedom: "td"
  },
  {
    parsedom: "colgroup"
  }
];
const inline = [
  {
    parsedom: "span"
  },
  {
    parsedom: "a"
  },
  {
    parsedom: "label"
  },
  {
    parsedom: "code"
  },
  {
    parsedom: "b",
    parse: {
      "font-weight": "bold"
    }
  },
  {
    parsedom: "strong",
    parse: {
      "font-weight": "bold"
    }
  },
  {
    parsedom: "sup",
    parse: {
      "vertical-align": "super"
    }
  },
  {
    parsedom: "sub",
    parse: {
      "vertical-align": "sub"
    }
  },
  {
    parsedom: "i",
    parse: {
      "font-style": "italic"
    }
  },
  {
    parsedom: "u",
    parse: {
      "text-decoration-line": "underline"
    }
  },
  {
    parsedom: "del",
    parse: {
      "text-decoration-line": "line-through"
    }
  },
  {
    parsedom: "abbr",
    parse: true
  },
  {
    parsedom: "acronym",
    parse: true
  },
  {
    parsedom: "bdo",
    parse: true
  }
];
const closed = [
  {
    parsedom: "br"
  },
  {
    parsedom: "col"
  },
  {
    parsedom: "img"
  },
  {
    parsedom: "hr"
  },
  {
    parsedom: "video"
  },
  {
    parsedom: "audio"
  }
];
const defaultConfig = {
  block,
  inblock,
  inline,
  closed
};
class AlexEditor {
  constructor(el, options) {
    __publicField(this, "__formatUnchangeableRules", [
      (element2) => {
        if (element2.hasChildren()) {
          const children = element2.children.filter((el2) => {
            return !el2.isEmpty();
          });
          const blocks = children.filter((el2) => {
            return el2.isBlock();
          });
          blocks.forEach((el2) => {
            el2.type = element2.type == "inline" ? "inline" : "inblock";
          });
        }
      },
      (element2) => {
        if (element2.hasChildren()) {
          const children = element2.children.filter((el2) => {
            return !el2.isEmpty();
          });
          let allIsBlock = children.every((el2) => {
            return el2.isInblock();
          });
          if (!allIsBlock) {
            children.forEach((el2) => {
              if (el2.isInblock()) {
                el2.type = "inline";
              }
            });
          }
        }
      },
      (element2) => {
        if (element2.isInline() && element2.hasChildren()) {
          const children = element2.children.filter((el2) => {
            return !el2.isEmpty();
          });
          const inblocks = children.filter((el2) => {
            return el2.isInblock();
          });
          inblocks.forEach((el2) => {
            if (el2.isInblock()) {
              el2.type = "inline";
            }
          });
        }
      },
      (element2) => {
        if (element2.hasChildren()) {
          const children = element2.children.filter((el2) => {
            return !el2.isEmpty();
          });
          const allIsBreak = children.every((el2) => {
            return el2.isBreak();
          });
          if (allIsBreak && children.length) {
            const breakEl = children[0];
            if (element2.isContains(this.range.anchor.element)) {
              this.range.anchor.moveToStart(breakEl);
            }
            if (element2.isContains(this.range.focus.element)) {
              this.range.focus.moveToStart(breakEl);
            }
            element2.children = [breakEl];
          } else {
            element2.children.forEach((el2) => {
              if (el2.isBreak()) {
                el2.toEmpty();
              }
            });
          }
        }
      },
      (element2) => {
        const canMerge = (pel, nel) => {
          if (pel.isEmpty() || nel.isEmpty()) {
            return true;
          }
          if (pel.isText() && nel.isText()) {
            return pel.isEqualStyles(nel) && pel.isEqualMarks(nel);
          }
          if (pel.isInline() && nel.isInline()) {
            return pel.parsedom == nel.parsedom && pel.isEqualMarks(nel) && pel.isEqualStyles(nel);
          }
          return false;
        };
        const merge = (pel, nel) => {
          if (pel.isEmpty() || nel.isEmpty()) {
            if (nel.isEmpty()) {
              if (nel.isContains(this.range.anchor.element)) {
                if (pel.isEmpty()) {
                  this.range.anchor.element = pel;
                  this.range.anchor.offset = 0;
                } else {
                  this.range.anchor.moveToEnd(pel);
                }
              }
              if (nel.isContains(this.range.focus.element)) {
                if (pel.isEmpty()) {
                  this.range.focus.element = pel;
                  this.range.focus.offset = 0;
                } else {
                  this.range.focus.moveToEnd(pel);
                }
              }
              const index = nel.parent.children.findIndex((item) => {
                return nel.isEqual(item);
              });
              nel.parent.children.splice(index, 1);
            } else if (pel.isEmpty()) {
              if (pel.isContains(this.range.anchor.element)) {
                if (nel.isEmpty()) {
                  this.range.anchor.element = nel;
                  this.range.anchor.offset = 0;
                } else {
                  this.range.anchor.moveToStart(nel);
                }
              }
              if (pel.isContains(this.range.focus.element)) {
                if (nel.isEmpty()) {
                  this.range.focus.element = nel;
                  this.range.focus.offset = 0;
                } else {
                  this.range.focus.moveToStart(nel);
                }
              }
              const index = pel.parent.children.findIndex((item) => {
                return pel.isEqual(item);
              });
              pel.parent.children.splice(index, 1);
            }
          } else if (pel.isText()) {
            if (nel.isEqual(this.range.anchor.element)) {
              this.range.anchor.element = pel;
              this.range.anchor.offset = pel.textContent.length + this.range.anchor.offset;
            }
            if (nel.isEqual(this.range.focus.element)) {
              this.range.focus.element = pel;
              this.range.focus.offset = pel.textContent.length + this.range.focus.offset;
            }
            pel.textContent += nel.textContent;
            const index = nel.parent.children.findIndex((item) => {
              return nel.isEqual(item);
            });
            nel.parent.children.splice(index, 1);
          } else if (pel.isInline()) {
            pel.children.push(...nel.children);
            pel.children.forEach((item) => {
              item.parent = pel;
            });
            mergeElement(pel);
            const index = nel.parent.children.findIndex((item) => {
              return nel.isEqual(item);
            });
            nel.parent.children.splice(index, 1);
          }
        };
        const mergeElement = (ele) => {
          if (ele.hasChildren() && ele.children.length > 1) {
            let index = 0;
            while (index <= ele.children.length - 2) {
              if (canMerge(ele.children[index], ele.children[index + 1])) {
                merge(ele.children[index], ele.children[index + 1]);
                continue;
              }
              index++;
            }
          }
        };
        mergeElement(element2);
      },
      (element2) => {
        const canMerge = (parent, child) => {
          if (child.isText() && parent.isInline()) {
            return parent.parsedom == AlexElement.TEXT_NODE;
          }
          if (parent.isInline() && child.isInline() || parent.isInblock() && child.isInblock()) {
            return parent.parsedom == child.parsedom;
          }
          return false;
        };
        const merge = (parent, child) => {
          if (child.isText()) {
            parent.type = "text";
            parent.parsedom = null;
            if (child.hasMarks()) {
              if (parent.hasMarks()) {
                Object.assign(parent.marks, Util.clone(child.marks));
              } else {
                parent.marks = Util.clone(child.marks);
              }
            }
            if (child.hasStyles()) {
              if (parent.hasStyles()) {
                Object.assign(parent.styles, Util.clone(child.styles));
              } else {
                parent.styles = Util.clone(child.styles);
              }
            }
            parent.textContent = child.textContent;
            parent.children = null;
            if (child.isContains(this.range.anchor.element)) {
              this.range.anchor.element = parent;
            }
            if (child.isContains(this.range.focus.element)) {
              this.range.focus.element = parent;
            }
          } else {
            if (child.hasMarks()) {
              if (parent.hasMarks()) {
                Object.assign(parent.marks, Util.clone(child.marks));
              } else {
                parent.marks = Util.clone(child.marks);
              }
            }
            if (child.hasStyles()) {
              if (parent.hasStyles()) {
                Object.assign(parent.styles, Util.clone(child.styles));
              } else {
                parent.styles = Util.clone(child.styles);
              }
            }
            if (child.hasChildren()) {
              parent.children = [...child.children];
              parent.children.forEach((item) => {
                item.parent = parent;
              });
            }
          }
        };
        if (element2.hasChildren() && element2.children.length == 1 && canMerge(element2, element2.children[0])) {
          merge(element2, element2.children[0]);
        }
      }
    ]);
    if (typeof el == "string" && el) {
      el = document.body.querySelector(el);
    }
    if (!obj.element.isElement(el)) {
      throw new Error("You must specify a dom container to initialize the editor");
    }
    if (obj.data.get(el, "data-alex-editor-init")) {
      throw new Error("The element node has been initialized to the editor");
    }
    obj.data.set(el, "data-alex-editor-init", true);
    options = this.__formatOptions(options);
    this.$el = el;
    this.disabled = options.disabled;
    this.value = options.value;
    this.renderRules = options.renderRules;
    this.htmlPaste = options.htmlPaste;
    this.range = null;
    this.useClipboard = true;
    this.history = new AlexHistory();
    this.stack = this.parseHtml(this.value);
    this.__guid = Util.createGuid();
    this.__events = {};
    this.__oldValue = null;
    this.__isInputChinese = false;
    this.__innerSelectionChange = false;
    this.__chineseInputTimer = null;
    this.__initRange();
    this.disabled ? this.setDisabled() : this.setEnabled();
    this.__judgeUseClipboard();
    obj.event.on(document, `selectionchange.alex_editor_${this.__guid}`, this.__handleSelectionChange.bind(this));
    obj.event.on(this.$el, "beforeinput.alex_editor", this.__handleBeforeInput.bind(this));
    obj.event.on(this.$el, "compositionstart.alex_editor compositionupdate.alex_editor compositionend.alex_editor", this.__handleChineseInput.bind(this));
    obj.event.on(this.$el, "keydown.alex_editor", this.__handleKeydown.bind(this));
    obj.event.on(this.$el, "cut.alex_editor", this.__handleCut.bind(this));
    obj.event.on(this.$el, "paste.alex_editor", this.__handlePaste.bind(this));
    obj.event.on(this.$el, "copy.alex_editor", this.__handleCopy.bind(this));
    obj.event.on(this.$el, "dragstart.alex_editor drop.alex_editor ", this.__handleDragDrop.bind(this));
    obj.event.on(this.$el, "focus.alex_editor", this.__handleFocus.bind(this));
    obj.event.on(this.$el, "blur.alex_editor", this.__handleBlur.bind(this));
  }
  __formatOptions(options) {
    let opts = {
      disabled: false,
      renderRules: [],
      htmlPaste: false,
      value: ""
    };
    if (obj.common.isObject(options)) {
      if (typeof options.disabled == "boolean") {
        opts.disabled = options.disabled;
      }
      if (Array.isArray(options.renderRules)) {
        opts.renderRules = options.renderRules;
      }
      if (typeof options.value == "string" && options.value) {
        opts.value = options.value;
      }
      if (typeof options.htmlPaste == "boolean") {
        opts.htmlPaste = options.htmlPaste;
      }
    }
    return opts;
  }
  __initRange() {
    const firstElement = this.stack[0];
    const anchor = new AlexPoint(firstElement, 0);
    const focus = new AlexPoint(firstElement, 0);
    this.range = new AlexRange(anchor, focus);
  }
  __setRecentlyPoint(point) {
    const previousElement = this.getPreviousElementOfPoint(point);
    const nextElement = this.getNextElementOfPoint(point);
    const block2 = point.element.getBlock();
    const inblock2 = point.element.getInblock();
    if (previousElement && inblock2 && inblock2.isContains(previousElement)) {
      point.moveToEnd(previousElement);
    } else if (nextElement && inblock2 && inblock2.isContains(nextElement)) {
      point.moveToStart(nextElement);
    } else if (previousElement && block2.isContains(previousElement)) {
      point.moveToEnd(previousElement);
    } else if (nextElement && block2.isContains(nextElement)) {
      point.moveToStart(nextElement);
    } else if (previousElement) {
      point.moveToEnd(previousElement);
    } else if (nextElement) {
      point.moveToStart(nextElement);
    }
  }
  __judgeUseClipboard() {
    if (!window.ClipboardItem) {
      this.useClipboard = false;
      console.warn("window.ClipboardItem must be obtained in a secure environment, such as localhost, 127.0.0.1, or https, so the editor's copy, paste, and cut functions cannot be used");
    }
    if (!navigator.clipboard) {
      this.useClipboard = false;
      console.warn("navigator.clipboard must be obtained in a secure environment, such as localhost, 127.0.0.1, or https, so the editor's copy, paste, and cut functions cannot be used");
    }
  }
  __emptyDefaultBehaviorInblock(ele) {
    if (!ele.isInblock()) {
      return;
    }
    if (ele.behavior != "default") {
      return;
    }
    if (ele.hasChildren()) {
      ele.children.forEach((item) => {
        if (item.isInblock()) {
          this.__emptyDefaultBehaviorInblock(item);
        } else {
          item.toEmpty();
          if (item.parent.isEmpty()) {
            const breakEl = new AlexElement("closed", "br", null, null, null);
            this.addElementTo(breakEl, item.parent);
          }
        }
      });
    }
  }
  __safariLinkHandle() {
    const { Safari } = obj.platform.browser();
    const linkEle = this.range.anchor.element.__getLink();
    if (Safari && linkEle) {
      if (linkEle.hasChildren()) {
        const elements = AlexElement.flatElements(linkEle.children);
        for (let i = elements.length - 1; i >= 0; i--) {
          elements[i]._elm.remove();
        }
      }
      linkEle._elm.remove();
      this.__insertNewDom(linkEle);
    }
  }
  __setRangeInVisible() {
    const fn = async (root2) => {
      const scrollHeight = obj.element.getScrollHeight(root2);
      if (root2.clientHeight < scrollHeight) {
        const selection = window.getSelection();
        if (selection.rangeCount == 0) {
          return;
        }
        const range = selection.getRangeAt(0);
        const rects = range.getClientRects();
        let target = range;
        if (rects.length == 0) {
          target = this.range.focus.element._elm;
        }
        const childRect = target.getBoundingClientRect();
        const parentRect = root2.getBoundingClientRect();
        if (childRect.top < parentRect.top) {
          await obj.element.setScrollTop({
            el: root2,
            number: 0
          });
          const tempChildRect = target.getBoundingClientRect();
          const tempParentRect = root2.getBoundingClientRect();
          obj.element.setScrollTop({
            el: root2,
            number: tempChildRect.top - tempParentRect.top - tempChildRect.height * 2
          });
        } else if (childRect.bottom > parentRect.bottom) {
          await obj.element.setScrollTop({
            el: root2,
            number: 0
          });
          const tempChildRect = target.getBoundingClientRect();
          const tempParentRect = root2.getBoundingClientRect();
          obj.element.setScrollTop({
            el: root2,
            number: tempChildRect.bottom - tempParentRect.bottom + tempChildRect.height * 2
          });
        }
      }
    };
    let root = this.$el;
    while (obj.element.isElement(root) && root != document.documentElement) {
      fn(root);
      root = root.parentNode;
    }
  }
  __insertNewDom(el, reRender = true) {
    if (reRender) {
      el.__renderElement();
    }
    const previousElement = this.getPreviousElement(el);
    if (previousElement) {
      previousElement._elm.parentNode.insertBefore(el._elm, previousElement._elm.nextSibling);
    } else {
      if (el.isBlock()) {
        if (this.$el.firstElementChild) {
          this.$el.insertBefore(el._elm, this.$el.firstElementChild);
        } else {
          this.$el.appendChild(el._elm);
        }
      } else {
        const parent = el.parent._elm;
        if (parent.firstElementChild) {
          parent.insertBefore(el._elm, parent.firstElementChild);
        } else {
          parent.appendChild(el._elm);
        }
      }
    }
  }
  __handleSelectionChange() {
    if (this.disabled) {
      return;
    }
    if (this.__isInputChinese) {
      return;
    }
    if (this.__innerSelectionChange) {
      return;
    }
    const selection = window.getSelection();
    if (selection.rangeCount) {
      const range = selection.getRangeAt(0);
      if (Util.isContains(this.$el, range.startContainer) && Util.isContains(this.$el, range.endContainer)) {
        let anchorNode = null;
        let focusNode = null;
        let anchorOffset = null;
        let focusOffset = null;
        if (range.startContainer.nodeType == 3) {
          anchorNode = range.startContainer.parentNode;
          anchorOffset = range.startOffset;
        } else if (range.startContainer.nodeType == 1) {
          const childNodes = Array.from(range.startContainer.childNodes);
          if (childNodes.length) {
            anchorNode = childNodes[range.startOffset] ? childNodes[range.startOffset] : childNodes[range.startOffset - 1];
            anchorOffset = childNodes[range.startOffset] ? 0 : 1;
            if (anchorNode.nodeType == 3) {
              anchorOffset = anchorOffset == 0 ? 0 : anchorNode.textContent.length;
              anchorNode = anchorNode.parentNode;
            }
          } else {
            anchorNode = range.startContainer;
            anchorOffset = 0;
          }
        }
        if (range.endContainer.nodeType == 3) {
          focusNode = range.endContainer.parentNode;
          focusOffset = range.endOffset;
        } else if (range.endContainer.nodeType == 1) {
          const childNodes = Array.from(range.endContainer.childNodes);
          if (childNodes.length) {
            focusNode = childNodes[range.endOffset] ? childNodes[range.endOffset] : childNodes[range.endOffset - 1];
            focusOffset = childNodes[range.endOffset] ? 0 : 1;
            if (focusNode.nodeType == 3) {
              focusOffset = focusOffset == 0 ? 0 : focusNode.textContent.length;
              focusNode = focusNode.parentNode;
            }
          } else {
            focusNode = range.endContainer;
            focusOffset = 1;
          }
        }
        const anchorKey = obj.data.get(anchorNode, "data-alex-editor-key");
        const focusKey = obj.data.get(focusNode, "data-alex-editor-key");
        const anchorEle = this.getElementByKey(anchorKey);
        const focusEle = this.getElementByKey(focusKey);
        const anchor = new AlexPoint(anchorEle, anchorOffset);
        const focus = new AlexPoint(focusEle, focusOffset);
        this.range = new AlexRange(anchor, focus);
        this.emit("rangeUpdate", this.range);
      }
    }
  }
  __handleBeforeInput(e) {
    if (this.disabled) {
      return;
    }
    if (e.inputType == "deleteByCut" || e.inputType == "insertFromPaste" || e.inputType == "deleteByDrag" || e.inputType == "insertFromDrop") {
      return;
    }
    e.preventDefault();
    if (e.inputType == "insertText" && e.data) {
      this.insertText(e.data);
      this.formatElementStack();
      this.domRender();
      this.rangeRender();
    } else if (e.inputType == "insertParagraph" || e.inputType == "insertLineBreak") {
      this.insertParagraph();
      this.formatElementStack();
      this.domRender();
      this.rangeRender();
    } else if (e.inputType == "deleteContentBackward") {
      this.delete();
      this.formatElementStack();
      this.domRender();
      this.rangeRender();
    }
  }
  __handleChineseInput(e) {
    if (this.disabled) {
      return;
    }
    e.preventDefault();
    if (e.type == "compositionstart") {
      if (this.__chineseInputTimer) {
        clearTimeout(this.__chineseInputTimer);
        this.__chineseInputTimer = null;
      }
      this.__isInputChinese = true;
    } else if (e.type == "compositionend") {
      if (e.data) {
        this.insertText(e.data);
        this.formatElementStack();
        this.__safariLinkHandle();
        this.domRender();
        this.rangeRender();
      }
      this.__chineseInputTimer = setTimeout(() => {
        this.__isInputChinese = false;
      }, 0);
    }
  }
  __handleKeydown(e) {
    if (this.disabled) {
      return;
    }
    if (this.__isInputChinese) {
      return;
    }
    if (Keyboard.Undo(e)) {
      e.preventDefault();
      const historyRecord = this.history.get(-1);
      if (historyRecord) {
        this.stack = historyRecord.stack;
        this.range = historyRecord.range;
        this.formatElementStack();
        this.domRender(true);
        this.rangeRender();
      }
    } else if (Keyboard.Redo(e)) {
      e.preventDefault();
      const historyRecord = this.history.get(1);
      if (historyRecord) {
        this.stack = historyRecord.stack;
        this.range = historyRecord.range;
        this.formatElementStack();
        this.domRender(true);
        this.rangeRender();
      }
    }
  }
  async __handleCut(e) {
    e.preventDefault();
    const result = await this.cut();
    if (result) {
      this.formatElementStack();
      this.domRender();
      this.rangeRender();
    }
  }
  async __handlePaste(e) {
    e.preventDefault();
    await this.paste();
    this.formatElementStack();
    this.domRender();
    this.rangeRender();
  }
  async __handleCopy(e) {
    e.preventDefault();
    await this.copy();
  }
  __handleDragDrop(e) {
    e.preventDefault();
  }
  __handleFocus(e) {
    this.emit("focus", this.value);
  }
  __handleBlur(e) {
    this.emit("blur", this.value);
  }
  async paste() {
    if (!this.useClipboard) {
      return false;
    }
    const clipboardItems = await navigator.clipboard.read();
    const clipboardItem = clipboardItems[0];
    const getTypeFunctions = [];
    clipboardItem.types.forEach((type) => {
      getTypeFunctions.push(clipboardItem.getType(type));
    });
    const blobs = await Promise.all(getTypeFunctions);
    const length = blobs.length;
    const hasHtml = blobs.some((blob) => {
      return blob.type == "text/html";
    });
    if (hasHtml) {
      for (let i = 0; i < length; i++) {
        const blob = blobs[i];
        if (blob.type == "text/plain" && !this.htmlPaste) {
          const data2 = await blob.text();
          if (data2) {
            this.insertText(data2);
            this.emit("pasteText", data2);
          }
        } else if (blob.type == "text/html" && this.htmlPaste) {
          const data2 = await blob.text();
          if (data2) {
            const elements = this.parseHtml(data2).filter((el) => {
              return !el.isEmpty();
            });
            for (let i2 = 0; i2 < elements.length; i2++) {
              this.insertElement(elements[i2], false);
            }
            this.emit("pasteHtml", data2, elements);
          }
        }
      }
    } else {
      for (let i = 0; i < length; i++) {
        const blob = blobs[i];
        if (blob.type.startsWith("image/")) {
          const url = await Util.blobToBase64(blob);
          if (!this.emit("pasteImage", url)) {
            const image = new AlexElement(
              "closed",
              "img",
              {
                src: url
              },
              null,
              null
            );
            this.insertElement(image);
          }
        } else if (blob.type.startsWith("video/")) {
          const url = await Util.blobToBase64(blob);
          if (!this.emit("pasteVideo", url)) {
            const video = new AlexElement(
              "closed",
              "video",
              {
                src: url
              },
              null,
              null
            );
            this.insertElement(video);
          }
        } else if (blob.type == "text/plain") {
          const data2 = await blob.text();
          if (data2) {
            this.insertText(data2);
            this.emit("pasteText", data2);
          }
        }
      }
    }
  }
  async cut() {
    if (!this.useClipboard) {
      return false;
    }
    const result = await this.copy(true);
    if (result) {
      this.delete();
      this.emit("cut");
    }
    return result;
  }
  async copy(isCut = false) {
    if (!this.useClipboard) {
      return false;
    }
    let result = this.getElementsByRange(true, false);
    if (result.length == 0) {
      return false;
    }
    let html = "";
    let text = "";
    result.forEach((item) => {
      const newEl = item.element.clone();
      if (item.offset) {
        newEl.textContent = newEl.textContent.substring(item.offset[0], item.offset[1]);
      }
      newEl.__renderElement();
      html += newEl._elm.outerHTML;
      text += newEl._elm.innerText;
    });
    const clipboardItem = new window.ClipboardItem({
      "text/html": new Blob([html], { type: "text/html" }),
      "text/plain": new Blob([text], { type: "text/plain" })
    });
    await navigator.clipboard.write([clipboardItem]);
    if (!isCut) {
      this.emit("copy");
    }
    return true;
  }
  delete() {
    if (this.range.anchor.isEqual(this.range.focus)) {
      const previousElement = this.getPreviousElementOfPoint(this.range.anchor);
      const block2 = this.range.anchor.element.getBlock();
      const inblock2 = this.range.anchor.element.getInblock();
      if (inblock2) {
        if (this.range.anchor.offset == 0) {
          if (previousElement) {
            if (inblock2.isContains(previousElement)) {
              this.range.anchor.moveToEnd(previousElement);
              this.range.focus.moveToEnd(previousElement);
              this.delete();
              return;
            } else if (inblock2.behavior == "block") {
              const previousBlock = previousElement.getBlock();
              const previousInblock = previousElement.getInblock();
              if (previousInblock) {
                if (previousInblock.behavior == "block") {
                  this.mergeBlockElement(inblock2, previousInblock);
                }
              } else {
                this.mergeBlockElement(inblock2, previousBlock);
              }
            }
          } else {
            this.emit("deleteInStart", inblock2);
          }
        } else {
          if (this.range.anchor.element.isSpaceText()) {
            this.range.anchor.element.toEmpty();
            if (inblock2.isEmpty()) {
              const breakEl = new AlexElement("closed", "br", null, null, null);
              this.addElementTo(breakEl, inblock2);
              this.range.anchor.moveToStart(breakEl);
              this.range.focus.moveToStart(breakEl);
            } else {
              this.range.anchor.offset = 0;
              this.range.focus.offset = 0;
              this.delete();
              return;
            }
          } else if (this.range.anchor.element.isText()) {
            const val = this.range.anchor.element.textContent;
            this.range.anchor.offset -= 1;
            const isSpaceText = Util.isSpaceText(val[this.range.anchor.offset]);
            this.range.anchor.element.textContent = val.substring(0, this.range.anchor.offset) + val.substring(this.range.focus.offset);
            this.range.focus.offset = this.range.anchor.offset;
            if (isSpaceText) {
              this.delete();
              return;
            }
            if (inblock2.isEmpty()) {
              const breakEl = new AlexElement("closed", "br", null, null, null);
              this.addElementTo(breakEl, inblock2);
              this.range.anchor.moveToStart(breakEl);
              this.range.focus.moveToStart(breakEl);
            }
          } else {
            const isBreak = this.range.anchor.element.isBreak();
            this.range.anchor.element.toEmpty();
            if (inblock2.isEmpty()) {
              if (!isBreak || inblock2.behavior == "default") {
                const breakEl = new AlexElement("closed", "br", null, null, null);
                this.addElementTo(breakEl, inblock2);
                this.range.anchor.moveToStart(breakEl);
                this.range.focus.moveToStart(breakEl);
              } else if (!previousElement) {
                const breakEl = new AlexElement("closed", "br", null, null, null);
                this.addElementTo(breakEl, inblock2);
                this.range.anchor.moveToStart(breakEl);
                this.range.focus.moveToStart(breakEl);
              }
            }
          }
        }
      } else {
        if (this.range.anchor.offset == 0) {
          if (previousElement) {
            if (block2.isContains(previousElement)) {
              this.range.anchor.moveToEnd(previousElement);
              this.range.focus.moveToEnd(previousElement);
              this.delete();
              return;
            } else {
              const previousInblock = previousElement.getInblock();
              const previousBlock = previousElement.getBlock();
              if (previousInblock) {
                if (previousInblock.behavior == "block") {
                  this.mergeBlockElement(block2, previousInblock);
                }
              } else {
                this.mergeBlockElement(block2, previousBlock);
              }
            }
          } else {
            this.emit("deleteInStart", block2);
          }
        } else {
          if (this.range.anchor.element.isSpaceText()) {
            this.range.anchor.element.toEmpty();
            if (block2.isEmpty()) {
              const breakEl = new AlexElement("closed", "br", null, null, null);
              this.addElementTo(breakEl, block2);
              this.range.anchor.moveToStart(breakEl);
              this.range.focus.moveToStart(breakEl);
            } else {
              this.range.anchor.offset = 0;
              this.range.focus.offset = 0;
              this.delete();
              return;
            }
          } else if (this.range.anchor.element.isText()) {
            const val = this.range.anchor.element.textContent;
            this.range.anchor.offset -= 1;
            const isSpaceText = Util.isSpaceText(val[this.range.anchor.offset]);
            this.range.anchor.element.textContent = val.substring(0, this.range.anchor.offset) + val.substring(this.range.focus.offset);
            this.range.focus.offset = this.range.anchor.offset;
            if (isSpaceText) {
              this.delete();
              return;
            }
            if (block2.isEmpty()) {
              const breakEl = new AlexElement("closed", "br", null, null, null);
              this.addElementTo(breakEl, block2);
              this.range.anchor.moveToStart(breakEl);
              this.range.focus.moveToStart(breakEl);
            }
          } else {
            const isBreak = this.range.anchor.element.isBreak();
            this.range.anchor.element.toEmpty();
            if (block2.isEmpty()) {
              if (!isBreak || !previousElement) {
                const breakEl = new AlexElement("closed", "br", null, null, null);
                this.addElementTo(breakEl, block2);
                this.range.anchor.moveToStart(breakEl);
                this.range.focus.moveToStart(breakEl);
              }
            }
          }
        }
      }
    } else {
      const result = this.getElementsByRange(true, false).filter((item) => {
        return !AlexElement.VOID_NODES.includes(item.element.parsedom);
      });
      const anchorInblock = this.range.anchor.element.getInblock();
      const focusInblock = this.range.focus.element.getInblock();
      const anchorBlock = this.range.anchor.element.getBlock();
      const focusBlock = this.range.focus.element.getBlock();
      if (anchorInblock && focusInblock && anchorInblock.isEqual(focusInblock)) {
        result.forEach((item) => {
          if (item.offset) {
            item.element.textContent = item.element.textContent.substring(0, item.offset[0]) + item.element.textContent.substring(item.offset[1]);
          } else {
            item.element.toEmpty();
          }
          if (anchorInblock.isEmpty()) {
            const breakEl = new AlexElement("closed", "br", null, null, null);
            this.addElementTo(breakEl, anchorInblock);
          }
        });
      } else if (anchorInblock && focusInblock) {
        result.forEach((item) => {
          if (item.offset) {
            item.element.textContent = item.element.textContent.substring(0, item.offset[0]) + item.element.textContent.substring(item.offset[1]);
          } else {
            if (item.element.isInblock() && item.element.behavior == "default") {
              this.__emptyDefaultBehaviorInblock(item.element);
            } else {
              item.element.toEmpty();
              if (item.element.parent && (item.element.parent.isInblock() || item.element.parent.isBlock()) && item.element.parent.isEmpty()) {
                const breakEl = new AlexElement("closed", "br", null, null, null);
                this.addElementTo(breakEl, item.element.parent);
              }
            }
          }
        });
        if (anchorInblock.behavior == "block" && focusInblock.behavior == "block") {
          this.mergeBlockElement(focusInblock, anchorInblock);
        }
      } else if (anchorInblock) {
        result.forEach((item) => {
          if (item.offset) {
            item.element.textContent = item.element.textContent.substring(0, item.offset[0]) + item.element.textContent.substring(item.offset[1]);
          } else {
            if (item.element.isInblock() && item.element.behavior == "default") {
              this.__emptyDefaultBehaviorInblock(item.element);
            } else {
              item.element.toEmpty();
              if (item.element.parent && (item.element.parent.isInblock() || item.element.parent.isBlock()) && item.element.parent.isEmpty()) {
                const breakEl = new AlexElement("closed", "br", null, null, null);
                this.addElementTo(breakEl, item.element.parent);
              }
            }
          }
        });
        if (anchorInblock.behavior == "block") {
          this.mergeBlockElement(focusBlock, anchorInblock);
        }
      } else if (focusInblock) {
        result.forEach((item) => {
          if (item.offset) {
            item.element.textContent = item.element.textContent.substring(0, item.offset[0]) + item.element.textContent.substring(item.offset[1]);
          } else {
            if (item.element.isInblock() && item.element.behavior == "default") {
              this.__emptyDefaultBehaviorInblock(item.element);
            } else {
              item.element.toEmpty();
              if (item.element.parent && (item.element.parent.isInblock() || item.element.parent.isBlock()) && item.element.parent.isEmpty()) {
                const breakEl = new AlexElement("closed", "br", null, null, null);
                this.addElementTo(breakEl, item.element.parent);
              }
            }
          }
        });
        if (focusInblock.behavior == "block") {
          this.mergeBlockElement(focusInblock, anchorBlock);
        }
      } else if (anchorBlock.isEqual(focusBlock)) {
        result.forEach((item) => {
          if (item.offset) {
            item.element.textContent = item.element.textContent.substring(0, item.offset[0]) + item.element.textContent.substring(item.offset[1]);
          } else {
            item.element.toEmpty();
          }
          if (anchorBlock.isEmpty()) {
            const breakEl = new AlexElement("closed", "br", null, null, null);
            this.addElementTo(breakEl, anchorBlock);
          }
        });
      } else {
        result.forEach((item) => {
          if (item.offset) {
            item.element.textContent = item.element.textContent.substring(0, item.offset[0]) + item.element.textContent.substring(item.offset[1]);
          } else {
            if (item.element.isInblock() && item.element.behavior == "default") {
              this.__emptyDefaultBehaviorInblock(item.element);
            } else {
              item.element.toEmpty();
              if (item.element.parent && (item.element.parent.isInblock() || item.element.parent.isBlock()) && item.element.parent.isEmpty()) {
                const breakEl = new AlexElement("closed", "br", null, null, null);
                this.addElementTo(breakEl, item.element.parent);
              }
            }
          }
        });
        this.mergeBlockElement(focusBlock, anchorBlock);
      }
    }
    if (this.range.anchor.element.isEmpty()) {
      this.__setRecentlyPoint(this.range.anchor);
    }
    this.range.focus.element = this.range.anchor.element;
    this.range.focus.offset = this.range.anchor.offset;
  }
  insertText(data2) {
    if (!data2 || typeof data2 != "string") {
      throw new Error("The argument must be a string");
    }
    if (this.range.anchor.isEqual(this.range.focus)) {
      if (!this.range.anchor.element.isPreStyle()) {
        data2 = data2.replace(/\s/g, () => {
          const span = document.createElement("span");
          span.innerHTML = "&nbsp;";
          return span.innerText;
        });
      }
      if (this.range.anchor.element.isText()) {
        let val = this.range.anchor.element.textContent;
        this.range.anchor.element.textContent = val.substring(0, this.range.anchor.offset) + data2 + val.substring(this.range.anchor.offset);
        this.range.anchor.offset = this.range.anchor.offset + data2.length;
        this.range.focus.offset = this.range.anchor.offset;
      } else {
        const textEl = new AlexElement("text", null, null, null, data2);
        if (this.range.anchor.offset == 0) {
          this.addElementBefore(textEl, this.range.anchor.element);
        } else {
          this.addElementAfter(textEl, this.range.anchor.element);
        }
        this.range.anchor.moveToEnd(textEl);
        this.range.focus.moveToEnd(textEl);
      }
    } else {
      this.delete();
      this.insertText(data2);
    }
  }
  insertParagraph() {
    if (this.range.anchor.isEqual(this.range.focus)) {
      const previousElement = this.getPreviousElementOfPoint(this.range.anchor);
      const nextElement = this.getNextElementOfPoint(this.range.anchor);
      const block2 = this.range.anchor.element.getBlock();
      const inblock2 = this.range.anchor.element.getInblock();
      const endOffset = this.range.anchor.element.isText() ? this.range.anchor.element.textContent.length : 1;
      if (inblock2) {
        if (this.range.anchor.element.isPreStyle()) {
          this.insertText("\n");
          const text = AlexElement.getSpaceElement();
          this.insertElement(text);
          this.range.anchor.moveToEnd(text);
          this.range.focus.moveToEnd(text);
          this.emit("insertParagraph", null, inblock2);
        } else if (inblock2.behavior == "block") {
          if (this.range.anchor.offset == 0 && !(previousElement && inblock2.isContains(previousElement))) {
            const paragraph = inblock2.clone(false);
            const breakEle = new AlexElement("closed", "br", null, null, null);
            this.addElementTo(breakEle, paragraph);
            this.addElementBefore(paragraph, inblock2);
            this.emit("insertParagraph", inblock2, paragraph);
          } else if (this.range.anchor.offset == endOffset && !(nextElement && inblock2.isContains(nextElement))) {
            const paragraph = inblock2.clone(false);
            const breakEle = new AlexElement("closed", "br", null, null, null);
            this.addElementTo(breakEle, paragraph);
            this.addElementAfter(paragraph, inblock2);
            this.range.anchor.moveToStart(breakEle);
            this.range.focus.moveToStart(breakEle);
            this.emit("insertParagraph", paragraph, inblock2);
          } else {
            const newInblock = inblock2.clone();
            this.addElementAfter(newInblock, inblock2);
            const elements = AlexElement.flatElements(inblock2.children);
            const index = elements.findIndex((item) => {
              return this.range.anchor.element.isEqual(item);
            });
            this.range.focus.moveToEnd(inblock2);
            this.delete();
            const newElements = AlexElement.flatElements(newInblock.children);
            this.range.focus.element = newElements[index];
            this.range.focus.offset = this.range.anchor.offset;
            this.range.anchor.moveToStart(newInblock);
            this.delete();
            this.emit("insertParagraph", newInblock, inblock2);
          }
        }
      } else {
        if (this.range.anchor.element.isPreStyle()) {
          this.insertText("\n");
          const text = AlexElement.getSpaceElement();
          this.insertElement(text);
          this.range.anchor.moveToEnd(text);
          this.range.focus.moveToEnd(text);
          this.emit("insertParagraph", null, block2);
        } else {
          if (this.range.anchor.offset == 0 && !(previousElement && block2.isContains(previousElement))) {
            const paragraph = block2.clone(false);
            const breakEle = new AlexElement("closed", "br", null, null, null);
            this.addElementTo(breakEle, paragraph);
            this.addElementBefore(paragraph, block2);
            this.emit("insertParagraph", block2, paragraph);
          } else if (this.range.anchor.offset == endOffset && !(nextElement && block2.isContains(nextElement))) {
            const paragraph = block2.clone(false);
            const breakEle = new AlexElement("closed", "br", null, null, null);
            this.addElementTo(breakEle, paragraph);
            this.addElementAfter(paragraph, block2);
            this.range.anchor.moveToStart(breakEle);
            this.range.focus.moveToStart(breakEle);
            this.emit("insertParagraph", paragraph, block2);
          } else {
            const newBlock = block2.clone();
            this.addElementAfter(newBlock, block2);
            const elements = AlexElement.flatElements(block2.children);
            const index = elements.findIndex((item) => {
              return this.range.anchor.element.isEqual(item);
            });
            this.range.focus.moveToEnd(block2);
            this.delete();
            const newElements = AlexElement.flatElements(newBlock.children);
            this.range.focus.element = newElements[index];
            this.range.focus.offset = this.range.anchor.offset;
            this.range.anchor.moveToStart(newBlock);
            this.delete();
            this.emit("insertParagraph", newBlock, block2);
          }
        }
      }
    } else {
      this.delete();
      this.insertParagraph();
    }
  }
  insertElement(ele, cover = true) {
    if (!AlexElement.isElement(ele)) {
      throw new Error("The argument must be an AlexElement instance");
    }
    if (ele.isEmpty()) {
      return;
    }
    if (this.range.anchor.isEqual(this.range.focus)) {
      const previousElement = this.getPreviousElementOfPoint(this.range.anchor);
      const nextElement = this.getNextElementOfPoint(this.range.anchor);
      const block2 = this.range.anchor.element.getBlock();
      const inblock2 = this.range.anchor.element.getInblock();
      const endOffset = this.range.anchor.element.isText() ? this.range.anchor.element.textContent.length : 1;
      if (ele.isInblock() && ele.behavior == "block" && inblock2 && inblock2.behavior == "block") {
        if (inblock2.isOnlyHasBreak() && cover) {
          this.addElementBefore(ele, inblock2);
          inblock2.toEmpty();
        } else if (this.range.anchor.offset == 0 && !(previousElement && inblock2.isContains(previousElement))) {
          this.addElementBefore(ele, inblock2);
        } else if (this.range.anchor.offset == endOffset && !(nextElement && inblock2.isContains(nextElement))) {
          this.addElementAfter(ele, inblock2);
        } else {
          const newInblock = inblock2.clone();
          this.addElementAfter(newInblock, inblock2);
          this.range.focus.moveToEnd(inblock2);
          this.delete();
          const elements = AlexElement.flatElements(inblock2.children);
          const index = elements.findIndex((item) => {
            return this.range.anchor.element.isEqual(item);
          });
          const newElements = AlexElement.flatElements(newInblock.children);
          this.range.focus.element = newElements[index];
          this.range.focus.offset = this.range.anchor.offset;
          this.range.anchor.moveToStart(newInblock);
          this.delete();
          this.addElementBefore(ele, newInblock);
        }
      } else if (ele.isInblock() && inblock2) {
        if (inblock2.isOnlyHasBreak()) {
          this.addElementTo(ele, inblock2, 0);
        } else if (this.range.anchor.offset == 0 && !(previousElement && inblock2.isContains(previousElement))) {
          this.addElementTo(ele, inblock2, 0);
        } else if (this.range.anchor.offset == endOffset && !(nextElement && inblock2.isContains(nextElement))) {
          this.addElementTo(ele, inblock2, inblock2.children.length);
        } else {
          const newInblock = inblock2.clone();
          this.addElementAfter(newInblock, inblock2);
          this.range.focus.moveToEnd(inblock2);
          this.delete();
          const elements = AlexElement.flatElements(inblock2.children);
          const index = elements.findIndex((item) => {
            return this.range.anchor.element.isEqual(item);
          });
          const newElements = AlexElement.flatElements(newInblock.children);
          this.range.focus.element = newElements[index];
          this.range.focus.offset = this.range.anchor.offset;
          this.range.anchor.moveToStart(newInblock);
          this.delete();
          this.addElementTo(ele, newInblock);
          this.mergeBlockElement(newInblock, inblock2);
        }
      } else if (ele.isInblock()) {
        if (block2.isOnlyHasBreak()) {
          this.addElementTo(ele, block2, 0);
        } else if (this.range.anchor.offset == 0 && !(previousElement && block2.isContains(previousElement))) {
          this.addElementTo(ele, block2, 0);
        } else if (this.range.anchor.offset == endOffset && !(nextElement && block2.isContains(nextElement))) {
          this.addElementTo(ele, block2, block2.children.length);
        } else {
          const newBlock = block2.clone();
          this.addElementAfter(newBlock, block2);
          this.range.focus.moveToEnd(block2);
          this.delete();
          const elements = AlexElement.flatElements(block2.children);
          const index = elements.findIndex((item) => {
            return this.range.anchor.element.isEqual(item);
          });
          const newElements = AlexElement.flatElements(newBlock.children);
          this.range.focus.element = newElements[index];
          this.range.focus.offset = this.range.anchor.offset;
          this.range.anchor.moveToStart(newBlock);
          this.delete();
          this.addElementTo(ele, newBlock);
          this.mergeBlockElement(newBlock, block2);
        }
      } else if (ele.isBlock()) {
        if (block2.isOnlyHasBreak() && cover) {
          this.addElementBefore(ele, block2);
          block2.toEmpty();
        } else if (this.range.anchor.offset == 0 && !(previousElement && block2.isContains(previousElement))) {
          this.addElementBefore(ele, block2);
        } else if (this.range.anchor.offset == endOffset && !(nextElement && block2.isContains(nextElement))) {
          this.addElementAfter(ele, block2);
        } else {
          const newBlock = block2.clone();
          this.addElementAfter(newBlock, block2);
          this.range.focus.moveToEnd(block2);
          this.delete();
          const elements = AlexElement.flatElements(block2.children);
          const index = elements.findIndex((item) => {
            return this.range.anchor.element.isEqual(item);
          });
          const newElements = AlexElement.flatElements(newBlock.children);
          this.range.focus.element = newElements[index];
          this.range.focus.offset = this.range.anchor.offset;
          this.range.anchor.moveToStart(newBlock);
          this.delete();
          this.addElementBefore(ele, newBlock);
        }
      } else {
        if (this.range.anchor.element.isText()) {
          let val = this.range.anchor.element.textContent;
          let newText = this.range.anchor.element.clone();
          this.range.anchor.element.textContent = val.substring(0, this.range.anchor.offset);
          newText.textContent = val.substring(this.range.anchor.offset);
          this.addElementAfter(newText, this.range.anchor.element);
          this.addElementBefore(ele, newText);
        } else {
          if (this.range.anchor.offset == 0) {
            this.addElementBefore(ele, this.range.anchor.element);
          } else {
            this.addElementAfter(ele, this.range.anchor.element);
          }
        }
      }
      this.range.anchor.moveToEnd(ele);
      this.range.focus.moveToEnd(ele);
    } else {
      this.delete();
      this.insertElement(ele, cover);
    }
  }
  formatElementStack() {
    let renderRules = this.renderRules.filter((fn) => {
      return typeof fn == "function";
    });
    const format = (element2) => {
      [...renderRules, ...this.__formatUnchangeableRules].forEach((fn) => {
        fn.apply(this, [element2]);
      });
      if (element2.hasChildren()) {
        let index2 = 0;
        while (index2 < element2.children.length) {
          const ele = element2.children[index2];
          if (ele.isEmpty()) {
            if (ele.isContains(this.range.anchor.element)) {
              this.__setRecentlyPoint(this.range.anchor);
            }
            if (ele.isContains(this.range.focus.element)) {
              this.__setRecentlyPoint(this.range.focus);
            }
            element2.children.splice(index2, 1);
            continue;
          }
          format(ele);
          if (ele.isEmpty()) {
            if (ele.isContains(this.range.anchor.element)) {
              this.__setRecentlyPoint(this.range.anchor);
            }
            if (ele.isContains(this.range.focus.element)) {
              this.__setRecentlyPoint(this.range.focus);
            }
            element2.children.splice(index2, 1);
            continue;
          }
          index2++;
        }
      }
    };
    let index = 0;
    while (index < this.stack.length) {
      const ele = this.stack[index];
      if (ele.isEmpty()) {
        if (ele.isContains(this.range.anchor.element)) {
          this.__setRecentlyPoint(this.range.anchor);
        }
        if (ele.isContains(this.range.focus.element)) {
          this.__setRecentlyPoint(this.range.focus);
        }
        this.stack.splice(index, 1);
        continue;
      }
      if (!ele.isBlock()) {
        ele.convertToBlock();
      }
      format(ele);
      if (ele.isEmpty()) {
        if (ele.isContains(this.range.anchor.element)) {
          this.__setRecentlyPoint(this.range.anchor);
        }
        if (ele.isContains(this.range.focus.element)) {
          this.__setRecentlyPoint(this.range.focus);
        }
        this.stack.splice(index, 1);
        continue;
      }
      index++;
    }
    if (this.stack.length == 0) {
      const ele = new AlexElement("block", AlexElement.BLOCK_NODE, null, null, null);
      const breakEle = new AlexElement("closed", "br", null, null, null);
      this.addElementTo(breakEle, ele);
      this.stack = [ele];
      this.range.anchor.moveToStart(breakEle);
      this.range.focus.moveToStart(breakEle);
    }
  }
  domRender(unPushHistory = false) {
    this.emit("beforeRender");
    this.$el.innerHTML = "";
    this.stack.forEach((element2) => {
      element2.__renderElement();
      this.$el.appendChild(element2._elm);
    });
    const oldValue = this.value;
    this.value = this.$el.innerHTML;
    if (oldValue != this.value) {
      this.__oldValue = oldValue;
      this.emit("change", this.value, this.__oldValue);
      if (!unPushHistory) {
        this.history.push(this.stack, this.range);
      }
    }
    this.emit("afterRender");
  }
  rangeRender() {
    if (this.disabled) {
      return;
    }
    const handler = (point) => {
      let node = null;
      let offset = null;
      if (point.element.isText()) {
        node = point.element._elm.childNodes[0];
        offset = point.offset;
      } else {
        node = point.element.parent._elm;
        const index = point.element.parent.children.findIndex((item) => {
          return point.element.isEqual(item);
        });
        offset = point.offset + index;
      }
      return { node, offset };
    };
    this.__innerSelectionChange = true;
    const anchorResult = handler(this.range.anchor);
    const focusResult = handler(this.range.focus);
    const selection = window.getSelection();
    selection.removeAllRanges();
    const range = document.createRange();
    range.setStart(anchorResult.node, anchorResult.offset);
    range.setEnd(focusResult.node, focusResult.offset);
    selection.addRange(range);
    setTimeout(() => {
      this.__setRangeInVisible();
      this.__innerSelectionChange = false;
      this.emit("rangeUpdate", this.range);
    }, 0);
  }
  parseHtml(html) {
    if (!html) {
      throw new Error("You need to give an html content to convert");
    }
    const node = document.createElement("div");
    node.innerHTML = html;
    let elements = [];
    Array.from(node.childNodes).forEach((el) => {
      if (el.nodeType == 1 || el.nodeType == 3) {
        const element2 = this.parseNode(el);
        elements.push(element2);
      }
    });
    return elements;
  }
  parseNode(node) {
    if (!(node instanceof Node)) {
      throw new Error("The argument must be an node");
    }
    if (!(node.nodeType == 1 || node.nodeType == 3)) {
      throw new Error("The argument must be an element node or text node");
    }
    if (node.nodeType == 3) {
      return new AlexElement("text", null, null, null, node.textContent);
    }
    const marks = Util.getAttributes(node);
    const styles = Util.getStyles(node);
    const parsedom = node.nodeName.toLocaleLowerCase();
    const block2 = defaultConfig.block.find((item) => item.parsedom == parsedom);
    const inblock2 = defaultConfig.inblock.find((item) => item.parsedom == parsedom);
    const inline2 = defaultConfig.inline.find((item) => item.parsedom == parsedom);
    const closed2 = defaultConfig.closed.find((item) => item.parsedom == parsedom);
    let element2 = null;
    let config = {
      type: "inblock",
      parsedom,
      marks,
      styles,
      behavior: "default"
    };
    if (block2) {
      config.type = "block";
      if (block2.parse) {
        config.parsedom = AlexElement.BLOCK_NODE;
      }
    } else if (inblock2) {
      config.type = "inblock";
      if (inblock2.block) {
        config.behavior = "block";
      }
    } else if (inline2) {
      config.type = "inline";
      if (inline2.parse) {
        config.parsedom = AlexElement.TEXT_NODE;
        if (obj.common.isObject(inline2.parse)) {
          Object.assign(config.styles, Util.clone(inline2.parse));
        }
      }
    } else if (closed2) {
      config.type = "closed";
    } else {
      config.type = "inline";
      config.parsedom = "span";
    }
    element2 = new AlexElement(config.type, config.parsedom, config.marks, config.styles, null);
    element2.behavior = config.behavior;
    if (block2 || inblock2 || inline2) {
      Array.from(node.childNodes).forEach((childNode) => {
        if (childNode.nodeType == 1 || childNode.nodeType == 3) {
          const childEle = this.parseNode(childNode);
          childEle.parent = element2;
          if (element2.hasChildren()) {
            element2.children.push(childEle);
          } else {
            element2.children = [childEle];
          }
        }
      });
    }
    return element2;
  }
  mergeBlockElement(ele, previousEle) {
    if (!AlexElement.isElement(ele)) {
      throw new Error("The first argument must be an AlexElement instance");
    }
    if (!AlexElement.isElement(previousEle)) {
      throw new Error("The second argument must be an AlexElement instance");
    }
    if (!ele.isBlock() && !ele.isInblock() || !previousEle.isBlock() && !previousEle.isInblock()) {
      throw new Error('Elements that are not "block" or "inblock" cannot be merged');
    }
    previousEle.children.push(...ele.children);
    previousEle.children.forEach((item) => {
      item.parent = previousEle;
    });
    ele.children = null;
  }
  getElementByKey(key) {
    if (!key) {
      throw new Error("You need to specify a key to do the query");
    }
    const fn = (elements) => {
      let element2 = null;
      let i = 0;
      let length = elements.length;
      while (i < length) {
        if (elements[i].key == key) {
          element2 = elements[i];
          break;
        }
        if (elements[i].hasChildren()) {
          const el = fn(elements[i].children);
          if (el) {
            element2 = el;
            break;
          }
        }
        i++;
      }
      return element2;
    };
    return fn(this.stack);
  }
  getPreviousElement(ele) {
    if (!AlexElement.isElement(ele)) {
      throw new Error("The argument must be an AlexElement instance");
    }
    if (ele.isBlock()) {
      const index = this.stack.findIndex((item) => {
        return ele.isEqual(item);
      });
      if (index <= 0) {
        return null;
      }
      if (this.stack[index - 1].isEmpty()) {
        return this.getPreviousElement(this.stack[index - 1]);
      }
      return this.stack[index - 1];
    } else {
      const index = ele.parent.children.findIndex((item) => {
        return ele.isEqual(item);
      });
      if (index <= 0) {
        return null;
      }
      if (ele.parent.children[index - 1].isEmpty()) {
        return this.getPreviousElement(ele.parent.children[index - 1]);
      }
      return ele.parent.children[index - 1];
    }
  }
  getNextElement(ele) {
    if (!AlexElement.isElement(ele)) {
      throw new Error("The argument must be an AlexElement instance");
    }
    if (ele.isBlock()) {
      const index = this.stack.findIndex((item) => {
        return ele.isEqual(item);
      });
      if (index >= this.stack.length - 1) {
        return null;
      }
      if (this.stack[index + 1].isEmpty()) {
        return this.getNextElement(this.stack[index + 1]);
      }
      return this.stack[index + 1];
    } else {
      const index = ele.parent.children.findIndex((item) => {
        return ele.isEqual(item);
      });
      if (index >= ele.parent.children.length - 1) {
        return null;
      }
      if (ele.parent.children[index + 1].isEmpty()) {
        return this.getNextElement(ele.parent.children[index + 1]);
      }
      return ele.parent.children[index + 1];
    }
  }
  getPreviousElementOfPoint(point) {
    if (!AlexPoint.isPoint(point)) {
      throw new Error("The argument must be an AlexPoint instance");
    }
    const flatElements = AlexElement.flatElements(this.stack);
    const fn = (element2) => {
      const index = flatElements.findIndex((item) => {
        return element2.isEqual(item);
      });
      if (index <= 0) {
        return null;
      }
      let ele = flatElements[index - 1];
      if ((ele.isText() || ele.isClosed()) && !ele.isEmpty()) {
        return ele;
      }
      return fn(ele);
    };
    return fn(point.element);
  }
  getNextElementOfPoint(point) {
    if (!AlexPoint.isPoint(point)) {
      throw new Error("The argument must be an AlexPoint instance");
    }
    const flatElements = AlexElement.flatElements(this.stack);
    const fn = (element2) => {
      const index = flatElements.findIndex((item) => {
        return element2.isEqual(item);
      });
      if (index == flatElements.length - 1) {
        return null;
      }
      let ele = flatElements[index + 1];
      if ((ele.isText() || ele.isClosed()) && !ele.isEmpty()) {
        return ele;
      }
      return fn(ele);
    };
    return fn(point.element);
  }
  getElementsByRange(includes = false, flat = false) {
    if (this.range.anchor.isEqual(this.range.focus)) {
      return [];
    }
    if (this.range.anchor.element.isEqual(this.range.focus.element)) {
      if (includes) {
        const isCover = this.range.anchor.offset == 0 && this.range.focus.offset == (this.range.anchor.element.isText() ? this.range.anchor.element.textContent.length : 1);
        return [
          {
            element: this.range.anchor.element,
            offset: isCover ? false : [this.range.anchor.offset, this.range.focus.offset]
          }
        ];
      }
      return [];
    }
    let result = [];
    if (includes) {
      if (this.range.anchor.offset == 0) {
        result.push({
          element: this.range.anchor.element,
          offset: false
        });
      } else if (this.range.anchor.offset < (this.range.anchor.element.isText() ? this.range.anchor.element.textContent.length : 1)) {
        result.push({
          element: this.range.anchor.element,
          offset: [this.range.anchor.offset, this.range.anchor.element.isText() ? this.range.anchor.element.textContent.length : 1]
        });
      }
    }
    const elements = AlexElement.flatElements(this.stack);
    const anchorIndex = elements.findIndex((el) => el.isEqual(this.range.anchor.element));
    const focusIndex = elements.findIndex((el) => el.isEqual(this.range.focus.element));
    for (let i = anchorIndex + 1; i < focusIndex; i++) {
      result.push({
        element: elements[i],
        offset: false
      });
    }
    if (includes) {
      if (this.range.focus.offset == (this.range.focus.element.isText() ? this.range.focus.element.textContent.length : 1)) {
        result.push({
          element: this.range.focus.element,
          offset: false
        });
      } else if (this.range.focus.offset > 0) {
        result.push({
          element: this.range.focus.element,
          offset: [0, this.range.focus.offset]
        });
      }
    }
    const resLength = result.length;
    let newResult = [];
    for (let i = resLength - 1; i >= 0; i--) {
      if (result[i].element.hasChildren()) {
        let allIn = result[i].element.children.every((child) => {
          return newResult.some((item) => {
            return item.element.isEqual(child) && !item.offset;
          });
        });
        if (allIn) {
          newResult.unshift(result[i]);
        }
      } else {
        newResult.unshift(result[i]);
      }
    }
    if (flat) {
      return newResult;
    }
    let notFlatResult = [];
    const length = newResult.length;
    for (let i = 0; i < length; i++) {
      if (newResult[i].element.isBlock()) {
        notFlatResult.push(newResult[i]);
      } else {
        const isIn = newResult.some((item) => item.element.isEqual(newResult[i].element.parent));
        if (!isIn) {
          notFlatResult.push(newResult[i]);
        }
      }
    }
    return notFlatResult;
  }
  splitElementsByRange(includes = false, flat = false) {
    const result = this.getElementsByRange(includes, flat);
    let elements = [];
    result.forEach((item, index) => {
      if (item.offset) {
        let selectEl = null;
        if (item.offset[0] == 0) {
          const el = item.element.clone();
          item.element.textContent = item.element.textContent.substring(0, item.offset[1]);
          el.textContent = el.textContent.substring(item.offset[1]);
          this.addElementAfter(el, item.element);
          selectEl = item.element;
        } else if (item.offset[1] == item.element.textContent.length) {
          const el = item.element.clone();
          item.element.textContent = item.element.textContent.substring(0, item.offset[0]);
          el.textContent = el.textContent.substring(item.offset[0]);
          this.addElementAfter(el, item.element);
          selectEl = el;
        } else {
          const el = item.element.clone();
          const el2 = item.element.clone();
          item.element.textContent = item.element.textContent.substring(0, item.offset[0]);
          el.textContent = el.textContent.substring(item.offset[0], item.offset[1]);
          el2.textContent = el2.textContent.substring(item.offset[1]);
          this.addElementAfter(el, item.element);
          this.addElementAfter(el2, el);
          selectEl = el;
        }
        if (index == 0) {
          this.range.anchor.moveToStart(selectEl);
        }
        if (index == result.length - 1) {
          this.range.focus.moveToEnd(selectEl);
        }
        elements.push(selectEl);
      } else {
        elements.push(item.element);
      }
    });
    return elements;
  }
  addElementTo(childEle, parentEle, index = 0) {
    if (!AlexElement.isElement(childEle)) {
      throw new Error("The first argument must be an AlexElement instance");
    }
    if (!AlexElement.isElement(parentEle)) {
      throw new Error("The second argument must be an AlexElement instance");
    }
    if (typeof index != "number" || isNaN(index) || index < 0) {
      throw new Error("The third argument must be an integer not less than 0");
    }
    if (parentEle.hasChildren()) {
      if (index >= parentEle.children.length) {
        parentEle.children.push(childEle);
      } else {
        parentEle.children.splice(index, 0, childEle);
      }
    } else {
      parentEle.children = [childEle];
    }
    childEle.parent = parentEle;
  }
  addElementBefore(newEle, targetEle) {
    if (!AlexElement.isElement(newEle)) {
      throw new Error("The first argument must be an AlexElement instance");
    }
    if (!AlexElement.isElement(targetEle)) {
      throw new Error("The second argument must be an AlexElement instance");
    }
    if (targetEle.isBlock()) {
      const index = this.stack.findIndex((item) => {
        return targetEle.isEqual(item);
      });
      this.stack.splice(index, 0, newEle);
      newEle.parent = null;
    } else {
      const index = targetEle.parent.children.findIndex((item) => {
        return targetEle.isEqual(item);
      });
      this.addElementTo(newEle, targetEle.parent, index);
    }
  }
  addElementAfter(newEle, targetEle) {
    if (!AlexElement.isElement(newEle)) {
      throw new Error("The first argument must be an AlexElement instance");
    }
    if (!AlexElement.isElement(targetEle)) {
      throw new Error("The second argument must be an AlexElement instance");
    }
    if (targetEle.isBlock()) {
      const index = this.stack.findIndex((item) => {
        return targetEle.isEqual(item);
      });
      if (index >= this.stack.length - 1) {
        this.stack.push(newEle);
      } else {
        this.stack.splice(index + 1, 0, newEle);
      }
      newEle.parent = null;
    } else {
      const index = targetEle.parent.children.findIndex((item) => {
        return targetEle.isEqual(item);
      });
      this.addElementTo(newEle, targetEle.parent, index + 1);
    }
  }
  collapseToStart(element2) {
    if (this.disabled) {
      return;
    }
    if (AlexElement.isElement(element2)) {
      this.range.anchor.moveToStart(element2);
      this.range.focus.moveToStart(element2);
    } else {
      const flatElements = AlexElement.flatElements(this.stack);
      this.range.anchor.moveToStart(flatElements[0]);
      this.range.focus.moveToStart(flatElements[0]);
    }
  }
  collapseToEnd(element2) {
    if (this.disabled) {
      return;
    }
    if (AlexElement.isElement(element2)) {
      this.range.anchor.moveToEnd(element2);
      this.range.focus.moveToEnd(element2);
    } else {
      const flatElements = AlexElement.flatElements(this.stack);
      const length = flatElements.length;
      this.range.anchor.moveToEnd(flatElements[length - 1]);
      this.range.focus.moveToEnd(flatElements[length - 1]);
    }
  }
  setDisabled() {
    this.disabled = true;
    this.$el.removeAttribute("contenteditable");
  }
  setEnabled() {
    this.disabled = false;
    this.$el.setAttribute("contenteditable", true);
  }
  setTextStyle(styles) {
    if (!obj.common.isObject(styles)) {
      throw new Error("The argument must be an object");
    }
    if (this.range.anchor.isEqual(this.range.focus)) {
      if (this.range.anchor.element.isSpaceText()) {
        if (this.range.anchor.element.hasStyles()) {
          Object.assign(this.range.anchor.element.styles, Util.clone(styles));
        } else {
          this.range.anchor.element.styles = Util.clone(styles);
        }
      } else if (this.range.anchor.element.isText()) {
        const el = AlexElement.getSpaceElement();
        el.styles = Util.clone(this.range.anchor.element.styles);
        el.marks = Util.clone(this.range.anchor.element.marks);
        if (el.hasStyles()) {
          Object.assign(el.styles, Util.clone(styles));
        } else {
          el.styles = Util.clone(styles);
        }
        this.insertElement(el);
      } else {
        const el = AlexElement.getSpaceElement();
        el.styles = Util.clone(styles);
        this.insertElement(el);
      }
    } else {
      const elements = this.splitElementsByRange(true, true);
      elements.forEach((ele) => {
        if (ele.isText()) {
          if (ele.hasStyles()) {
            Object.assign(ele.styles, Util.clone(styles));
          } else {
            ele.styles = Util.clone(styles);
          }
        }
      });
    }
  }
  removeTextStyle(styleNames) {
    const removeFn = (el) => {
      if (Array.isArray(styleNames)) {
        if (el.hasStyles()) {
          let styles = {};
          Object.keys(el.styles).forEach((key) => {
            if (!styleNames.includes(key)) {
              styles[key] = el.styles[key];
            }
          });
          el.styles = styles;
        }
      } else {
        el.styles = null;
      }
    };
    if (this.range.anchor.isEqual(this.range.focus)) {
      if (this.range.anchor.element.isSpaceText()) {
        removeFn(this.range.anchor.element);
      } else if (this.range.anchor.element.isText()) {
        const el = AlexElement.getSpaceElement();
        el.styles = Util.clone(this.range.anchor.element.styles);
        el.marks = Util.clone(this.range.anchor.element.marks);
        removeFn(el);
        this.insertElement(el);
      }
    } else {
      const elements = this.splitElementsByRange(true, true);
      elements.forEach((ele) => {
        if (ele.isText()) {
          removeFn(ele);
        }
      });
    }
  }
  queryTextStyle(name, value) {
    if (!name) {
      throw new Error("The first argument cannot be null");
    }
    if (this.range.anchor.isEqual(this.range.focus)) {
      if (this.range.anchor.element.isText() && this.range.anchor.element.hasStyles()) {
        if (value == null || value == void 0) {
          return this.range.anchor.element.styles.hasOwnProperty(name);
        }
        return this.range.anchor.element.styles[name] == value;
      }
      return false;
    }
    const result = this.getElementsByRange(true, true).filter((item) => {
      return item.element.isText();
    });
    if (result.length == 0) {
      return false;
    }
    let flag = result.every((item) => {
      if (item.element.hasStyles()) {
        if (value == null || value == void 0) {
          return item.element.styles.hasOwnProperty(name);
        }
        return item.element.styles[name] == value;
      }
      return false;
    });
    return flag;
  }
  setTextMark(marks) {
    if (!obj.common.isObject(marks)) {
      throw new Error("The argument must be an object");
    }
    if (this.range.anchor.isEqual(this.range.focus)) {
      if (this.range.anchor.element.isSpaceText()) {
        if (this.range.anchor.element.hasMarks()) {
          Object.assign(this.range.anchor.element.marks, Util.clone(marks));
        } else {
          this.range.anchor.element.marks = Util.clone(marks);
        }
      } else if (this.range.anchor.element.isText()) {
        const el = AlexElement.getSpaceElement();
        el.styles = Util.clone(this.range.anchor.element.styles);
        el.marks = Util.clone(this.range.anchor.element.marks);
        if (el.hasMarks()) {
          Object.assign(el.marks, Util.clone(marks));
        } else {
          el.marks = Util.clone(marks);
        }
        this.insertElement(el);
      } else {
        const el = AlexElement.getSpaceElement();
        el.marks = Util.clone(marks);
        this.insertElement(el);
      }
    } else {
      const elements = this.splitElementsByRange(true, true);
      elements.forEach((ele) => {
        if (ele.isText()) {
          if (ele.hasMarks()) {
            Object.assign(ele.marks, Util.clone(marks));
          } else {
            ele.marks = Util.clone(marks);
          }
        }
      });
    }
  }
  removeTextMark(markNames) {
    const removeFn = (el) => {
      if (Array.isArray(markNames)) {
        if (el.hasMarks()) {
          let marks = {};
          Object.keys(el.marks).forEach((key) => {
            if (!markNames.includes(key)) {
              marks[key] = el.marks[key];
            }
          });
          el.marks = marks;
        }
      } else {
        el.marks = null;
      }
    };
    if (this.range.anchor.isEqual(this.range.focus)) {
      if (this.range.anchor.element.isSpaceText()) {
        removeFn(this.range.anchor.element);
      } else if (this.range.anchor.element.isText()) {
        const el = AlexElement.getSpaceElement();
        el.styles = Util.clone(this.range.anchor.element.styles);
        el.marks = Util.clone(this.range.anchor.element.marks);
        removeFn(el);
        this.insertElement(el);
      }
    } else {
      const elements = this.splitElementsByRange(true, true);
      elements.forEach((ele) => {
        if (ele.isText()) {
          removeFn(ele);
        }
      });
    }
  }
  queryTextMark(name, value) {
    if (!name) {
      throw new Error("The first argument cannot be null");
    }
    if (this.range.anchor.isEqual(this.range.focus)) {
      if (this.range.anchor.element.isText() && this.range.anchor.element.hasMarks()) {
        if (value == null || value == void 0) {
          return this.range.anchor.element.marks.hasOwnProperty(name);
        }
        return this.range.anchor.element.marks[name] == value;
      }
      return false;
    }
    const result = this.getElementsByRange(true, true).filter((item) => {
      return item.element.isText();
    });
    if (result.length == 0) {
      return false;
    }
    let flag = result.every((item) => {
      if (item.element.hasMarks()) {
        if (value == null || value == void 0) {
          return item.element.marks.hasOwnProperty(name);
        }
        return item.element.marks[name] == value;
      }
      return false;
    });
    return flag;
  }
  emit(eventName, ...value) {
    if (Array.isArray(this.__events[eventName])) {
      this.__events[eventName].forEach((fn) => {
        fn.apply(this, [...value]);
      });
      return true;
    }
    return false;
  }
  on(eventName, eventHandle) {
    if (!this.__events[eventName]) {
      this.__events[eventName] = [];
    }
    this.__events[eventName].push(eventHandle);
  }
  destroy() {
    this.setDisabled();
    obj.event.off(document, `selectionchange.alex_editor_${this.__guid}`);
    obj.event.off(this.$el, "beforeinput.alex_editor compositionstart.alex_editor compositionupdate.alex_editor compositionend.alex_editor keydown.alex_editor cut.alex_editor paste.alex_editor copy.alex_editor dragstart.alex_editor drop.alex_editor focus.alex_editor blur.alex_editor");
  }
}
const elementUtil = {
  isList(element2, ordered = false) {
    return element2.type == "block" && element2.parsedom == "div" && element2.hasMarks() && element2.marks["data-list"] == (ordered ? "ol" : "ul");
  },
  toParagraph(element2) {
    if (this.isList(element2, true) || this.isList(element2, false)) {
      let marks = {};
      for (let key in element2.marks) {
        if (key != "data-list" && key != "data-value") {
          marks[key] = element2.marks[key];
        }
      }
      element2.marks = marks;
    }
    element2.parsedom = AlexElement.BLOCK_NODE;
  },
  toList(element2, ordered = false) {
    element2.parsedom = "div";
    if (!element2.hasMarks()) {
      element2.marks = {};
    }
    element2.marks["data-list"] = ordered ? "ol" : "ul";
  }
};
function deepFreeze(obj2) {
  if (obj2 instanceof Map) {
    obj2.clear = obj2.delete = obj2.set = function() {
      throw new Error("map is read-only");
    };
  } else if (obj2 instanceof Set) {
    obj2.add = obj2.clear = obj2.delete = function() {
      throw new Error("set is read-only");
    };
  }
  Object.freeze(obj2);
  Object.getOwnPropertyNames(obj2).forEach((name) => {
    const prop = obj2[name];
    const type = typeof prop;
    if ((type === "object" || type === "function") && !Object.isFrozen(prop)) {
      deepFreeze(prop);
    }
  });
  return obj2;
}
class Response {
  constructor(mode) {
    if (mode.data === void 0)
      mode.data = {};
    this.data = mode.data;
    this.isMatchIgnored = false;
  }
  ignoreMatch() {
    this.isMatchIgnored = true;
  }
}
function escapeHTML(value) {
  return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function inherit$1(original, ...objects) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key in original) {
    result[key] = original[key];
  }
  objects.forEach(function(obj2) {
    for (const key in obj2) {
      result[key] = obj2[key];
    }
  });
  return result;
}
const SPAN_CLOSE = "</span>";
const emitsWrappingTags = (node) => {
  return !!node.scope;
};
const scopeToCSSClass = (name, { prefix }) => {
  if (name.startsWith("language:")) {
    return name.replace("language:", "language-");
  }
  if (name.includes(".")) {
    const pieces = name.split(".");
    return [
      `${prefix}${pieces.shift()}`,
      ...pieces.map((x, i) => `${x}${"_".repeat(i + 1)}`)
    ].join(" ");
  }
  return `${prefix}${name}`;
};
class HTMLRenderer {
  constructor(parseTree, options) {
    this.buffer = "";
    this.classPrefix = options.classPrefix;
    parseTree.walk(this);
  }
  addText(text) {
    this.buffer += escapeHTML(text);
  }
  openNode(node) {
    if (!emitsWrappingTags(node))
      return;
    const className = scopeToCSSClass(
      node.scope,
      { prefix: this.classPrefix }
    );
    this.span(className);
  }
  closeNode(node) {
    if (!emitsWrappingTags(node))
      return;
    this.buffer += SPAN_CLOSE;
  }
  value() {
    return this.buffer;
  }
  span(className) {
    this.buffer += `<span class="${className}">`;
  }
}
const newNode = (opts = {}) => {
  const result = { children: [] };
  Object.assign(result, opts);
  return result;
};
class TokenTree {
  constructor() {
    this.rootNode = newNode();
    this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  add(node) {
    this.top.children.push(node);
  }
  openNode(scope) {
    const node = newNode({ scope });
    this.add(node);
    this.stack.push(node);
  }
  closeNode() {
    if (this.stack.length > 1) {
      return this.stack.pop();
    }
    return void 0;
  }
  closeAllNodes() {
    while (this.closeNode())
      ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  walk(builder) {
    return this.constructor._walk(builder, this.rootNode);
  }
  static _walk(builder, node) {
    if (typeof node === "string") {
      builder.addText(node);
    } else if (node.children) {
      builder.openNode(node);
      node.children.forEach((child) => this._walk(builder, child));
      builder.closeNode(node);
    }
    return builder;
  }
  static _collapse(node) {
    if (typeof node === "string")
      return;
    if (!node.children)
      return;
    if (node.children.every((el) => typeof el === "string")) {
      node.children = [node.children.join("")];
    } else {
      node.children.forEach((child) => {
        TokenTree._collapse(child);
      });
    }
  }
}
class TokenTreeEmitter extends TokenTree {
  constructor(options) {
    super();
    this.options = options;
  }
  addText(text) {
    if (text === "") {
      return;
    }
    this.add(text);
  }
  startScope(scope) {
    this.openNode(scope);
  }
  endScope() {
    this.closeNode();
  }
  __addSublanguage(emitter, name) {
    const node = emitter.root;
    if (name)
      node.scope = `language:${name}`;
    this.add(node);
  }
  toHTML() {
    const renderer = new HTMLRenderer(this, this.options);
    return renderer.value();
  }
  finalize() {
    this.closeAllNodes();
    return true;
  }
}
function source$1(re) {
  if (!re)
    return null;
  if (typeof re === "string")
    return re;
  return re.source;
}
function lookahead$1(re) {
  return concat$1("(?=", re, ")");
}
function anyNumberOfTimes(re) {
  return concat$1("(?:", re, ")*");
}
function optional(re) {
  return concat$1("(?:", re, ")?");
}
function concat$1(...args) {
  const joined = args.map((x) => source$1(x)).join("");
  return joined;
}
function stripOptionsFromArgs$1(args) {
  const opts = args[args.length - 1];
  if (typeof opts === "object" && opts.constructor === Object) {
    args.splice(args.length - 1, 1);
    return opts;
  } else {
    return {};
  }
}
function either$1(...args) {
  const opts = stripOptionsFromArgs$1(args);
  const joined = "(" + (opts.capture ? "" : "?:") + args.map((x) => source$1(x)).join("|") + ")";
  return joined;
}
function countMatchGroups(re) {
  return new RegExp(re.toString() + "|").exec("").length - 1;
}
function startsWith(re, lexeme) {
  const match = re && re.exec(lexeme);
  return match && match.index === 0;
}
const BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function _rewriteBackreferences(regexps, { joinWith }) {
  let numCaptures = 0;
  return regexps.map((regex) => {
    numCaptures += 1;
    const offset = numCaptures;
    let re = source$1(regex);
    let out = "";
    while (re.length > 0) {
      const match = BACKREF_RE.exec(re);
      if (!match) {
        out += re;
        break;
      }
      out += re.substring(0, match.index);
      re = re.substring(match.index + match[0].length);
      if (match[0][0] === "\\" && match[1]) {
        out += "\\" + String(Number(match[1]) + offset);
      } else {
        out += match[0];
        if (match[0] === "(") {
          numCaptures++;
        }
      }
    }
    return out;
  }).map((re) => `(${re})`).join(joinWith);
}
const MATCH_NOTHING_RE = /\b\B/;
const IDENT_RE$2 = "[a-zA-Z]\\w*";
const UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
const NUMBER_RE = "\\b\\d+(\\.\\d+)?";
const C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
const BINARY_NUMBER_RE = "\\b(0b[01]+)";
const RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
const SHEBANG = (opts = {}) => {
  const beginShebang = /^#![ ]*\//;
  if (opts.binary) {
    opts.begin = concat$1(
      beginShebang,
      /.*\b/,
      opts.binary,
      /\b.*/
    );
  }
  return inherit$1({
    scope: "meta",
    begin: beginShebang,
    end: /$/,
    relevance: 0,
    "on:begin": (m, resp) => {
      if (m.index !== 0)
        resp.ignoreMatch();
    }
  }, opts);
};
const BACKSLASH_ESCAPE = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
};
const APOS_STRING_MODE = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [BACKSLASH_ESCAPE]
};
const QUOTE_STRING_MODE = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [BACKSLASH_ESCAPE]
};
const PHRASAL_WORDS_MODE = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
};
const COMMENT = function(begin, end, modeOptions = {}) {
  const mode = inherit$1(
    {
      scope: "comment",
      begin,
      end,
      contains: []
    },
    modeOptions
  );
  mode.contains.push({
    scope: "doctag",
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: true,
    relevance: 0
  });
  const ENGLISH_WORD = either$1(
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    /[A-Za-z]+[-][a-z]+/,
    /[A-Za-z][a-z]{2,}/
  );
  mode.contains.push(
    {
      begin: concat$1(
        /[ ]+/,
        "(",
        ENGLISH_WORD,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
    }
  );
  return mode;
};
const C_LINE_COMMENT_MODE = COMMENT("//", "$");
const C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
const HASH_COMMENT_MODE = COMMENT("#", "$");
const NUMBER_MODE = {
  scope: "number",
  begin: NUMBER_RE,
  relevance: 0
};
const C_NUMBER_MODE = {
  scope: "number",
  begin: C_NUMBER_RE,
  relevance: 0
};
const BINARY_NUMBER_MODE = {
  scope: "number",
  begin: BINARY_NUMBER_RE,
  relevance: 0
};
const REGEXP_MODE = {
  begin: /(?=\/[^/\n]*\/)/,
  contains: [{
    scope: "regexp",
    begin: /\//,
    end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [
      BACKSLASH_ESCAPE,
      {
        begin: /\[/,
        end: /\]/,
        relevance: 0,
        contains: [BACKSLASH_ESCAPE]
      }
    ]
  }]
};
const TITLE_MODE = {
  scope: "title",
  begin: IDENT_RE$2,
  relevance: 0
};
const UNDERSCORE_TITLE_MODE = {
  scope: "title",
  begin: UNDERSCORE_IDENT_RE,
  relevance: 0
};
const METHOD_GUARD = {
  begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
  relevance: 0
};
const END_SAME_AS_BEGIN = function(mode) {
  return Object.assign(
    mode,
    {
      "on:begin": (m, resp) => {
        resp.data._beginMatch = m[1];
      },
      "on:end": (m, resp) => {
        if (resp.data._beginMatch !== m[1])
          resp.ignoreMatch();
      }
    }
  );
};
var MODES$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MATCH_NOTHING_RE,
  IDENT_RE: IDENT_RE$2,
  UNDERSCORE_IDENT_RE,
  NUMBER_RE,
  C_NUMBER_RE,
  BINARY_NUMBER_RE,
  RE_STARTERS_RE,
  SHEBANG,
  BACKSLASH_ESCAPE,
  APOS_STRING_MODE,
  QUOTE_STRING_MODE,
  PHRASAL_WORDS_MODE,
  COMMENT,
  C_LINE_COMMENT_MODE,
  C_BLOCK_COMMENT_MODE,
  HASH_COMMENT_MODE,
  NUMBER_MODE,
  C_NUMBER_MODE,
  BINARY_NUMBER_MODE,
  REGEXP_MODE,
  TITLE_MODE,
  UNDERSCORE_TITLE_MODE,
  METHOD_GUARD,
  END_SAME_AS_BEGIN
});
function skipIfHasPrecedingDot(match, response) {
  const before = match.input[match.index - 1];
  if (before === ".") {
    response.ignoreMatch();
  }
}
function scopeClassName(mode, _parent) {
  if (mode.className !== void 0) {
    mode.scope = mode.className;
    delete mode.className;
  }
}
function beginKeywords(mode, parent) {
  if (!parent)
    return;
  if (!mode.beginKeywords)
    return;
  mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
  mode.__beforeBegin = skipIfHasPrecedingDot;
  mode.keywords = mode.keywords || mode.beginKeywords;
  delete mode.beginKeywords;
  if (mode.relevance === void 0)
    mode.relevance = 0;
}
function compileIllegal(mode, _parent) {
  if (!Array.isArray(mode.illegal))
    return;
  mode.illegal = either$1(...mode.illegal);
}
function compileMatch(mode, _parent) {
  if (!mode.match)
    return;
  if (mode.begin || mode.end)
    throw new Error("begin & end are not supported with match");
  mode.begin = mode.match;
  delete mode.match;
}
function compileRelevance(mode, _parent) {
  if (mode.relevance === void 0)
    mode.relevance = 1;
}
const beforeMatchExt = (mode, parent) => {
  if (!mode.beforeMatch)
    return;
  if (mode.starts)
    throw new Error("beforeMatch cannot be used with starts");
  const originalMode = Object.assign({}, mode);
  Object.keys(mode).forEach((key) => {
    delete mode[key];
  });
  mode.keywords = originalMode.keywords;
  mode.begin = concat$1(originalMode.beforeMatch, lookahead$1(originalMode.begin));
  mode.starts = {
    relevance: 0,
    contains: [
      Object.assign(originalMode, { endsParent: true })
    ]
  };
  mode.relevance = 0;
  delete originalMode.beforeMatch;
};
const COMMON_KEYWORDS = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  "list",
  "value"
];
const DEFAULT_KEYWORD_SCOPE = "keyword";
function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {
  const compiledKeywords = /* @__PURE__ */ Object.create(null);
  if (typeof rawKeywords === "string") {
    compileList(scopeName, rawKeywords.split(" "));
  } else if (Array.isArray(rawKeywords)) {
    compileList(scopeName, rawKeywords);
  } else {
    Object.keys(rawKeywords).forEach(function(scopeName2) {
      Object.assign(
        compiledKeywords,
        compileKeywords(rawKeywords[scopeName2], caseInsensitive, scopeName2)
      );
    });
  }
  return compiledKeywords;
  function compileList(scopeName2, keywordList) {
    if (caseInsensitive) {
      keywordList = keywordList.map((x) => x.toLowerCase());
    }
    keywordList.forEach(function(keyword) {
      const pair = keyword.split("|");
      compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword(pair[0], pair[1])];
    });
  }
}
function scoreForKeyword(keyword, providedScore) {
  if (providedScore) {
    return Number(providedScore);
  }
  return commonKeyword(keyword) ? 0 : 1;
}
function commonKeyword(keyword) {
  return COMMON_KEYWORDS.includes(keyword.toLowerCase());
}
const seenDeprecations = {};
const error = (message) => {
  console.error(message);
};
const warn = (message, ...args) => {
  console.log(`WARN: ${message}`, ...args);
};
const deprecated = (version2, message) => {
  if (seenDeprecations[`${version2}/${message}`])
    return;
  console.log(`Deprecated as of ${version2}. ${message}`);
  seenDeprecations[`${version2}/${message}`] = true;
};
const MultiClassError = new Error();
function remapScopeNames(mode, regexes, { key }) {
  let offset = 0;
  const scopeNames = mode[key];
  const emit = {};
  const positions = {};
  for (let i = 1; i <= regexes.length; i++) {
    positions[i + offset] = scopeNames[i];
    emit[i + offset] = true;
    offset += countMatchGroups(regexes[i - 1]);
  }
  mode[key] = positions;
  mode[key]._emit = emit;
  mode[key]._multi = true;
}
function beginMultiClass(mode) {
  if (!Array.isArray(mode.begin))
    return;
  if (mode.skip || mode.excludeBegin || mode.returnBegin) {
    error("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
    throw MultiClassError;
  }
  if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
    error("beginScope must be object");
    throw MultiClassError;
  }
  remapScopeNames(mode, mode.begin, { key: "beginScope" });
  mode.begin = _rewriteBackreferences(mode.begin, { joinWith: "" });
}
function endMultiClass(mode) {
  if (!Array.isArray(mode.end))
    return;
  if (mode.skip || mode.excludeEnd || mode.returnEnd) {
    error("skip, excludeEnd, returnEnd not compatible with endScope: {}");
    throw MultiClassError;
  }
  if (typeof mode.endScope !== "object" || mode.endScope === null) {
    error("endScope must be object");
    throw MultiClassError;
  }
  remapScopeNames(mode, mode.end, { key: "endScope" });
  mode.end = _rewriteBackreferences(mode.end, { joinWith: "" });
}
function scopeSugar(mode) {
  if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
    mode.beginScope = mode.scope;
    delete mode.scope;
  }
}
function MultiClass(mode) {
  scopeSugar(mode);
  if (typeof mode.beginScope === "string") {
    mode.beginScope = { _wrap: mode.beginScope };
  }
  if (typeof mode.endScope === "string") {
    mode.endScope = { _wrap: mode.endScope };
  }
  beginMultiClass(mode);
  endMultiClass(mode);
}
function compileLanguage(language) {
  function langRe(value, global2) {
    return new RegExp(
      source$1(value),
      "m" + (language.case_insensitive ? "i" : "") + (language.unicodeRegex ? "u" : "") + (global2 ? "g" : "")
    );
  }
  class MultiRegex {
    constructor() {
      this.matchIndexes = {};
      this.regexes = [];
      this.matchAt = 1;
      this.position = 0;
    }
    addRule(re, opts) {
      opts.position = this.position++;
      this.matchIndexes[this.matchAt] = opts;
      this.regexes.push([opts, re]);
      this.matchAt += countMatchGroups(re) + 1;
    }
    compile() {
      if (this.regexes.length === 0) {
        this.exec = () => null;
      }
      const terminators = this.regexes.map((el) => el[1]);
      this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: "|" }), true);
      this.lastIndex = 0;
    }
    exec(s) {
      this.matcherRe.lastIndex = this.lastIndex;
      const match = this.matcherRe.exec(s);
      if (!match) {
        return null;
      }
      const i = match.findIndex((el, i2) => i2 > 0 && el !== void 0);
      const matchData = this.matchIndexes[i];
      match.splice(0, i);
      return Object.assign(match, matchData);
    }
  }
  class ResumableMultiRegex {
    constructor() {
      this.rules = [];
      this.multiRegexes = [];
      this.count = 0;
      this.lastIndex = 0;
      this.regexIndex = 0;
    }
    getMatcher(index) {
      if (this.multiRegexes[index])
        return this.multiRegexes[index];
      const matcher = new MultiRegex();
      this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));
      matcher.compile();
      this.multiRegexes[index] = matcher;
      return matcher;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    addRule(re, opts) {
      this.rules.push([re, opts]);
      if (opts.type === "begin")
        this.count++;
    }
    exec(s) {
      const m = this.getMatcher(this.regexIndex);
      m.lastIndex = this.lastIndex;
      let result = m.exec(s);
      if (this.resumingScanAtSamePosition()) {
        if (result && result.index === this.lastIndex)
          ;
        else {
          const m2 = this.getMatcher(0);
          m2.lastIndex = this.lastIndex + 1;
          result = m2.exec(s);
        }
      }
      if (result) {
        this.regexIndex += result.position + 1;
        if (this.regexIndex === this.count) {
          this.considerAll();
        }
      }
      return result;
    }
  }
  function buildModeRegex(mode) {
    const mm = new ResumableMultiRegex();
    mode.contains.forEach((term) => mm.addRule(term.begin, { rule: term, type: "begin" }));
    if (mode.terminatorEnd) {
      mm.addRule(mode.terminatorEnd, { type: "end" });
    }
    if (mode.illegal) {
      mm.addRule(mode.illegal, { type: "illegal" });
    }
    return mm;
  }
  function compileMode(mode, parent) {
    const cmode = mode;
    if (mode.isCompiled)
      return cmode;
    [
      scopeClassName,
      compileMatch,
      MultiClass,
      beforeMatchExt
    ].forEach((ext) => ext(mode, parent));
    language.compilerExtensions.forEach((ext) => ext(mode, parent));
    mode.__beforeBegin = null;
    [
      beginKeywords,
      compileIllegal,
      compileRelevance
    ].forEach((ext) => ext(mode, parent));
    mode.isCompiled = true;
    let keywordPattern = null;
    if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
      mode.keywords = Object.assign({}, mode.keywords);
      keywordPattern = mode.keywords.$pattern;
      delete mode.keywords.$pattern;
    }
    keywordPattern = keywordPattern || /\w+/;
    if (mode.keywords) {
      mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
    }
    cmode.keywordPatternRe = langRe(keywordPattern, true);
    if (parent) {
      if (!mode.begin)
        mode.begin = /\B|\b/;
      cmode.beginRe = langRe(cmode.begin);
      if (!mode.end && !mode.endsWithParent)
        mode.end = /\B|\b/;
      if (mode.end)
        cmode.endRe = langRe(cmode.end);
      cmode.terminatorEnd = source$1(cmode.end) || "";
      if (mode.endsWithParent && parent.terminatorEnd) {
        cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
      }
    }
    if (mode.illegal)
      cmode.illegalRe = langRe(mode.illegal);
    if (!mode.contains)
      mode.contains = [];
    mode.contains = [].concat(...mode.contains.map(function(c) {
      return expandOrCloneMode(c === "self" ? mode : c);
    }));
    mode.contains.forEach(function(c) {
      compileMode(c, cmode);
    });
    if (mode.starts) {
      compileMode(mode.starts, parent);
    }
    cmode.matcher = buildModeRegex(cmode);
    return cmode;
  }
  if (!language.compilerExtensions)
    language.compilerExtensions = [];
  if (language.contains && language.contains.includes("self")) {
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  }
  language.classNameAliases = inherit$1(language.classNameAliases || {});
  return compileMode(language);
}
function dependencyOnParent(mode) {
  if (!mode)
    return false;
  return mode.endsWithParent || dependencyOnParent(mode.starts);
}
function expandOrCloneMode(mode) {
  if (mode.variants && !mode.cachedVariants) {
    mode.cachedVariants = mode.variants.map(function(variant) {
      return inherit$1(mode, { variants: null }, variant);
    });
  }
  if (mode.cachedVariants) {
    return mode.cachedVariants;
  }
  if (dependencyOnParent(mode)) {
    return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });
  }
  if (Object.isFrozen(mode)) {
    return inherit$1(mode);
  }
  return mode;
}
var version$1 = "11.8.0";
class HTMLInjectionError extends Error {
  constructor(reason, html) {
    super(reason);
    this.name = "HTMLInjectionError";
    this.html = html;
  }
}
const escape = escapeHTML;
const inherit = inherit$1;
const NO_MATCH = Symbol("nomatch");
const MAX_KEYWORD_HITS = 7;
const HLJS = function(hljs) {
  const languages2 = /* @__PURE__ */ Object.create(null);
  const aliases = /* @__PURE__ */ Object.create(null);
  const plugins = [];
  let SAFE_MODE = true;
  const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
  const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
  let options = {
    ignoreUnescapedHTML: false,
    throwUnescapedHTML: false,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    __emitter: TokenTreeEmitter
  };
  function shouldNotHighlight(languageName) {
    return options.noHighlightRe.test(languageName);
  }
  function blockLanguage(block2) {
    let classes = block2.className + " ";
    classes += block2.parentNode ? block2.parentNode.className : "";
    const match = options.languageDetectRe.exec(classes);
    if (match) {
      const language = getLanguage(match[1]);
      if (!language) {
        warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
        warn("Falling back to no-highlight mode for this block.", block2);
      }
      return language ? match[1] : "no-highlight";
    }
    return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
  }
  function highlight2(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
    let code = "";
    let languageName = "";
    if (typeof optionsOrCode === "object") {
      code = codeOrLanguageName;
      ignoreIllegals = optionsOrCode.ignoreIllegals;
      languageName = optionsOrCode.language;
    } else {
      deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
      deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
      languageName = codeOrLanguageName;
      code = optionsOrCode;
    }
    if (ignoreIllegals === void 0) {
      ignoreIllegals = true;
    }
    const context = {
      code,
      language: languageName
    };
    fire("before:highlight", context);
    const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
    result.code = context.code;
    fire("after:highlight", result);
    return result;
  }
  function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
    const keywordHits = /* @__PURE__ */ Object.create(null);
    function keywordData(mode, matchText) {
      return mode.keywords[matchText];
    }
    function processKeywords() {
      if (!top.keywords) {
        emitter.addText(modeBuffer);
        return;
      }
      let lastIndex = 0;
      top.keywordPatternRe.lastIndex = 0;
      let match = top.keywordPatternRe.exec(modeBuffer);
      let buf = "";
      while (match) {
        buf += modeBuffer.substring(lastIndex, match.index);
        const word = language.case_insensitive ? match[0].toLowerCase() : match[0];
        const data2 = keywordData(top, word);
        if (data2) {
          const [kind, keywordRelevance] = data2;
          emitter.addText(buf);
          buf = "";
          keywordHits[word] = (keywordHits[word] || 0) + 1;
          if (keywordHits[word] <= MAX_KEYWORD_HITS)
            relevance += keywordRelevance;
          if (kind.startsWith("_")) {
            buf += match[0];
          } else {
            const cssClass = language.classNameAliases[kind] || kind;
            emitKeyword(match[0], cssClass);
          }
        } else {
          buf += match[0];
        }
        lastIndex = top.keywordPatternRe.lastIndex;
        match = top.keywordPatternRe.exec(modeBuffer);
      }
      buf += modeBuffer.substring(lastIndex);
      emitter.addText(buf);
    }
    function processSubLanguage() {
      if (modeBuffer === "")
        return;
      let result2 = null;
      if (typeof top.subLanguage === "string") {
        if (!languages2[top.subLanguage]) {
          emitter.addText(modeBuffer);
          return;
        }
        result2 = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
        continuations[top.subLanguage] = result2._top;
      } else {
        result2 = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
      }
      if (top.relevance > 0) {
        relevance += result2.relevance;
      }
      emitter.__addSublanguage(result2._emitter, result2.language);
    }
    function processBuffer() {
      if (top.subLanguage != null) {
        processSubLanguage();
      } else {
        processKeywords();
      }
      modeBuffer = "";
    }
    function emitKeyword(keyword, scope) {
      if (keyword === "")
        return;
      emitter.startScope(scope);
      emitter.addText(keyword);
      emitter.endScope();
    }
    function emitMultiClass(scope, match) {
      let i = 1;
      const max = match.length - 1;
      while (i <= max) {
        if (!scope._emit[i]) {
          i++;
          continue;
        }
        const klass = language.classNameAliases[scope[i]] || scope[i];
        const text = match[i];
        if (klass) {
          emitKeyword(text, klass);
        } else {
          modeBuffer = text;
          processKeywords();
          modeBuffer = "";
        }
        i++;
      }
    }
    function startNewMode(mode, match) {
      if (mode.scope && typeof mode.scope === "string") {
        emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
      }
      if (mode.beginScope) {
        if (mode.beginScope._wrap) {
          emitKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
          modeBuffer = "";
        } else if (mode.beginScope._multi) {
          emitMultiClass(mode.beginScope, match);
          modeBuffer = "";
        }
      }
      top = Object.create(mode, { parent: { value: top } });
      return top;
    }
    function endOfMode(mode, match, matchPlusRemainder) {
      let matched = startsWith(mode.endRe, matchPlusRemainder);
      if (matched) {
        if (mode["on:end"]) {
          const resp = new Response(mode);
          mode["on:end"](match, resp);
          if (resp.isMatchIgnored)
            matched = false;
        }
        if (matched) {
          while (mode.endsParent && mode.parent) {
            mode = mode.parent;
          }
          return mode;
        }
      }
      if (mode.endsWithParent) {
        return endOfMode(mode.parent, match, matchPlusRemainder);
      }
    }
    function doIgnore(lexeme) {
      if (top.matcher.regexIndex === 0) {
        modeBuffer += lexeme[0];
        return 1;
      } else {
        resumeScanAtSamePosition = true;
        return 0;
      }
    }
    function doBeginMatch(match) {
      const lexeme = match[0];
      const newMode = match.rule;
      const resp = new Response(newMode);
      const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
      for (const cb of beforeCallbacks) {
        if (!cb)
          continue;
        cb(match, resp);
        if (resp.isMatchIgnored)
          return doIgnore(lexeme);
      }
      if (newMode.skip) {
        modeBuffer += lexeme;
      } else {
        if (newMode.excludeBegin) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (!newMode.returnBegin && !newMode.excludeBegin) {
          modeBuffer = lexeme;
        }
      }
      startNewMode(newMode, match);
      return newMode.returnBegin ? 0 : lexeme.length;
    }
    function doEndMatch(match) {
      const lexeme = match[0];
      const matchPlusRemainder = codeToHighlight.substring(match.index);
      const endMode = endOfMode(top, match, matchPlusRemainder);
      if (!endMode) {
        return NO_MATCH;
      }
      const origin = top;
      if (top.endScope && top.endScope._wrap) {
        processBuffer();
        emitKeyword(lexeme, top.endScope._wrap);
      } else if (top.endScope && top.endScope._multi) {
        processBuffer();
        emitMultiClass(top.endScope, match);
      } else if (origin.skip) {
        modeBuffer += lexeme;
      } else {
        if (!(origin.returnEnd || origin.excludeEnd)) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (origin.excludeEnd) {
          modeBuffer = lexeme;
        }
      }
      do {
        if (top.scope) {
          emitter.closeNode();
        }
        if (!top.skip && !top.subLanguage) {
          relevance += top.relevance;
        }
        top = top.parent;
      } while (top !== endMode.parent);
      if (endMode.starts) {
        startNewMode(endMode.starts, match);
      }
      return origin.returnEnd ? 0 : lexeme.length;
    }
    function processContinuations() {
      const list = [];
      for (let current = top; current !== language; current = current.parent) {
        if (current.scope) {
          list.unshift(current.scope);
        }
      }
      list.forEach((item) => emitter.openNode(item));
    }
    let lastMatch = {};
    function processLexeme(textBeforeMatch, match) {
      const lexeme = match && match[0];
      modeBuffer += textBeforeMatch;
      if (lexeme == null) {
        processBuffer();
        return 0;
      }
      if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
        modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
        if (!SAFE_MODE) {
          const err = new Error(`0 width match regex (${languageName})`);
          err.languageName = languageName;
          err.badRule = lastMatch.rule;
          throw err;
        }
        return 1;
      }
      lastMatch = match;
      if (match.type === "begin") {
        return doBeginMatch(match);
      } else if (match.type === "illegal" && !ignoreIllegals) {
        const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.scope || "<unnamed>") + '"');
        err.mode = top;
        throw err;
      } else if (match.type === "end") {
        const processed = doEndMatch(match);
        if (processed !== NO_MATCH) {
          return processed;
        }
      }
      if (match.type === "illegal" && lexeme === "") {
        return 1;
      }
      if (iterations > 1e5 && iterations > match.index * 3) {
        const err = new Error("potential infinite loop, way more iterations than matches");
        throw err;
      }
      modeBuffer += lexeme;
      return lexeme.length;
    }
    const language = getLanguage(languageName);
    if (!language) {
      error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
      throw new Error('Unknown language: "' + languageName + '"');
    }
    const md = compileLanguage(language);
    let result = "";
    let top = continuation || md;
    const continuations = {};
    const emitter = new options.__emitter(options);
    processContinuations();
    let modeBuffer = "";
    let relevance = 0;
    let index = 0;
    let iterations = 0;
    let resumeScanAtSamePosition = false;
    try {
      if (!language.__emitTokens) {
        top.matcher.considerAll();
        for (; ; ) {
          iterations++;
          if (resumeScanAtSamePosition) {
            resumeScanAtSamePosition = false;
          } else {
            top.matcher.considerAll();
          }
          top.matcher.lastIndex = index;
          const match = top.matcher.exec(codeToHighlight);
          if (!match)
            break;
          const beforeMatch = codeToHighlight.substring(index, match.index);
          const processedCount = processLexeme(beforeMatch, match);
          index = match.index + processedCount;
        }
        processLexeme(codeToHighlight.substring(index));
      } else {
        language.__emitTokens(codeToHighlight, emitter);
      }
      emitter.finalize();
      result = emitter.toHTML();
      return {
        language: languageName,
        value: result,
        relevance,
        illegal: false,
        _emitter: emitter,
        _top: top
      };
    } catch (err) {
      if (err.message && err.message.includes("Illegal")) {
        return {
          language: languageName,
          value: escape(codeToHighlight),
          illegal: true,
          relevance: 0,
          _illegalBy: {
            message: err.message,
            index,
            context: codeToHighlight.slice(index - 100, index + 100),
            mode: err.mode,
            resultSoFar: result
          },
          _emitter: emitter
        };
      } else if (SAFE_MODE) {
        return {
          language: languageName,
          value: escape(codeToHighlight),
          illegal: false,
          relevance: 0,
          errorRaised: err,
          _emitter: emitter,
          _top: top
        };
      } else {
        throw err;
      }
    }
  }
  function justTextHighlightResult(code) {
    const result = {
      value: escape(code),
      illegal: false,
      relevance: 0,
      _top: PLAINTEXT_LANGUAGE,
      _emitter: new options.__emitter(options)
    };
    result._emitter.addText(code);
    return result;
  }
  function highlightAuto(code, languageSubset) {
    languageSubset = languageSubset || options.languages || Object.keys(languages2);
    const plaintext2 = justTextHighlightResult(code);
    const results = languageSubset.filter(getLanguage).filter(autoDetection).map(
      (name) => _highlight(name, code, false)
    );
    results.unshift(plaintext2);
    const sorted = results.sort((a, b) => {
      if (a.relevance !== b.relevance)
        return b.relevance - a.relevance;
      if (a.language && b.language) {
        if (getLanguage(a.language).supersetOf === b.language) {
          return 1;
        } else if (getLanguage(b.language).supersetOf === a.language) {
          return -1;
        }
      }
      return 0;
    });
    const [best, secondBest] = sorted;
    const result = best;
    result.secondBest = secondBest;
    return result;
  }
  function updateClassName(element2, currentLang, resultLang) {
    const language = currentLang && aliases[currentLang] || resultLang;
    element2.classList.add("hljs");
    element2.classList.add(`language-${language}`);
  }
  function highlightElement(element2) {
    let node = null;
    const language = blockLanguage(element2);
    if (shouldNotHighlight(language))
      return;
    fire(
      "before:highlightElement",
      { el: element2, language }
    );
    if (element2.children.length > 0) {
      if (!options.ignoreUnescapedHTML) {
        console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
        console.warn("https://github.com/highlightjs/highlight.js/wiki/security");
        console.warn("The element with unescaped HTML:");
        console.warn(element2);
      }
      if (options.throwUnescapedHTML) {
        const err = new HTMLInjectionError(
          "One of your code blocks includes unescaped HTML.",
          element2.innerHTML
        );
        throw err;
      }
    }
    node = element2;
    const text = node.textContent;
    const result = language ? highlight2(text, { language, ignoreIllegals: true }) : highlightAuto(text);
    element2.innerHTML = result.value;
    updateClassName(element2, language, result.language);
    element2.result = {
      language: result.language,
      re: result.relevance,
      relevance: result.relevance
    };
    if (result.secondBest) {
      element2.secondBest = {
        language: result.secondBest.language,
        relevance: result.secondBest.relevance
      };
    }
    fire("after:highlightElement", { el: element2, result, text });
  }
  function configure(userOptions) {
    options = inherit(options, userOptions);
  }
  const initHighlighting = () => {
    highlightAll();
    deprecated("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function initHighlightingOnLoad() {
    highlightAll();
    deprecated("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let wantsHighlight = false;
  function highlightAll() {
    if (document.readyState === "loading") {
      wantsHighlight = true;
      return;
    }
    const blocks = document.querySelectorAll(options.cssSelector);
    blocks.forEach(highlightElement);
  }
  function boot() {
    if (wantsHighlight)
      highlightAll();
  }
  if (typeof window !== "undefined" && window.addEventListener) {
    window.addEventListener("DOMContentLoaded", boot, false);
  }
  function registerLanguage(languageName, languageDefinition) {
    let lang = null;
    try {
      lang = languageDefinition(hljs);
    } catch (error$1) {
      error("Language definition for '{}' could not be registered.".replace("{}", languageName));
      if (!SAFE_MODE) {
        throw error$1;
      } else {
        error(error$1);
      }
      lang = PLAINTEXT_LANGUAGE;
    }
    if (!lang.name)
      lang.name = languageName;
    languages2[languageName] = lang;
    lang.rawDefinition = languageDefinition.bind(null, hljs);
    if (lang.aliases) {
      registerAliases(lang.aliases, { languageName });
    }
  }
  function unregisterLanguage(languageName) {
    delete languages2[languageName];
    for (const alias of Object.keys(aliases)) {
      if (aliases[alias] === languageName) {
        delete aliases[alias];
      }
    }
  }
  function listLanguages() {
    return Object.keys(languages2);
  }
  function getLanguage(name) {
    name = (name || "").toLowerCase();
    return languages2[name] || languages2[aliases[name]];
  }
  function registerAliases(aliasList, { languageName }) {
    if (typeof aliasList === "string") {
      aliasList = [aliasList];
    }
    aliasList.forEach((alias) => {
      aliases[alias.toLowerCase()] = languageName;
    });
  }
  function autoDetection(name) {
    const lang = getLanguage(name);
    return lang && !lang.disableAutodetect;
  }
  function upgradePluginAPI(plugin) {
    if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
      plugin["before:highlightElement"] = (data2) => {
        plugin["before:highlightBlock"](
          Object.assign({ block: data2.el }, data2)
        );
      };
    }
    if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
      plugin["after:highlightElement"] = (data2) => {
        plugin["after:highlightBlock"](
          Object.assign({ block: data2.el }, data2)
        );
      };
    }
  }
  function addPlugin(plugin) {
    upgradePluginAPI(plugin);
    plugins.push(plugin);
  }
  function removePlugin(plugin) {
    const index = plugins.indexOf(plugin);
    if (index !== -1) {
      plugins.splice(index, 1);
    }
  }
  function fire(event2, args) {
    const cb = event2;
    plugins.forEach(function(plugin) {
      if (plugin[cb]) {
        plugin[cb](args);
      }
    });
  }
  function deprecateHighlightBlock(el) {
    deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
    deprecated("10.7.0", "Please use highlightElement now.");
    return highlightElement(el);
  }
  Object.assign(hljs, {
    highlight: highlight2,
    highlightAuto,
    highlightAll,
    highlightElement,
    highlightBlock: deprecateHighlightBlock,
    configure,
    initHighlighting,
    initHighlightingOnLoad,
    registerLanguage,
    unregisterLanguage,
    listLanguages,
    getLanguage,
    registerAliases,
    autoDetection,
    inherit,
    addPlugin,
    removePlugin
  });
  hljs.debugMode = function() {
    SAFE_MODE = false;
  };
  hljs.safeMode = function() {
    SAFE_MODE = true;
  };
  hljs.versionString = version$1;
  hljs.regex = {
    concat: concat$1,
    lookahead: lookahead$1,
    either: either$1,
    optional,
    anyNumberOfTimes
  };
  for (const key in MODES$3) {
    if (typeof MODES$3[key] === "object") {
      deepFreeze(MODES$3[key]);
    }
  }
  Object.assign(hljs, MODES$3);
  return hljs;
};
const highlight = HLJS({});
highlight.newInstance = () => HLJS({});
var core = highlight;
highlight.HighlightJS = highlight;
highlight.default = highlight;
const HighlightJS = core;
function plaintext(hljs) {
  return {
    name: "Plain text",
    aliases: [
      "text",
      "txt"
    ],
    disableAutodetect: true
  };
}
const IDENT_RE$1 = "[A-Za-z$_][0-9A-Za-z$_]*";
const KEYWORDS$1 = [
  "as",
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
];
const LITERALS$1 = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
];
const TYPES$1 = [
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  "Math",
  "Date",
  "Number",
  "BigInt",
  "String",
  "RegExp",
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  "Reflect",
  "Proxy",
  "Intl",
  "WebAssembly"
];
const ERROR_TYPES$1 = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
];
const BUILT_IN_GLOBALS$1 = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
];
const BUILT_IN_VARIABLES$1 = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
];
const BUILT_INS$1 = [].concat(
  BUILT_IN_GLOBALS$1,
  TYPES$1,
  ERROR_TYPES$1
);
function javascript$1(hljs) {
  const regex = hljs.regex;
  const hasClosingTag = (match, { after }) => {
    const tag = "</" + match[0].slice(1);
    const pos = match.input.indexOf(tag, after);
    return pos !== -1;
  };
  const IDENT_RE$1$1 = IDENT_RE$1;
  const FRAGMENT = {
    begin: "<>",
    end: "</>"
  };
  const XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
  const XML_TAG = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    isTrulyOpeningTag: (match, response) => {
      const afterMatchIndex = match[0].length + match.index;
      const nextChar = match.input[afterMatchIndex];
      if (nextChar === "<" || nextChar === ",") {
        response.ignoreMatch();
        return;
      }
      if (nextChar === ">") {
        if (!hasClosingTag(match, { after: afterMatchIndex })) {
          response.ignoreMatch();
        }
      }
      let m;
      const afterMatch = match.input.substring(afterMatchIndex);
      if (m = afterMatch.match(/^\s*=/)) {
        response.ignoreMatch();
        return;
      }
      if (m = afterMatch.match(/^\s+extends\s+/)) {
        if (m.index === 0) {
          response.ignoreMatch();
          return;
        }
      }
    }
  };
  const KEYWORDS$1$1 = {
    $pattern: IDENT_RE$1,
    keyword: KEYWORDS$1,
    literal: LITERALS$1,
    built_in: BUILT_INS$1,
    "variable.language": BUILT_IN_VARIABLES$1
  };
  const decimalDigits2 = "[0-9](_?[0-9])*";
  const frac2 = `\\.(${decimalDigits2})`;
  const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
  const NUMBER = {
    className: "number",
    variants: [
      { begin: `(\\b(${decimalInteger})((${frac2})|\\.)?|(${frac2}))[eE][+-]?(${decimalDigits2})\\b` },
      { begin: `\\b(${decimalInteger})\\b((${frac2})\\b|\\.)?|(${frac2})\\b` },
      { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  };
  const SUBST = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: KEYWORDS$1$1,
    contains: []
  };
  const HTML_TEMPLATE = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "xml"
    }
  };
  const CSS_TEMPLATE = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "css"
    }
  };
  const GRAPHQL_TEMPLATE = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "graphql"
    }
  };
  const TEMPLATE_STRING = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      hljs.BACKSLASH_ESCAPE,
      SUBST
    ]
  };
  const JSDOC_COMMENT = hljs.COMMENT(
    /\/\*\*(?!\/)/,
    "\\*/",
    {
      relevance: 0,
      contains: [
        {
          begin: "(?=@[A-Za-z]+)",
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            },
            {
              className: "type",
              begin: "\\{",
              end: "\\}",
              excludeEnd: true,
              excludeBegin: true,
              relevance: 0
            },
            {
              className: "variable",
              begin: IDENT_RE$1$1 + "(?=\\s*(-)|$)",
              endsParent: true,
              relevance: 0
            },
            {
              begin: /(?=[^\n])\s/,
              relevance: 0
            }
          ]
        }
      ]
    }
  );
  const COMMENT2 = {
    className: "comment",
    variants: [
      JSDOC_COMMENT,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.C_LINE_COMMENT_MODE
    ]
  };
  const SUBST_INTERNALS = [
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    HTML_TEMPLATE,
    CSS_TEMPLATE,
    GRAPHQL_TEMPLATE,
    TEMPLATE_STRING,
    { match: /\$\d+/ },
    NUMBER
  ];
  SUBST.contains = SUBST_INTERNALS.concat({
    begin: /\{/,
    end: /\}/,
    keywords: KEYWORDS$1$1,
    contains: [
      "self"
    ].concat(SUBST_INTERNALS)
  });
  const SUBST_AND_COMMENTS = [].concat(COMMENT2, SUBST.contains);
  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
    {
      begin: /\(/,
      end: /\)/,
      keywords: KEYWORDS$1$1,
      contains: ["self"].concat(SUBST_AND_COMMENTS)
    }
  ]);
  const PARAMS = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: true,
    excludeEnd: true,
    keywords: KEYWORDS$1$1,
    contains: PARAMS_CONTAINS
  };
  const CLASS_OR_EXTENDS = {
    variants: [
      {
        match: [
          /class/,
          /\s+/,
          IDENT_RE$1$1,
          /\s+/,
          /extends/,
          /\s+/,
          regex.concat(IDENT_RE$1$1, "(", regex.concat(/\./, IDENT_RE$1$1), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      {
        match: [
          /class/,
          /\s+/,
          IDENT_RE$1$1
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  };
  const CLASS_REFERENCE = {
    relevance: 0,
    match: regex.either(
      /\bJSON/,
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
    ),
    className: "title.class",
    keywords: {
      _: [
        ...TYPES$1,
        ...ERROR_TYPES$1
      ]
    }
  };
  const USE_STRICT = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  };
  const FUNCTION_DEFINITION = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          IDENT_RE$1$1,
          /(?=\s*\()/
        ]
      },
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [PARAMS],
    illegal: /%/
  };
  const UPPER_CASE_CONSTANT = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function noneOf(list) {
    return regex.concat("(?!", list.join("|"), ")");
  }
  const FUNCTION_CALL = {
    match: regex.concat(
      /\b/,
      noneOf([
        ...BUILT_IN_GLOBALS$1,
        "super",
        "import"
      ]),
      IDENT_RE$1$1,
      regex.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  };
  const PROPERTY_ACCESS = {
    begin: regex.concat(/\./, regex.lookahead(
      regex.concat(IDENT_RE$1$1, /(?![0-9A-Za-z$_(])/)
    )),
    end: IDENT_RE$1$1,
    excludeBegin: true,
    keywords: "prototype",
    className: "property",
    relevance: 0
  };
  const GETTER_OR_SETTER = {
    match: [
      /get|set/,
      /\s+/,
      IDENT_RE$1$1,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        begin: /\(\)/
      },
      PARAMS
    ]
  };
  const FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
  const FUNCTION_VARIABLE = {
    match: [
      /const|var|let/,
      /\s+/,
      IDENT_RE$1$1,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      regex.lookahead(FUNC_LEAD_IN_RE)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      PARAMS
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: KEYWORDS$1$1,
    exports: { PARAMS_CONTAINS, CLASS_REFERENCE },
    illegal: /#(?![$_A-z])/,
    contains: [
      hljs.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      USE_STRICT,
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      GRAPHQL_TEMPLATE,
      TEMPLATE_STRING,
      COMMENT2,
      { match: /\$\d+/ },
      NUMBER,
      CLASS_REFERENCE,
      {
        className: "attr",
        begin: IDENT_RE$1$1 + regex.lookahead(":"),
        relevance: 0
      },
      FUNCTION_VARIABLE,
      {
        begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          COMMENT2,
          hljs.REGEXP_MODE,
          {
            className: "function",
            begin: FUNC_LEAD_IN_RE,
            returnBegin: true,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: hljs.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: true
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: true,
                    excludeEnd: true,
                    keywords: KEYWORDS$1$1,
                    contains: PARAMS_CONTAINS
                  }
                ]
              }
            ]
          },
          {
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            variants: [
              { begin: FRAGMENT.begin, end: FRAGMENT.end },
              { match: XML_SELF_CLOSING },
              {
                begin: XML_TAG.begin,
                "on:begin": XML_TAG.isTrulyOpeningTag,
                end: XML_TAG.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: XML_TAG.begin,
                end: XML_TAG.end,
                skip: true,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      FUNCTION_DEFINITION,
      {
        beginKeywords: "while if switch catch for"
      },
      {
        begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        returnBegin: true,
        label: "func.def",
        contains: [
          PARAMS,
          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1$1, className: "title.function" })
        ]
      },
      {
        match: /\.\.\./,
        relevance: 0
      },
      PROPERTY_ACCESS,
      {
        match: "\\$" + IDENT_RE$1$1,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [PARAMS]
      },
      FUNCTION_CALL,
      UPPER_CASE_CONSTANT,
      CLASS_OR_EXTENDS,
      GETTER_OR_SETTER,
      {
        match: /\$[(.]/
      }
    ]
  };
}
var decimalDigits = "[0-9](_*[0-9])*";
var frac = `\\.(${decimalDigits})`;
var hexDigits = "[0-9a-fA-F](_*[0-9a-fA-F])*";
var NUMERIC = {
  className: "number",
  variants: [
    { begin: `(\\b(${decimalDigits})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})[fFdD]?\\b` },
    { begin: `\\b(${decimalDigits})((${frac})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${frac})[fFdD]?\\b` },
    { begin: `\\b(${decimalDigits})[fFdD]\\b` },
    { begin: `\\b0[xX]((${hexDigits})\\.?|(${hexDigits})?\\.(${hexDigits}))[pP][+-]?(${decimalDigits})[fFdD]?\\b` },
    { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
    { begin: `\\b0[xX](${hexDigits})[lL]?\\b` },
    { begin: "\\b0(_*[0-7])*[lL]?\\b" },
    { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
  ],
  relevance: 0
};
function recurRegex(re, substitution, depth) {
  if (depth === -1)
    return "";
  return re.replace(substitution, (_) => {
    return recurRegex(re, substitution, depth - 1);
  });
}
function java(hljs) {
  const regex = hljs.regex;
  const JAVA_IDENT_RE = "[\xC0-\u02B8a-zA-Z_$][\xC0-\u02B8a-zA-Z_$0-9]*";
  const GENERIC_IDENT_RE = JAVA_IDENT_RE + recurRegex("(?:<" + JAVA_IDENT_RE + "~~~(?:\\s*,\\s*" + JAVA_IDENT_RE + "~~~)*>)?", /~~~/g, 2);
  const MAIN_KEYWORDS = [
    "synchronized",
    "abstract",
    "private",
    "var",
    "static",
    "if",
    "const ",
    "for",
    "while",
    "strictfp",
    "finally",
    "protected",
    "import",
    "native",
    "final",
    "void",
    "enum",
    "else",
    "break",
    "transient",
    "catch",
    "instanceof",
    "volatile",
    "case",
    "assert",
    "package",
    "default",
    "public",
    "try",
    "switch",
    "continue",
    "throws",
    "protected",
    "public",
    "private",
    "module",
    "requires",
    "exports",
    "do",
    "sealed",
    "yield",
    "permits"
  ];
  const BUILT_INS2 = [
    "super",
    "this"
  ];
  const LITERALS2 = [
    "false",
    "true",
    "null"
  ];
  const TYPES2 = [
    "char",
    "boolean",
    "long",
    "float",
    "int",
    "byte",
    "short",
    "double"
  ];
  const KEYWORDS2 = {
    keyword: MAIN_KEYWORDS,
    literal: LITERALS2,
    type: TYPES2,
    built_in: BUILT_INS2
  };
  const ANNOTATION = {
    className: "meta",
    begin: "@" + JAVA_IDENT_RE,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: ["self"]
      }
    ]
  };
  const PARAMS = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    keywords: KEYWORDS2,
    relevance: 0,
    contains: [hljs.C_BLOCK_COMMENT_MODE],
    endsParent: true
  };
  return {
    name: "Java",
    aliases: ["jsp"],
    keywords: KEYWORDS2,
    illegal: /<\/|#/,
    contains: [
      hljs.COMMENT(
        "/\\*\\*",
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: /\w+@/,
              relevance: 0
            },
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        }
      ),
      {
        begin: /import java\.[a-z]+\./,
        keywords: "import",
        relevance: 2
      },
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      {
        begin: /"""/,
        end: /"""/,
        className: "string",
        contains: [hljs.BACKSLASH_ESCAPE]
      },
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      {
        match: [
          /\b(?:class|interface|enum|extends|implements|new)/,
          /\s+/,
          JAVA_IDENT_RE
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        match: /non-sealed/,
        scope: "keyword"
      },
      {
        begin: [
          regex.concat(/(?!else)/, JAVA_IDENT_RE),
          /\s+/,
          JAVA_IDENT_RE,
          /\s+/,
          /=(?!=)/
        ],
        className: {
          1: "type",
          3: "variable",
          5: "operator"
        }
      },
      {
        begin: [
          /record/,
          /\s+/,
          JAVA_IDENT_RE
        ],
        className: {
          1: "keyword",
          3: "title.class"
        },
        contains: [
          PARAMS,
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        beginKeywords: "new throw return else",
        relevance: 0
      },
      {
        begin: [
          "(?:" + GENERIC_IDENT_RE + "\\s+)",
          hljs.UNDERSCORE_IDENT_RE,
          /\s*(?=\()/
        ],
        className: { 2: "title.function" },
        keywords: KEYWORDS2,
        contains: [
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: KEYWORDS2,
            relevance: 0,
            contains: [
              ANNOTATION,
              hljs.APOS_STRING_MODE,
              hljs.QUOTE_STRING_MODE,
              NUMERIC,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ]
      },
      NUMERIC,
      ANNOTATION
    ]
  };
}
const IDENT_RE = "[A-Za-z$_][0-9A-Za-z$_]*";
const KEYWORDS = [
  "as",
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
];
const LITERALS = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
];
const TYPES = [
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  "Math",
  "Date",
  "Number",
  "BigInt",
  "String",
  "RegExp",
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  "Reflect",
  "Proxy",
  "Intl",
  "WebAssembly"
];
const ERROR_TYPES = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
];
const BUILT_IN_GLOBALS = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
];
const BUILT_IN_VARIABLES = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
];
const BUILT_INS = [].concat(
  BUILT_IN_GLOBALS,
  TYPES,
  ERROR_TYPES
);
function javascript(hljs) {
  const regex = hljs.regex;
  const hasClosingTag = (match, { after }) => {
    const tag = "</" + match[0].slice(1);
    const pos = match.input.indexOf(tag, after);
    return pos !== -1;
  };
  const IDENT_RE$12 = IDENT_RE;
  const FRAGMENT = {
    begin: "<>",
    end: "</>"
  };
  const XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
  const XML_TAG = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    isTrulyOpeningTag: (match, response) => {
      const afterMatchIndex = match[0].length + match.index;
      const nextChar = match.input[afterMatchIndex];
      if (nextChar === "<" || nextChar === ",") {
        response.ignoreMatch();
        return;
      }
      if (nextChar === ">") {
        if (!hasClosingTag(match, { after: afterMatchIndex })) {
          response.ignoreMatch();
        }
      }
      let m;
      const afterMatch = match.input.substring(afterMatchIndex);
      if (m = afterMatch.match(/^\s*=/)) {
        response.ignoreMatch();
        return;
      }
      if (m = afterMatch.match(/^\s+extends\s+/)) {
        if (m.index === 0) {
          response.ignoreMatch();
          return;
        }
      }
    }
  };
  const KEYWORDS$12 = {
    $pattern: IDENT_RE,
    keyword: KEYWORDS,
    literal: LITERALS,
    built_in: BUILT_INS,
    "variable.language": BUILT_IN_VARIABLES
  };
  const decimalDigits2 = "[0-9](_?[0-9])*";
  const frac2 = `\\.(${decimalDigits2})`;
  const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
  const NUMBER = {
    className: "number",
    variants: [
      { begin: `(\\b(${decimalInteger})((${frac2})|\\.)?|(${frac2}))[eE][+-]?(${decimalDigits2})\\b` },
      { begin: `\\b(${decimalInteger})\\b((${frac2})\\b|\\.)?|(${frac2})\\b` },
      { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  };
  const SUBST = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: KEYWORDS$12,
    contains: []
  };
  const HTML_TEMPLATE = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "xml"
    }
  };
  const CSS_TEMPLATE = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "css"
    }
  };
  const GRAPHQL_TEMPLATE = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "graphql"
    }
  };
  const TEMPLATE_STRING = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      hljs.BACKSLASH_ESCAPE,
      SUBST
    ]
  };
  const JSDOC_COMMENT = hljs.COMMENT(
    /\/\*\*(?!\/)/,
    "\\*/",
    {
      relevance: 0,
      contains: [
        {
          begin: "(?=@[A-Za-z]+)",
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            },
            {
              className: "type",
              begin: "\\{",
              end: "\\}",
              excludeEnd: true,
              excludeBegin: true,
              relevance: 0
            },
            {
              className: "variable",
              begin: IDENT_RE$12 + "(?=\\s*(-)|$)",
              endsParent: true,
              relevance: 0
            },
            {
              begin: /(?=[^\n])\s/,
              relevance: 0
            }
          ]
        }
      ]
    }
  );
  const COMMENT2 = {
    className: "comment",
    variants: [
      JSDOC_COMMENT,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.C_LINE_COMMENT_MODE
    ]
  };
  const SUBST_INTERNALS = [
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    HTML_TEMPLATE,
    CSS_TEMPLATE,
    GRAPHQL_TEMPLATE,
    TEMPLATE_STRING,
    { match: /\$\d+/ },
    NUMBER
  ];
  SUBST.contains = SUBST_INTERNALS.concat({
    begin: /\{/,
    end: /\}/,
    keywords: KEYWORDS$12,
    contains: [
      "self"
    ].concat(SUBST_INTERNALS)
  });
  const SUBST_AND_COMMENTS = [].concat(COMMENT2, SUBST.contains);
  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
    {
      begin: /\(/,
      end: /\)/,
      keywords: KEYWORDS$12,
      contains: ["self"].concat(SUBST_AND_COMMENTS)
    }
  ]);
  const PARAMS = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: true,
    excludeEnd: true,
    keywords: KEYWORDS$12,
    contains: PARAMS_CONTAINS
  };
  const CLASS_OR_EXTENDS = {
    variants: [
      {
        match: [
          /class/,
          /\s+/,
          IDENT_RE$12,
          /\s+/,
          /extends/,
          /\s+/,
          regex.concat(IDENT_RE$12, "(", regex.concat(/\./, IDENT_RE$12), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      {
        match: [
          /class/,
          /\s+/,
          IDENT_RE$12
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  };
  const CLASS_REFERENCE = {
    relevance: 0,
    match: regex.either(
      /\bJSON/,
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
    ),
    className: "title.class",
    keywords: {
      _: [
        ...TYPES,
        ...ERROR_TYPES
      ]
    }
  };
  const USE_STRICT = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  };
  const FUNCTION_DEFINITION = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          IDENT_RE$12,
          /(?=\s*\()/
        ]
      },
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [PARAMS],
    illegal: /%/
  };
  const UPPER_CASE_CONSTANT = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function noneOf(list) {
    return regex.concat("(?!", list.join("|"), ")");
  }
  const FUNCTION_CALL = {
    match: regex.concat(
      /\b/,
      noneOf([
        ...BUILT_IN_GLOBALS,
        "super",
        "import"
      ]),
      IDENT_RE$12,
      regex.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  };
  const PROPERTY_ACCESS = {
    begin: regex.concat(/\./, regex.lookahead(
      regex.concat(IDENT_RE$12, /(?![0-9A-Za-z$_(])/)
    )),
    end: IDENT_RE$12,
    excludeBegin: true,
    keywords: "prototype",
    className: "property",
    relevance: 0
  };
  const GETTER_OR_SETTER = {
    match: [
      /get|set/,
      /\s+/,
      IDENT_RE$12,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        begin: /\(\)/
      },
      PARAMS
    ]
  };
  const FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
  const FUNCTION_VARIABLE = {
    match: [
      /const|var|let/,
      /\s+/,
      IDENT_RE$12,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      regex.lookahead(FUNC_LEAD_IN_RE)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      PARAMS
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: KEYWORDS$12,
    exports: { PARAMS_CONTAINS, CLASS_REFERENCE },
    illegal: /#(?![$_A-z])/,
    contains: [
      hljs.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      USE_STRICT,
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      GRAPHQL_TEMPLATE,
      TEMPLATE_STRING,
      COMMENT2,
      { match: /\$\d+/ },
      NUMBER,
      CLASS_REFERENCE,
      {
        className: "attr",
        begin: IDENT_RE$12 + regex.lookahead(":"),
        relevance: 0
      },
      FUNCTION_VARIABLE,
      {
        begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          COMMENT2,
          hljs.REGEXP_MODE,
          {
            className: "function",
            begin: FUNC_LEAD_IN_RE,
            returnBegin: true,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: hljs.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: true
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: true,
                    excludeEnd: true,
                    keywords: KEYWORDS$12,
                    contains: PARAMS_CONTAINS
                  }
                ]
              }
            ]
          },
          {
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            variants: [
              { begin: FRAGMENT.begin, end: FRAGMENT.end },
              { match: XML_SELF_CLOSING },
              {
                begin: XML_TAG.begin,
                "on:begin": XML_TAG.isTrulyOpeningTag,
                end: XML_TAG.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: XML_TAG.begin,
                end: XML_TAG.end,
                skip: true,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      FUNCTION_DEFINITION,
      {
        beginKeywords: "while if switch catch for"
      },
      {
        begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        returnBegin: true,
        label: "func.def",
        contains: [
          PARAMS,
          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$12, className: "title.function" })
        ]
      },
      {
        match: /\.\.\./,
        relevance: 0
      },
      PROPERTY_ACCESS,
      {
        match: "\\$" + IDENT_RE$12,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [PARAMS]
      },
      FUNCTION_CALL,
      UPPER_CASE_CONSTANT,
      CLASS_OR_EXTENDS,
      GETTER_OR_SETTER,
      {
        match: /\$[(.]/
      }
    ]
  };
}
function typescript(hljs) {
  const tsLanguage = javascript(hljs);
  const IDENT_RE$12 = IDENT_RE;
  const TYPES2 = [
    "any",
    "void",
    "number",
    "boolean",
    "string",
    "object",
    "never",
    "symbol",
    "bigint",
    "unknown"
  ];
  const NAMESPACE = {
    beginKeywords: "namespace",
    end: /\{/,
    excludeEnd: true,
    contains: [tsLanguage.exports.CLASS_REFERENCE]
  };
  const INTERFACE = {
    beginKeywords: "interface",
    end: /\{/,
    excludeEnd: true,
    keywords: {
      keyword: "interface extends",
      built_in: TYPES2
    },
    contains: [tsLanguage.exports.CLASS_REFERENCE]
  };
  const USE_STRICT = {
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use strict['"]/
  };
  const TS_SPECIFIC_KEYWORDS = [
    "type",
    "namespace",
    "interface",
    "public",
    "private",
    "protected",
    "implements",
    "declare",
    "abstract",
    "readonly",
    "enum",
    "override"
  ];
  const KEYWORDS$12 = {
    $pattern: IDENT_RE,
    keyword: KEYWORDS.concat(TS_SPECIFIC_KEYWORDS),
    literal: LITERALS,
    built_in: BUILT_INS.concat(TYPES2),
    "variable.language": BUILT_IN_VARIABLES
  };
  const DECORATOR = {
    className: "meta",
    begin: "@" + IDENT_RE$12
  };
  const swapMode = (mode, label, replacement) => {
    const indx = mode.contains.findIndex((m) => m.label === label);
    if (indx === -1) {
      throw new Error("can not find mode to replace");
    }
    mode.contains.splice(indx, 1, replacement);
  };
  Object.assign(tsLanguage.keywords, KEYWORDS$12);
  tsLanguage.exports.PARAMS_CONTAINS.push(DECORATOR);
  tsLanguage.contains = tsLanguage.contains.concat([
    DECORATOR,
    NAMESPACE,
    INTERFACE
  ]);
  swapMode(tsLanguage, "shebang", hljs.SHEBANG());
  swapMode(tsLanguage, "use_strict", USE_STRICT);
  const functionDeclaration = tsLanguage.contains.find((m) => m.label === "func.def");
  functionDeclaration.relevance = 0;
  Object.assign(tsLanguage, {
    name: "TypeScript",
    aliases: [
      "ts",
      "tsx",
      "mts",
      "cts"
    ]
  });
  return tsLanguage;
}
function xml(hljs) {
  const regex = hljs.regex;
  const TAG_NAME_RE = regex.concat(/[\p{L}_]/u, regex.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u);
  const XML_IDENT_RE = /[\p{L}0-9._:-]+/u;
  const XML_ENTITIES = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  };
  const XML_META_KEYWORDS = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  };
  const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {
    begin: /\(/,
    end: /\)/
  });
  const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, { className: "string" });
  const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, { className: "string" });
  const TAG_INTERNALS = {
    endsWithParent: true,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: XML_IDENT_RE,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: true,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [XML_ENTITIES]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [XML_ENTITIES]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: true,
    unicodeRegex: true,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          XML_META_KEYWORDS,
          QUOTE_META_STRING_MODE,
          APOS_META_STRING_MODE,
          XML_META_PAR_KEYWORDS,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  XML_META_KEYWORDS,
                  XML_META_PAR_KEYWORDS,
                  QUOTE_META_STRING_MODE,
                  APOS_META_STRING_MODE
                ]
              }
            ]
          }
        ]
      },
      hljs.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      XML_ENTITIES,
      {
        className: "meta",
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              QUOTE_META_STRING_MODE
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/
          }
        ]
      },
      {
        className: "tag",
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [TAG_INTERNALS],
        starts: {
          end: /<\/style>/,
          returnEnd: true,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [TAG_INTERNALS],
        starts: {
          end: /<\/script>/,
          returnEnd: true,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      {
        className: "tag",
        begin: regex.concat(
          /</,
          regex.lookahead(regex.concat(
            TAG_NAME_RE,
            regex.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: TAG_NAME_RE,
            relevance: 0,
            starts: TAG_INTERNALS
          }
        ]
      },
      {
        className: "tag",
        begin: regex.concat(
          /<\//,
          regex.lookahead(regex.concat(
            TAG_NAME_RE,
            />/
          ))
        ),
        contains: [
          {
            className: "name",
            begin: TAG_NAME_RE,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: true
          }
        ]
      }
    ]
  };
}
function markdown(hljs) {
  const regex = hljs.regex;
  const INLINE_HTML = {
    begin: /<\/?[A-Za-z_]/,
    end: ">",
    subLanguage: "xml",
    relevance: 0
  };
  const HORIZONTAL_RULE = {
    begin: "^[-\\*]{3,}",
    end: "$"
  };
  const CODE = {
    className: "code",
    variants: [
      { begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
      { begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
      {
        begin: "```",
        end: "```+[ ]*$"
      },
      {
        begin: "~~~",
        end: "~~~+[ ]*$"
      },
      { begin: "`.+?`" },
      {
        begin: "(?=^( {4}|\\t))",
        contains: [
          {
            begin: "^( {4}|\\t)",
            end: "(\\n)$"
          }
        ],
        relevance: 0
      }
    ]
  };
  const LIST = {
    className: "bullet",
    begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
    end: "\\s+",
    excludeEnd: true
  };
  const LINK_REFERENCE = {
    begin: /^\[[^\n]+\]:/,
    returnBegin: true,
    contains: [
      {
        className: "symbol",
        begin: /\[/,
        end: /\]/,
        excludeBegin: true,
        excludeEnd: true
      },
      {
        className: "link",
        begin: /:\s*/,
        end: /$/,
        excludeBegin: true
      }
    ]
  };
  const URL_SCHEME = /[A-Za-z][A-Za-z0-9+.-]*/;
  const LINK = {
    variants: [
      {
        begin: /\[.+?\]\[.*?\]/,
        relevance: 0
      },
      {
        begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
        relevance: 2
      },
      {
        begin: regex.concat(/\[.+?\]\(/, URL_SCHEME, /:\/\/.*?\)/),
        relevance: 2
      },
      {
        begin: /\[.+?\]\([./?&#].*?\)/,
        relevance: 1
      },
      {
        begin: /\[.*?\]\(.*?\)/,
        relevance: 0
      }
    ],
    returnBegin: true,
    contains: [
      {
        match: /\[(?=\])/
      },
      {
        className: "string",
        relevance: 0,
        begin: "\\[",
        end: "\\]",
        excludeBegin: true,
        returnEnd: true
      },
      {
        className: "link",
        relevance: 0,
        begin: "\\]\\(",
        end: "\\)",
        excludeBegin: true,
        excludeEnd: true
      },
      {
        className: "symbol",
        relevance: 0,
        begin: "\\]\\[",
        end: "\\]",
        excludeBegin: true,
        excludeEnd: true
      }
    ]
  };
  const BOLD = {
    className: "strong",
    contains: [],
    variants: [
      {
        begin: /_{2}(?!\s)/,
        end: /_{2}/
      },
      {
        begin: /\*{2}(?!\s)/,
        end: /\*{2}/
      }
    ]
  };
  const ITALIC = {
    className: "emphasis",
    contains: [],
    variants: [
      {
        begin: /\*(?![*\s])/,
        end: /\*/
      },
      {
        begin: /_(?![_\s])/,
        end: /_/,
        relevance: 0
      }
    ]
  };
  const BOLD_WITHOUT_ITALIC = hljs.inherit(BOLD, { contains: [] });
  const ITALIC_WITHOUT_BOLD = hljs.inherit(ITALIC, { contains: [] });
  BOLD.contains.push(ITALIC_WITHOUT_BOLD);
  ITALIC.contains.push(BOLD_WITHOUT_ITALIC);
  let CONTAINABLE = [
    INLINE_HTML,
    LINK
  ];
  [
    BOLD,
    ITALIC,
    BOLD_WITHOUT_ITALIC,
    ITALIC_WITHOUT_BOLD
  ].forEach((m) => {
    m.contains = m.contains.concat(CONTAINABLE);
  });
  CONTAINABLE = CONTAINABLE.concat(BOLD, ITALIC);
  const HEADER = {
    className: "section",
    variants: [
      {
        begin: "^#{1,6}",
        end: "$",
        contains: CONTAINABLE
      },
      {
        begin: "(?=^.+?\\n[=-]{2,}$)",
        contains: [
          { begin: "^[=-]*$" },
          {
            begin: "^",
            end: "\\n",
            contains: CONTAINABLE
          }
        ]
      }
    ]
  };
  const BLOCKQUOTE = {
    className: "quote",
    begin: "^>\\s+",
    contains: CONTAINABLE,
    end: "$"
  };
  return {
    name: "Markdown",
    aliases: [
      "md",
      "mkdown",
      "mkd"
    ],
    contains: [
      HEADER,
      INLINE_HTML,
      LIST,
      BOLD,
      ITALIC,
      BLOCKQUOTE,
      CODE,
      HORIZONTAL_RULE,
      LINK,
      LINK_REFERENCE
    ]
  };
}
const MODES$2 = (hljs) => {
  return {
    IMPORTANT: {
      scope: "meta",
      begin: "!important"
    },
    BLOCK_COMMENT: hljs.C_BLOCK_COMMENT_MODE,
    HEXCOLOR: {
      scope: "number",
      begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
    },
    FUNCTION_DISPATCH: {
      className: "built_in",
      begin: /[\w-]+(?=\()/
    },
    ATTRIBUTE_SELECTOR_MODE: {
      scope: "selector-attr",
      begin: /\[/,
      end: /\]/,
      illegal: "$",
      contains: [
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE
      ]
    },
    CSS_NUMBER_MODE: {
      scope: "number",
      begin: hljs.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
      relevance: 0
    },
    CSS_VARIABLE: {
      className: "attr",
      begin: /--[A-Za-z][A-Za-z0-9_-]*/
    }
  };
};
const TAGS$2 = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "p",
  "q",
  "quote",
  "samp",
  "section",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
];
const MEDIA_FEATURES$2 = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  "min-width",
  "max-width",
  "min-height",
  "max-height"
];
const PSEUDO_CLASSES$2 = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  "host",
  "host-context",
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  "nth-child",
  "nth-col",
  "nth-last-child",
  "nth-last-col",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
];
const PSEUDO_ELEMENTS$2 = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
];
const ATTRIBUTES$2 = [
  "align-content",
  "align-items",
  "align-self",
  "all",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "direction",
  "display",
  "empty-cells",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-variant",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "gap",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "inline-size",
  "isolation",
  "justify-content",
  "left",
  "letter-spacing",
  "line-break",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "row-gap",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "speak",
  "speak-as",
  "src",
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-style",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-position",
  "top",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "unicode-bidi",
  "vertical-align",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "z-index"
].reverse();
function css(hljs) {
  const regex = hljs.regex;
  const modes = MODES$2(hljs);
  const VENDOR_PREFIX = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ };
  const AT_MODIFIERS = "and or not only";
  const AT_PROPERTY_RE = /@-?\w[\w]*(-\w+)*/;
  const IDENT_RE2 = "[a-zA-Z-][a-zA-Z0-9_-]*";
  const STRINGS = [
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE
  ];
  return {
    name: "CSS",
    case_insensitive: true,
    illegal: /[=|'\$]/,
    keywords: { keyframePosition: "from to" },
    classNameAliases: {
      keyframePosition: "selector-tag"
    },
    contains: [
      modes.BLOCK_COMMENT,
      VENDOR_PREFIX,
      modes.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: /#[A-Za-z0-9_-]+/,
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\." + IDENT_RE2,
        relevance: 0
      },
      modes.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        variants: [
          { begin: ":(" + PSEUDO_CLASSES$2.join("|") + ")" },
          { begin: ":(:)?(" + PSEUDO_ELEMENTS$2.join("|") + ")" }
        ]
      },
      modes.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + ATTRIBUTES$2.join("|") + ")\\b"
      },
      {
        begin: /:/,
        end: /[;}{]/,
        contains: [
          modes.BLOCK_COMMENT,
          modes.HEXCOLOR,
          modes.IMPORTANT,
          modes.CSS_NUMBER_MODE,
          ...STRINGS,
          {
            begin: /(url|data-uri)\(/,
            end: /\)/,
            relevance: 0,
            keywords: { built_in: "url data-uri" },
            contains: [
              ...STRINGS,
              {
                className: "string",
                begin: /[^)]/,
                endsWithParent: true,
                excludeEnd: true
              }
            ]
          },
          modes.FUNCTION_DISPATCH
        ]
      },
      {
        begin: regex.lookahead(/@/),
        end: "[{;]",
        relevance: 0,
        illegal: /:/,
        contains: [
          {
            className: "keyword",
            begin: AT_PROPERTY_RE
          },
          {
            begin: /\s/,
            endsWithParent: true,
            excludeEnd: true,
            relevance: 0,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: AT_MODIFIERS,
              attribute: MEDIA_FEATURES$2.join(" ")
            },
            contains: [
              {
                begin: /[a-z-]+(?=:)/,
                className: "attribute"
              },
              ...STRINGS,
              modes.CSS_NUMBER_MODE
            ]
          }
        ]
      },
      {
        className: "selector-tag",
        begin: "\\b(" + TAGS$2.join("|") + ")\\b"
      }
    ]
  };
}
const MODES$1 = (hljs) => {
  return {
    IMPORTANT: {
      scope: "meta",
      begin: "!important"
    },
    BLOCK_COMMENT: hljs.C_BLOCK_COMMENT_MODE,
    HEXCOLOR: {
      scope: "number",
      begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
    },
    FUNCTION_DISPATCH: {
      className: "built_in",
      begin: /[\w-]+(?=\()/
    },
    ATTRIBUTE_SELECTOR_MODE: {
      scope: "selector-attr",
      begin: /\[/,
      end: /\]/,
      illegal: "$",
      contains: [
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE
      ]
    },
    CSS_NUMBER_MODE: {
      scope: "number",
      begin: hljs.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
      relevance: 0
    },
    CSS_VARIABLE: {
      className: "attr",
      begin: /--[A-Za-z][A-Za-z0-9_-]*/
    }
  };
};
const TAGS$1 = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "p",
  "q",
  "quote",
  "samp",
  "section",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
];
const MEDIA_FEATURES$1 = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  "min-width",
  "max-width",
  "min-height",
  "max-height"
];
const PSEUDO_CLASSES$1 = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  "host",
  "host-context",
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  "nth-child",
  "nth-col",
  "nth-last-child",
  "nth-last-col",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
];
const PSEUDO_ELEMENTS$1 = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
];
const ATTRIBUTES$1 = [
  "align-content",
  "align-items",
  "align-self",
  "all",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "direction",
  "display",
  "empty-cells",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-variant",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "gap",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "inline-size",
  "isolation",
  "justify-content",
  "left",
  "letter-spacing",
  "line-break",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "row-gap",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "speak",
  "speak-as",
  "src",
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-style",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-position",
  "top",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "unicode-bidi",
  "vertical-align",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "z-index"
].reverse();
const PSEUDO_SELECTORS = PSEUDO_CLASSES$1.concat(PSEUDO_ELEMENTS$1);
function less(hljs) {
  const modes = MODES$1(hljs);
  const PSEUDO_SELECTORS$1 = PSEUDO_SELECTORS;
  const AT_MODIFIERS = "and or not only";
  const IDENT_RE2 = "[\\w-]+";
  const INTERP_IDENT_RE = "(" + IDENT_RE2 + "|@\\{" + IDENT_RE2 + "\\})";
  const RULES = [];
  const VALUE_MODES = [];
  const STRING_MODE = function(c) {
    return {
      className: "string",
      begin: "~?" + c + ".*?" + c
    };
  };
  const IDENT_MODE = function(name, begin, relevance) {
    return {
      className: name,
      begin,
      relevance
    };
  };
  const AT_KEYWORDS = {
    $pattern: /[a-z-]+/,
    keyword: AT_MODIFIERS,
    attribute: MEDIA_FEATURES$1.join(" ")
  };
  const PARENS_MODE = {
    begin: "\\(",
    end: "\\)",
    contains: VALUE_MODES,
    keywords: AT_KEYWORDS,
    relevance: 0
  };
  VALUE_MODES.push(
    hljs.C_LINE_COMMENT_MODE,
    hljs.C_BLOCK_COMMENT_MODE,
    STRING_MODE("'"),
    STRING_MODE('"'),
    modes.CSS_NUMBER_MODE,
    {
      begin: "(url|data-uri)\\(",
      starts: {
        className: "string",
        end: "[\\)\\n]",
        excludeEnd: true
      }
    },
    modes.HEXCOLOR,
    PARENS_MODE,
    IDENT_MODE("variable", "@@?" + IDENT_RE2, 10),
    IDENT_MODE("variable", "@\\{" + IDENT_RE2 + "\\}"),
    IDENT_MODE("built_in", "~?`[^`]*?`"),
    {
      className: "attribute",
      begin: IDENT_RE2 + "\\s*:",
      end: ":",
      returnBegin: true,
      excludeEnd: true
    },
    modes.IMPORTANT,
    { beginKeywords: "and not" },
    modes.FUNCTION_DISPATCH
  );
  const VALUE_WITH_RULESETS = VALUE_MODES.concat({
    begin: /\{/,
    end: /\}/,
    contains: RULES
  });
  const MIXIN_GUARD_MODE = {
    beginKeywords: "when",
    endsWithParent: true,
    contains: [{ beginKeywords: "and not" }].concat(VALUE_MODES)
  };
  const RULE_MODE = {
    begin: INTERP_IDENT_RE + "\\s*:",
    returnBegin: true,
    end: /[;}]/,
    relevance: 0,
    contains: [
      { begin: /-(webkit|moz|ms|o)-/ },
      modes.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + ATTRIBUTES$1.join("|") + ")\\b",
        end: /(?=:)/,
        starts: {
          endsWithParent: true,
          illegal: "[<=$]",
          relevance: 0,
          contains: VALUE_MODES
        }
      }
    ]
  };
  const AT_RULE_MODE = {
    className: "keyword",
    begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
    starts: {
      end: "[;{}]",
      keywords: AT_KEYWORDS,
      returnEnd: true,
      contains: VALUE_MODES,
      relevance: 0
    }
  };
  const VAR_RULE_MODE = {
    className: "variable",
    variants: [
      {
        begin: "@" + IDENT_RE2 + "\\s*:",
        relevance: 15
      },
      { begin: "@" + IDENT_RE2 }
    ],
    starts: {
      end: "[;}]",
      returnEnd: true,
      contains: VALUE_WITH_RULESETS
    }
  };
  const SELECTOR_MODE = {
    variants: [
      {
        begin: "[\\.#:&\\[>]",
        end: "[;{}]"
      },
      {
        begin: INTERP_IDENT_RE,
        end: /\{/
      }
    ],
    returnBegin: true,
    returnEnd: true,
    illegal: `[<='$"]`,
    relevance: 0,
    contains: [
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      MIXIN_GUARD_MODE,
      IDENT_MODE("keyword", "all\\b"),
      IDENT_MODE("variable", "@\\{" + IDENT_RE2 + "\\}"),
      {
        begin: "\\b(" + TAGS$1.join("|") + ")\\b",
        className: "selector-tag"
      },
      modes.CSS_NUMBER_MODE,
      IDENT_MODE("selector-tag", INTERP_IDENT_RE, 0),
      IDENT_MODE("selector-id", "#" + INTERP_IDENT_RE),
      IDENT_MODE("selector-class", "\\." + INTERP_IDENT_RE, 0),
      IDENT_MODE("selector-tag", "&", 0),
      modes.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        begin: ":(" + PSEUDO_CLASSES$1.join("|") + ")"
      },
      {
        className: "selector-pseudo",
        begin: ":(:)?(" + PSEUDO_ELEMENTS$1.join("|") + ")"
      },
      {
        begin: /\(/,
        end: /\)/,
        relevance: 0,
        contains: VALUE_WITH_RULESETS
      },
      { begin: "!important" },
      modes.FUNCTION_DISPATCH
    ]
  };
  const PSEUDO_SELECTOR_MODE = {
    begin: IDENT_RE2 + `:(:)?(${PSEUDO_SELECTORS$1.join("|")})`,
    returnBegin: true,
    contains: [SELECTOR_MODE]
  };
  RULES.push(
    hljs.C_LINE_COMMENT_MODE,
    hljs.C_BLOCK_COMMENT_MODE,
    AT_RULE_MODE,
    VAR_RULE_MODE,
    PSEUDO_SELECTOR_MODE,
    RULE_MODE,
    SELECTOR_MODE,
    MIXIN_GUARD_MODE,
    modes.FUNCTION_DISPATCH
  );
  return {
    name: "Less",
    case_insensitive: true,
    illegal: `[=>'/<($"]`,
    contains: RULES
  };
}
const MODES = (hljs) => {
  return {
    IMPORTANT: {
      scope: "meta",
      begin: "!important"
    },
    BLOCK_COMMENT: hljs.C_BLOCK_COMMENT_MODE,
    HEXCOLOR: {
      scope: "number",
      begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
    },
    FUNCTION_DISPATCH: {
      className: "built_in",
      begin: /[\w-]+(?=\()/
    },
    ATTRIBUTE_SELECTOR_MODE: {
      scope: "selector-attr",
      begin: /\[/,
      end: /\]/,
      illegal: "$",
      contains: [
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE
      ]
    },
    CSS_NUMBER_MODE: {
      scope: "number",
      begin: hljs.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
      relevance: 0
    },
    CSS_VARIABLE: {
      className: "attr",
      begin: /--[A-Za-z][A-Za-z0-9_-]*/
    }
  };
};
const TAGS = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "p",
  "q",
  "quote",
  "samp",
  "section",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
];
const MEDIA_FEATURES = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  "min-width",
  "max-width",
  "min-height",
  "max-height"
];
const PSEUDO_CLASSES = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  "host",
  "host-context",
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  "nth-child",
  "nth-col",
  "nth-last-child",
  "nth-last-col",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
];
const PSEUDO_ELEMENTS = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
];
const ATTRIBUTES = [
  "align-content",
  "align-items",
  "align-self",
  "all",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "direction",
  "display",
  "empty-cells",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-variant",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "gap",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "inline-size",
  "isolation",
  "justify-content",
  "left",
  "letter-spacing",
  "line-break",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "row-gap",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "speak",
  "speak-as",
  "src",
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-style",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-position",
  "top",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "unicode-bidi",
  "vertical-align",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "z-index"
].reverse();
function scss(hljs) {
  const modes = MODES(hljs);
  const PSEUDO_ELEMENTS$12 = PSEUDO_ELEMENTS;
  const PSEUDO_CLASSES$12 = PSEUDO_CLASSES;
  const AT_IDENTIFIER = "@[a-z-]+";
  const AT_MODIFIERS = "and or not only";
  const IDENT_RE2 = "[a-zA-Z-][a-zA-Z0-9_-]*";
  const VARIABLE = {
    className: "variable",
    begin: "(\\$" + IDENT_RE2 + ")\\b",
    relevance: 0
  };
  return {
    name: "SCSS",
    case_insensitive: true,
    illegal: "[=/|']",
    contains: [
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      modes.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: "#[A-Za-z0-9_-]+",
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\.[A-Za-z0-9_-]+",
        relevance: 0
      },
      modes.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-tag",
        begin: "\\b(" + TAGS.join("|") + ")\\b",
        relevance: 0
      },
      {
        className: "selector-pseudo",
        begin: ":(" + PSEUDO_CLASSES$12.join("|") + ")"
      },
      {
        className: "selector-pseudo",
        begin: ":(:)?(" + PSEUDO_ELEMENTS$12.join("|") + ")"
      },
      VARIABLE,
      {
        begin: /\(/,
        end: /\)/,
        contains: [modes.CSS_NUMBER_MODE]
      },
      modes.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + ATTRIBUTES.join("|") + ")\\b"
      },
      { begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b" },
      {
        begin: /:/,
        end: /[;}{]/,
        relevance: 0,
        contains: [
          modes.BLOCK_COMMENT,
          VARIABLE,
          modes.HEXCOLOR,
          modes.CSS_NUMBER_MODE,
          hljs.QUOTE_STRING_MODE,
          hljs.APOS_STRING_MODE,
          modes.IMPORTANT,
          modes.FUNCTION_DISPATCH
        ]
      },
      {
        begin: "@(page|font-face)",
        keywords: {
          $pattern: AT_IDENTIFIER,
          keyword: "@page @font-face"
        }
      },
      {
        begin: "@",
        end: "[{;]",
        returnBegin: true,
        keywords: {
          $pattern: /[a-z-]+/,
          keyword: AT_MODIFIERS,
          attribute: MEDIA_FEATURES.join(" ")
        },
        contains: [
          {
            begin: AT_IDENTIFIER,
            className: "keyword"
          },
          {
            begin: /[a-z-]+(?=:)/,
            className: "attribute"
          },
          VARIABLE,
          hljs.QUOTE_STRING_MODE,
          hljs.APOS_STRING_MODE,
          modes.HEXCOLOR,
          modes.CSS_NUMBER_MODE
        ]
      },
      modes.FUNCTION_DISPATCH
    ]
  };
}
function objectivec(hljs) {
  const API_CLASS = {
    className: "built_in",
    begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"
  };
  const IDENTIFIER_RE = /[a-zA-Z@][a-zA-Z0-9_]*/;
  const TYPES2 = [
    "int",
    "float",
    "char",
    "unsigned",
    "signed",
    "short",
    "long",
    "double",
    "wchar_t",
    "unichar",
    "void",
    "bool",
    "BOOL",
    "id|0",
    "_Bool"
  ];
  const KWS = [
    "while",
    "export",
    "sizeof",
    "typedef",
    "const",
    "struct",
    "for",
    "union",
    "volatile",
    "static",
    "mutable",
    "if",
    "do",
    "return",
    "goto",
    "enum",
    "else",
    "break",
    "extern",
    "asm",
    "case",
    "default",
    "register",
    "explicit",
    "typename",
    "switch",
    "continue",
    "inline",
    "readonly",
    "assign",
    "readwrite",
    "self",
    "@synchronized",
    "id",
    "typeof",
    "nonatomic",
    "IBOutlet",
    "IBAction",
    "strong",
    "weak",
    "copy",
    "in",
    "out",
    "inout",
    "bycopy",
    "byref",
    "oneway",
    "__strong",
    "__weak",
    "__block",
    "__autoreleasing",
    "@private",
    "@protected",
    "@public",
    "@try",
    "@property",
    "@end",
    "@throw",
    "@catch",
    "@finally",
    "@autoreleasepool",
    "@synthesize",
    "@dynamic",
    "@selector",
    "@optional",
    "@required",
    "@encode",
    "@package",
    "@import",
    "@defs",
    "@compatibility_alias",
    "__bridge",
    "__bridge_transfer",
    "__bridge_retained",
    "__bridge_retain",
    "__covariant",
    "__contravariant",
    "__kindof",
    "_Nonnull",
    "_Nullable",
    "_Null_unspecified",
    "__FUNCTION__",
    "__PRETTY_FUNCTION__",
    "__attribute__",
    "getter",
    "setter",
    "retain",
    "unsafe_unretained",
    "nonnull",
    "nullable",
    "null_unspecified",
    "null_resettable",
    "class",
    "instancetype",
    "NS_DESIGNATED_INITIALIZER",
    "NS_UNAVAILABLE",
    "NS_REQUIRES_SUPER",
    "NS_RETURNS_INNER_POINTER",
    "NS_INLINE",
    "NS_AVAILABLE",
    "NS_DEPRECATED",
    "NS_ENUM",
    "NS_OPTIONS",
    "NS_SWIFT_UNAVAILABLE",
    "NS_ASSUME_NONNULL_BEGIN",
    "NS_ASSUME_NONNULL_END",
    "NS_REFINED_FOR_SWIFT",
    "NS_SWIFT_NAME",
    "NS_SWIFT_NOTHROW",
    "NS_DURING",
    "NS_HANDLER",
    "NS_ENDHANDLER",
    "NS_VALUERETURN",
    "NS_VOIDRETURN"
  ];
  const LITERALS2 = [
    "false",
    "true",
    "FALSE",
    "TRUE",
    "nil",
    "YES",
    "NO",
    "NULL"
  ];
  const BUILT_INS2 = [
    "dispatch_once_t",
    "dispatch_queue_t",
    "dispatch_sync",
    "dispatch_async",
    "dispatch_once"
  ];
  const KEYWORDS2 = {
    "variable.language": [
      "this",
      "super"
    ],
    $pattern: IDENTIFIER_RE,
    keyword: KWS,
    literal: LITERALS2,
    built_in: BUILT_INS2,
    type: TYPES2
  };
  const CLASS_KEYWORDS = {
    $pattern: IDENTIFIER_RE,
    keyword: [
      "@interface",
      "@class",
      "@protocol",
      "@implementation"
    ]
  };
  return {
    name: "Objective-C",
    aliases: [
      "mm",
      "objc",
      "obj-c",
      "obj-c++",
      "objective-c++"
    ],
    keywords: KEYWORDS2,
    illegal: "</",
    contains: [
      API_CLASS,
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.C_NUMBER_MODE,
      hljs.QUOTE_STRING_MODE,
      hljs.APOS_STRING_MODE,
      {
        className: "string",
        variants: [
          {
            begin: '@"',
            end: '"',
            illegal: "\\n",
            contains: [hljs.BACKSLASH_ESCAPE]
          }
        ]
      },
      {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          hljs.inherit(hljs.QUOTE_STRING_MODE, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/,
            end: /$/,
            illegal: "\\n"
          },
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        className: "class",
        begin: "(" + CLASS_KEYWORDS.keyword.join("|") + ")\\b",
        end: /(\{|$)/,
        excludeEnd: true,
        keywords: CLASS_KEYWORDS,
        contains: [hljs.UNDERSCORE_TITLE_MODE]
      },
      {
        begin: "\\." + hljs.UNDERSCORE_IDENT_RE,
        relevance: 0
      }
    ]
  };
}
function source(re) {
  if (!re)
    return null;
  if (typeof re === "string")
    return re;
  return re.source;
}
function lookahead(re) {
  return concat("(?=", re, ")");
}
function concat(...args) {
  const joined = args.map((x) => source(x)).join("");
  return joined;
}
function stripOptionsFromArgs(args) {
  const opts = args[args.length - 1];
  if (typeof opts === "object" && opts.constructor === Object) {
    args.splice(args.length - 1, 1);
    return opts;
  } else {
    return {};
  }
}
function either(...args) {
  const opts = stripOptionsFromArgs(args);
  const joined = "(" + (opts.capture ? "" : "?:") + args.map((x) => source(x)).join("|") + ")";
  return joined;
}
const keywordWrapper = (keyword) => concat(
  /\b/,
  keyword,
  /\w$/.test(keyword) ? /\b/ : /\B/
);
const dotKeywords = [
  "Protocol",
  "Type"
].map(keywordWrapper);
const optionalDotKeywords = [
  "init",
  "self"
].map(keywordWrapper);
const keywordTypes = [
  "Any",
  "Self"
];
const keywords = [
  "actor",
  "any",
  "associatedtype",
  "async",
  "await",
  /as\?/,
  /as!/,
  "as",
  "break",
  "case",
  "catch",
  "class",
  "continue",
  "convenience",
  "default",
  "defer",
  "deinit",
  "didSet",
  "distributed",
  "do",
  "dynamic",
  "else",
  "enum",
  "extension",
  "fallthrough",
  /fileprivate\(set\)/,
  "fileprivate",
  "final",
  "for",
  "func",
  "get",
  "guard",
  "if",
  "import",
  "indirect",
  "infix",
  /init\?/,
  /init!/,
  "inout",
  /internal\(set\)/,
  "internal",
  "in",
  "is",
  "isolated",
  "nonisolated",
  "lazy",
  "let",
  "mutating",
  "nonmutating",
  /open\(set\)/,
  "open",
  "operator",
  "optional",
  "override",
  "postfix",
  "precedencegroup",
  "prefix",
  /private\(set\)/,
  "private",
  "protocol",
  /public\(set\)/,
  "public",
  "repeat",
  "required",
  "rethrows",
  "return",
  "set",
  "some",
  "static",
  "struct",
  "subscript",
  "super",
  "switch",
  "throws",
  "throw",
  /try\?/,
  /try!/,
  "try",
  "typealias",
  /unowned\(safe\)/,
  /unowned\(unsafe\)/,
  "unowned",
  "var",
  "weak",
  "where",
  "while",
  "willSet"
];
const literals = [
  "false",
  "nil",
  "true"
];
const precedencegroupKeywords = [
  "assignment",
  "associativity",
  "higherThan",
  "left",
  "lowerThan",
  "none",
  "right"
];
const numberSignKeywords = [
  "#colorLiteral",
  "#column",
  "#dsohandle",
  "#else",
  "#elseif",
  "#endif",
  "#error",
  "#file",
  "#fileID",
  "#fileLiteral",
  "#filePath",
  "#function",
  "#if",
  "#imageLiteral",
  "#keyPath",
  "#line",
  "#selector",
  "#sourceLocation",
  "#warn_unqualified_access",
  "#warning"
];
const builtIns = [
  "abs",
  "all",
  "any",
  "assert",
  "assertionFailure",
  "debugPrint",
  "dump",
  "fatalError",
  "getVaList",
  "isKnownUniquelyReferenced",
  "max",
  "min",
  "numericCast",
  "pointwiseMax",
  "pointwiseMin",
  "precondition",
  "preconditionFailure",
  "print",
  "readLine",
  "repeatElement",
  "sequence",
  "stride",
  "swap",
  "swift_unboxFromSwiftValueWithType",
  "transcode",
  "type",
  "unsafeBitCast",
  "unsafeDowncast",
  "withExtendedLifetime",
  "withUnsafeMutablePointer",
  "withUnsafePointer",
  "withVaList",
  "withoutActuallyEscaping",
  "zip"
];
const operatorHead = either(
  /[/=\-+!*%<>&|^~?]/,
  /[\u00A1-\u00A7]/,
  /[\u00A9\u00AB]/,
  /[\u00AC\u00AE]/,
  /[\u00B0\u00B1]/,
  /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
  /[\u2016-\u2017]/,
  /[\u2020-\u2027]/,
  /[\u2030-\u203E]/,
  /[\u2041-\u2053]/,
  /[\u2055-\u205E]/,
  /[\u2190-\u23FF]/,
  /[\u2500-\u2775]/,
  /[\u2794-\u2BFF]/,
  /[\u2E00-\u2E7F]/,
  /[\u3001-\u3003]/,
  /[\u3008-\u3020]/,
  /[\u3030]/
);
const operatorCharacter = either(
  operatorHead,
  /[\u0300-\u036F]/,
  /[\u1DC0-\u1DFF]/,
  /[\u20D0-\u20FF]/,
  /[\uFE00-\uFE0F]/,
  /[\uFE20-\uFE2F]/
);
const operator = concat(operatorHead, operatorCharacter, "*");
const identifierHead = either(
  /[a-zA-Z_]/,
  /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
  /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
  /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
  /[\u1E00-\u1FFF]/,
  /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
  /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
  /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
  /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
  /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
  /[\uFE47-\uFEFE\uFF00-\uFFFD]/
);
const identifierCharacter = either(
  identifierHead,
  /\d/,
  /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/
);
const identifier = concat(identifierHead, identifierCharacter, "*");
const typeIdentifier = concat(/[A-Z]/, identifierCharacter, "*");
const keywordAttributes = [
  "autoclosure",
  concat(/convention\(/, either("swift", "block", "c"), /\)/),
  "discardableResult",
  "dynamicCallable",
  "dynamicMemberLookup",
  "escaping",
  "frozen",
  "GKInspectable",
  "IBAction",
  "IBDesignable",
  "IBInspectable",
  "IBOutlet",
  "IBSegueAction",
  "inlinable",
  "main",
  "nonobjc",
  "NSApplicationMain",
  "NSCopying",
  "NSManaged",
  concat(/objc\(/, identifier, /\)/),
  "objc",
  "objcMembers",
  "propertyWrapper",
  "requires_stored_property_inits",
  "resultBuilder",
  "testable",
  "UIApplicationMain",
  "unknown",
  "usableFromInline"
];
const availabilityKeywords = [
  "iOS",
  "iOSApplicationExtension",
  "macOS",
  "macOSApplicationExtension",
  "macCatalyst",
  "macCatalystApplicationExtension",
  "watchOS",
  "watchOSApplicationExtension",
  "tvOS",
  "tvOSApplicationExtension",
  "swift"
];
function swift(hljs) {
  const WHITESPACE = {
    match: /\s+/,
    relevance: 0
  };
  const BLOCK_COMMENT = hljs.COMMENT(
    "/\\*",
    "\\*/",
    { contains: ["self"] }
  );
  const COMMENTS = [
    hljs.C_LINE_COMMENT_MODE,
    BLOCK_COMMENT
  ];
  const DOT_KEYWORD = {
    match: [
      /\./,
      either(...dotKeywords, ...optionalDotKeywords)
    ],
    className: { 2: "keyword" }
  };
  const KEYWORD_GUARD = {
    match: concat(/\./, either(...keywords)),
    relevance: 0
  };
  const PLAIN_KEYWORDS = keywords.filter((kw) => typeof kw === "string").concat(["_|0"]);
  const REGEX_KEYWORDS = keywords.filter((kw) => typeof kw !== "string").concat(keywordTypes).map(keywordWrapper);
  const KEYWORD = { variants: [
    {
      className: "keyword",
      match: either(...REGEX_KEYWORDS, ...optionalDotKeywords)
    }
  ] };
  const KEYWORDS2 = {
    $pattern: either(
      /\b\w+/,
      /#\w+/
    ),
    keyword: PLAIN_KEYWORDS.concat(numberSignKeywords),
    literal: literals
  };
  const KEYWORD_MODES = [
    DOT_KEYWORD,
    KEYWORD_GUARD,
    KEYWORD
  ];
  const BUILT_IN_GUARD = {
    match: concat(/\./, either(...builtIns)),
    relevance: 0
  };
  const BUILT_IN = {
    className: "built_in",
    match: concat(/\b/, either(...builtIns), /(?=\()/)
  };
  const BUILT_INS2 = [
    BUILT_IN_GUARD,
    BUILT_IN
  ];
  const OPERATOR_GUARD = {
    match: /->/,
    relevance: 0
  };
  const OPERATOR = {
    className: "operator",
    relevance: 0,
    variants: [
      { match: operator },
      {
        match: `\\.(\\.|${operatorCharacter})+`
      }
    ]
  };
  const OPERATORS = [
    OPERATOR_GUARD,
    OPERATOR
  ];
  const decimalDigits2 = "([0-9]_*)+";
  const hexDigits2 = "([0-9a-fA-F]_*)+";
  const NUMBER = {
    className: "number",
    relevance: 0,
    variants: [
      { match: `\\b(${decimalDigits2})(\\.(${decimalDigits2}))?([eE][+-]?(${decimalDigits2}))?\\b` },
      { match: `\\b0x(${hexDigits2})(\\.(${hexDigits2}))?([pP][+-]?(${decimalDigits2}))?\\b` },
      { match: /\b0o([0-7]_*)+\b/ },
      { match: /\b0b([01]_*)+\b/ }
    ]
  };
  const ESCAPED_CHARACTER = (rawDelimiter = "") => ({
    className: "subst",
    variants: [
      { match: concat(/\\/, rawDelimiter, /[0\\tnr"']/) },
      { match: concat(/\\/, rawDelimiter, /u\{[0-9a-fA-F]{1,8}\}/) }
    ]
  });
  const ESCAPED_NEWLINE = (rawDelimiter = "") => ({
    className: "subst",
    match: concat(/\\/, rawDelimiter, /[\t ]*(?:[\r\n]|\r\n)/)
  });
  const INTERPOLATION = (rawDelimiter = "") => ({
    className: "subst",
    label: "interpol",
    begin: concat(/\\/, rawDelimiter, /\(/),
    end: /\)/
  });
  const MULTILINE_STRING = (rawDelimiter = "") => ({
    begin: concat(rawDelimiter, /"""/),
    end: concat(/"""/, rawDelimiter),
    contains: [
      ESCAPED_CHARACTER(rawDelimiter),
      ESCAPED_NEWLINE(rawDelimiter),
      INTERPOLATION(rawDelimiter)
    ]
  });
  const SINGLE_LINE_STRING = (rawDelimiter = "") => ({
    begin: concat(rawDelimiter, /"/),
    end: concat(/"/, rawDelimiter),
    contains: [
      ESCAPED_CHARACTER(rawDelimiter),
      INTERPOLATION(rawDelimiter)
    ]
  });
  const STRING = {
    className: "string",
    variants: [
      MULTILINE_STRING(),
      MULTILINE_STRING("#"),
      MULTILINE_STRING("##"),
      MULTILINE_STRING("###"),
      SINGLE_LINE_STRING(),
      SINGLE_LINE_STRING("#"),
      SINGLE_LINE_STRING("##"),
      SINGLE_LINE_STRING("###")
    ]
  };
  const QUOTED_IDENTIFIER = { match: concat(/`/, identifier, /`/) };
  const IMPLICIT_PARAMETER = {
    className: "variable",
    match: /\$\d+/
  };
  const PROPERTY_WRAPPER_PROJECTION = {
    className: "variable",
    match: `\\$${identifierCharacter}+`
  };
  const IDENTIFIERS = [
    QUOTED_IDENTIFIER,
    IMPLICIT_PARAMETER,
    PROPERTY_WRAPPER_PROJECTION
  ];
  const AVAILABLE_ATTRIBUTE = {
    match: /(@|#(un)?)available/,
    className: "keyword",
    starts: { contains: [
      {
        begin: /\(/,
        end: /\)/,
        keywords: availabilityKeywords,
        contains: [
          ...OPERATORS,
          NUMBER,
          STRING
        ]
      }
    ] }
  };
  const KEYWORD_ATTRIBUTE = {
    className: "keyword",
    match: concat(/@/, either(...keywordAttributes))
  };
  const USER_DEFINED_ATTRIBUTE = {
    className: "meta",
    match: concat(/@/, identifier)
  };
  const ATTRIBUTES2 = [
    AVAILABLE_ATTRIBUTE,
    KEYWORD_ATTRIBUTE,
    USER_DEFINED_ATTRIBUTE
  ];
  const TYPE = {
    match: lookahead(/\b[A-Z]/),
    relevance: 0,
    contains: [
      {
        className: "type",
        match: concat(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, identifierCharacter, "+")
      },
      {
        className: "type",
        match: typeIdentifier,
        relevance: 0
      },
      {
        match: /[?!]+/,
        relevance: 0
      },
      {
        match: /\.\.\./,
        relevance: 0
      },
      {
        match: concat(/\s+&\s+/, lookahead(typeIdentifier)),
        relevance: 0
      }
    ]
  };
  const GENERIC_ARGUMENTS = {
    begin: /</,
    end: />/,
    keywords: KEYWORDS2,
    contains: [
      ...COMMENTS,
      ...KEYWORD_MODES,
      ...ATTRIBUTES2,
      OPERATOR_GUARD,
      TYPE
    ]
  };
  TYPE.contains.push(GENERIC_ARGUMENTS);
  const TUPLE_ELEMENT_NAME = {
    match: concat(identifier, /\s*:/),
    keywords: "_|0",
    relevance: 0
  };
  const TUPLE = {
    begin: /\(/,
    end: /\)/,
    relevance: 0,
    keywords: KEYWORDS2,
    contains: [
      "self",
      TUPLE_ELEMENT_NAME,
      ...COMMENTS,
      ...KEYWORD_MODES,
      ...BUILT_INS2,
      ...OPERATORS,
      NUMBER,
      STRING,
      ...IDENTIFIERS,
      ...ATTRIBUTES2,
      TYPE
    ]
  };
  const GENERIC_PARAMETERS = {
    begin: /</,
    end: />/,
    contains: [
      ...COMMENTS,
      TYPE
    ]
  };
  const FUNCTION_PARAMETER_NAME = {
    begin: either(
      lookahead(concat(identifier, /\s*:/)),
      lookahead(concat(identifier, /\s+/, identifier, /\s*:/))
    ),
    end: /:/,
    relevance: 0,
    contains: [
      {
        className: "keyword",
        match: /\b_\b/
      },
      {
        className: "params",
        match: identifier
      }
    ]
  };
  const FUNCTION_PARAMETERS = {
    begin: /\(/,
    end: /\)/,
    keywords: KEYWORDS2,
    contains: [
      FUNCTION_PARAMETER_NAME,
      ...COMMENTS,
      ...KEYWORD_MODES,
      ...OPERATORS,
      NUMBER,
      STRING,
      ...ATTRIBUTES2,
      TYPE,
      TUPLE
    ],
    endsParent: true,
    illegal: /["']/
  };
  const FUNCTION = {
    match: [
      /func/,
      /\s+/,
      either(QUOTED_IDENTIFIER.match, identifier, operator)
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      GENERIC_PARAMETERS,
      FUNCTION_PARAMETERS,
      WHITESPACE
    ],
    illegal: [
      /\[/,
      /%/
    ]
  };
  const INIT_SUBSCRIPT = {
    match: [
      /\b(?:subscript|init[?!]?)/,
      /\s*(?=[<(])/
    ],
    className: { 1: "keyword" },
    contains: [
      GENERIC_PARAMETERS,
      FUNCTION_PARAMETERS,
      WHITESPACE
    ],
    illegal: /\[|%/
  };
  const OPERATOR_DECLARATION = {
    match: [
      /operator/,
      /\s+/,
      operator
    ],
    className: {
      1: "keyword",
      3: "title"
    }
  };
  const PRECEDENCEGROUP = {
    begin: [
      /precedencegroup/,
      /\s+/,
      typeIdentifier
    ],
    className: {
      1: "keyword",
      3: "title"
    },
    contains: [TYPE],
    keywords: [
      ...precedencegroupKeywords,
      ...literals
    ],
    end: /}/
  };
  for (const variant of STRING.variants) {
    const interpolation = variant.contains.find((mode) => mode.label === "interpol");
    interpolation.keywords = KEYWORDS2;
    const submodes = [
      ...KEYWORD_MODES,
      ...BUILT_INS2,
      ...OPERATORS,
      NUMBER,
      STRING,
      ...IDENTIFIERS
    ];
    interpolation.contains = [
      ...submodes,
      {
        begin: /\(/,
        end: /\)/,
        contains: [
          "self",
          ...submodes
        ]
      }
    ];
  }
  return {
    name: "Swift",
    keywords: KEYWORDS2,
    contains: [
      ...COMMENTS,
      FUNCTION,
      INIT_SUBSCRIPT,
      {
        beginKeywords: "struct protocol class extension enum actor",
        end: "\\{",
        excludeEnd: true,
        keywords: KEYWORDS2,
        contains: [
          hljs.inherit(hljs.TITLE_MODE, {
            className: "title.class",
            begin: /[A-Za-z$_][\u00C0-\u02B80-9A-Za-z$_]*/
          }),
          ...KEYWORD_MODES
        ]
      },
      OPERATOR_DECLARATION,
      PRECEDENCEGROUP,
      {
        beginKeywords: "import",
        end: /$/,
        contains: [...COMMENTS],
        relevance: 0
      },
      ...KEYWORD_MODES,
      ...BUILT_INS2,
      ...OPERATORS,
      NUMBER,
      STRING,
      ...IDENTIFIERS,
      ...ATTRIBUTES2,
      TYPE,
      TUPLE
    ]
  };
}
function dart(hljs) {
  const SUBST = {
    className: "subst",
    variants: [{ begin: "\\$[A-Za-z0-9_]+" }]
  };
  const BRACED_SUBST = {
    className: "subst",
    variants: [
      {
        begin: /\$\{/,
        end: /\}/
      }
    ],
    keywords: "true false null this is new super"
  };
  const STRING = {
    className: "string",
    variants: [
      {
        begin: "r'''",
        end: "'''"
      },
      {
        begin: 'r"""',
        end: '"""'
      },
      {
        begin: "r'",
        end: "'",
        illegal: "\\n"
      },
      {
        begin: 'r"',
        end: '"',
        illegal: "\\n"
      },
      {
        begin: "'''",
        end: "'''",
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST,
          BRACED_SUBST
        ]
      },
      {
        begin: '"""',
        end: '"""',
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST,
          BRACED_SUBST
        ]
      },
      {
        begin: "'",
        end: "'",
        illegal: "\\n",
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST,
          BRACED_SUBST
        ]
      },
      {
        begin: '"',
        end: '"',
        illegal: "\\n",
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST,
          BRACED_SUBST
        ]
      }
    ]
  };
  BRACED_SUBST.contains = [
    hljs.C_NUMBER_MODE,
    STRING
  ];
  const BUILT_IN_TYPES = [
    "Comparable",
    "DateTime",
    "Duration",
    "Function",
    "Iterable",
    "Iterator",
    "List",
    "Map",
    "Match",
    "Object",
    "Pattern",
    "RegExp",
    "Set",
    "Stopwatch",
    "String",
    "StringBuffer",
    "StringSink",
    "Symbol",
    "Type",
    "Uri",
    "bool",
    "double",
    "int",
    "num",
    "Element",
    "ElementList"
  ];
  const NULLABLE_BUILT_IN_TYPES = BUILT_IN_TYPES.map((e) => `${e}?`);
  const BASIC_KEYWORDS = [
    "abstract",
    "as",
    "assert",
    "async",
    "await",
    "base",
    "break",
    "case",
    "catch",
    "class",
    "const",
    "continue",
    "covariant",
    "default",
    "deferred",
    "do",
    "dynamic",
    "else",
    "enum",
    "export",
    "extends",
    "extension",
    "external",
    "factory",
    "false",
    "final",
    "finally",
    "for",
    "Function",
    "get",
    "hide",
    "if",
    "implements",
    "import",
    "in",
    "interface",
    "is",
    "late",
    "library",
    "mixin",
    "new",
    "null",
    "on",
    "operator",
    "part",
    "required",
    "rethrow",
    "return",
    "sealed",
    "set",
    "show",
    "static",
    "super",
    "switch",
    "sync",
    "this",
    "throw",
    "true",
    "try",
    "typedef",
    "var",
    "void",
    "when",
    "while",
    "with",
    "yield"
  ];
  const KEYWORDS2 = {
    keyword: BASIC_KEYWORDS,
    built_in: BUILT_IN_TYPES.concat(NULLABLE_BUILT_IN_TYPES).concat([
      "Never",
      "Null",
      "dynamic",
      "print",
      "document",
      "querySelector",
      "querySelectorAll",
      "window"
    ]),
    $pattern: /[A-Za-z][A-Za-z0-9_]*\??/
  };
  return {
    name: "Dart",
    keywords: KEYWORDS2,
    contains: [
      STRING,
      hljs.COMMENT(
        /\/\*\*(?!\/)/,
        /\*\//,
        {
          subLanguage: "markdown",
          relevance: 0
        }
      ),
      hljs.COMMENT(
        /\/{3,} ?/,
        /$/,
        { contains: [
          {
            subLanguage: "markdown",
            begin: ".",
            end: "$",
            relevance: 0
          }
        ] }
      ),
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      {
        className: "class",
        beginKeywords: "class interface",
        end: /\{/,
        excludeEnd: true,
        contains: [
          { beginKeywords: "extends implements" },
          hljs.UNDERSCORE_TITLE_MODE
        ]
      },
      hljs.C_NUMBER_MODE,
      {
        className: "meta",
        begin: "@[A-Za-z]+"
      },
      {
        begin: "=>"
      }
    ]
  };
}
function nginx(hljs) {
  const regex = hljs.regex;
  const VAR = {
    className: "variable",
    variants: [
      { begin: /\$\d+/ },
      { begin: /\$\{\w+\}/ },
      { begin: regex.concat(/[$@]/, hljs.UNDERSCORE_IDENT_RE) }
    ]
  };
  const LITERALS2 = [
    "on",
    "off",
    "yes",
    "no",
    "true",
    "false",
    "none",
    "blocked",
    "debug",
    "info",
    "notice",
    "warn",
    "error",
    "crit",
    "select",
    "break",
    "last",
    "permanent",
    "redirect",
    "kqueue",
    "rtsig",
    "epoll",
    "poll",
    "/dev/poll"
  ];
  const DEFAULT = {
    endsWithParent: true,
    keywords: {
      $pattern: /[a-z_]{2,}|\/dev\/poll/,
      literal: LITERALS2
    },
    relevance: 0,
    illegal: "=>",
    contains: [
      hljs.HASH_COMMENT_MODE,
      {
        className: "string",
        contains: [
          hljs.BACKSLASH_ESCAPE,
          VAR
        ],
        variants: [
          {
            begin: /"/,
            end: /"/
          },
          {
            begin: /'/,
            end: /'/
          }
        ]
      },
      {
        begin: "([a-z]+):/",
        end: "\\s",
        endsWithParent: true,
        excludeEnd: true,
        contains: [VAR]
      },
      {
        className: "regexp",
        contains: [
          hljs.BACKSLASH_ESCAPE,
          VAR
        ],
        variants: [
          {
            begin: "\\s\\^",
            end: "\\s|\\{|;",
            returnEnd: true
          },
          {
            begin: "~\\*?\\s+",
            end: "\\s|\\{|;",
            returnEnd: true
          },
          { begin: "\\*(\\.[a-z\\-]+)+" },
          { begin: "([a-z\\-]+\\.)+\\*" }
        ]
      },
      {
        className: "number",
        begin: "\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}(:\\d{1,5})?\\b"
      },
      {
        className: "number",
        begin: "\\b\\d+[kKmMgGdshdwy]?\\b",
        relevance: 0
      },
      VAR
    ]
  };
  return {
    name: "Nginx config",
    aliases: ["nginxconf"],
    contains: [
      hljs.HASH_COMMENT_MODE,
      {
        beginKeywords: "upstream location",
        end: /;|\{/,
        contains: DEFAULT.contains,
        keywords: { section: "upstream location" }
      },
      {
        className: "section",
        begin: regex.concat(hljs.UNDERSCORE_IDENT_RE + regex.lookahead(/\s+\{/)),
        relevance: 0
      },
      {
        begin: regex.lookahead(hljs.UNDERSCORE_IDENT_RE + "\\s"),
        end: ";|\\{",
        contains: [
          {
            className: "attribute",
            begin: hljs.UNDERSCORE_IDENT_RE,
            starts: DEFAULT
          }
        ],
        relevance: 0
      }
    ],
    illegal: "[^\\s\\}\\{]"
  };
}
function php(hljs) {
  const regex = hljs.regex;
  const NOT_PERL_ETC = /(?![A-Za-z0-9])(?![$])/;
  const IDENT_RE2 = regex.concat(
    /[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/,
    NOT_PERL_ETC
  );
  const PASCAL_CASE_CLASS_NAME_RE = regex.concat(
    /(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,
    NOT_PERL_ETC
  );
  const VARIABLE = {
    scope: "variable",
    match: "\\$+" + IDENT_RE2
  };
  const PREPROCESSOR = {
    scope: "meta",
    variants: [
      { begin: /<\?php/, relevance: 10 },
      { begin: /<\?=/ },
      { begin: /<\?/, relevance: 0.1 },
      { begin: /\?>/ }
    ]
  };
  const SUBST = {
    scope: "subst",
    variants: [
      { begin: /\$\w+/ },
      {
        begin: /\{\$/,
        end: /\}/
      }
    ]
  };
  const SINGLE_QUOTED = hljs.inherit(hljs.APOS_STRING_MODE, { illegal: null });
  const DOUBLE_QUOTED = hljs.inherit(hljs.QUOTE_STRING_MODE, {
    illegal: null,
    contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST)
  });
  const HEREDOC = {
    begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
    end: /[ \t]*(\w+)\b/,
    contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST),
    "on:begin": (m, resp) => {
      resp.data._beginMatch = m[1] || m[2];
    },
    "on:end": (m, resp) => {
      if (resp.data._beginMatch !== m[1])
        resp.ignoreMatch();
    }
  };
  const NOWDOC = hljs.END_SAME_AS_BEGIN({
    begin: /<<<[ \t]*'(\w+)'\n/,
    end: /[ \t]*(\w+)\b/
  });
  const WHITESPACE = "[ 	\n]";
  const STRING = {
    scope: "string",
    variants: [
      DOUBLE_QUOTED,
      SINGLE_QUOTED,
      HEREDOC,
      NOWDOC
    ]
  };
  const NUMBER = {
    scope: "number",
    variants: [
      { begin: `\\b0[bB][01]+(?:_[01]+)*\\b` },
      { begin: `\\b0[oO][0-7]+(?:_[0-7]+)*\\b` },
      { begin: `\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b` },
      { begin: `(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?` }
    ],
    relevance: 0
  };
  const LITERALS2 = [
    "false",
    "null",
    "true"
  ];
  const KWS = [
    "__CLASS__",
    "__DIR__",
    "__FILE__",
    "__FUNCTION__",
    "__COMPILER_HALT_OFFSET__",
    "__LINE__",
    "__METHOD__",
    "__NAMESPACE__",
    "__TRAIT__",
    "die",
    "echo",
    "exit",
    "include",
    "include_once",
    "print",
    "require",
    "require_once",
    "array",
    "abstract",
    "and",
    "as",
    "binary",
    "bool",
    "boolean",
    "break",
    "callable",
    "case",
    "catch",
    "class",
    "clone",
    "const",
    "continue",
    "declare",
    "default",
    "do",
    "double",
    "else",
    "elseif",
    "empty",
    "enddeclare",
    "endfor",
    "endforeach",
    "endif",
    "endswitch",
    "endwhile",
    "enum",
    "eval",
    "extends",
    "final",
    "finally",
    "float",
    "for",
    "foreach",
    "from",
    "global",
    "goto",
    "if",
    "implements",
    "instanceof",
    "insteadof",
    "int",
    "integer",
    "interface",
    "isset",
    "iterable",
    "list",
    "match|0",
    "mixed",
    "new",
    "never",
    "object",
    "or",
    "private",
    "protected",
    "public",
    "readonly",
    "real",
    "return",
    "string",
    "switch",
    "throw",
    "trait",
    "try",
    "unset",
    "use",
    "var",
    "void",
    "while",
    "xor",
    "yield"
  ];
  const BUILT_INS2 = [
    "Error|0",
    "AppendIterator",
    "ArgumentCountError",
    "ArithmeticError",
    "ArrayIterator",
    "ArrayObject",
    "AssertionError",
    "BadFunctionCallException",
    "BadMethodCallException",
    "CachingIterator",
    "CallbackFilterIterator",
    "CompileError",
    "Countable",
    "DirectoryIterator",
    "DivisionByZeroError",
    "DomainException",
    "EmptyIterator",
    "ErrorException",
    "Exception",
    "FilesystemIterator",
    "FilterIterator",
    "GlobIterator",
    "InfiniteIterator",
    "InvalidArgumentException",
    "IteratorIterator",
    "LengthException",
    "LimitIterator",
    "LogicException",
    "MultipleIterator",
    "NoRewindIterator",
    "OutOfBoundsException",
    "OutOfRangeException",
    "OuterIterator",
    "OverflowException",
    "ParentIterator",
    "ParseError",
    "RangeException",
    "RecursiveArrayIterator",
    "RecursiveCachingIterator",
    "RecursiveCallbackFilterIterator",
    "RecursiveDirectoryIterator",
    "RecursiveFilterIterator",
    "RecursiveIterator",
    "RecursiveIteratorIterator",
    "RecursiveRegexIterator",
    "RecursiveTreeIterator",
    "RegexIterator",
    "RuntimeException",
    "SeekableIterator",
    "SplDoublyLinkedList",
    "SplFileInfo",
    "SplFileObject",
    "SplFixedArray",
    "SplHeap",
    "SplMaxHeap",
    "SplMinHeap",
    "SplObjectStorage",
    "SplObserver",
    "SplPriorityQueue",
    "SplQueue",
    "SplStack",
    "SplSubject",
    "SplTempFileObject",
    "TypeError",
    "UnderflowException",
    "UnexpectedValueException",
    "UnhandledMatchError",
    "ArrayAccess",
    "BackedEnum",
    "Closure",
    "Fiber",
    "Generator",
    "Iterator",
    "IteratorAggregate",
    "Serializable",
    "Stringable",
    "Throwable",
    "Traversable",
    "UnitEnum",
    "WeakReference",
    "WeakMap",
    "Directory",
    "__PHP_Incomplete_Class",
    "parent",
    "php_user_filter",
    "self",
    "static",
    "stdClass"
  ];
  const dualCase = (items) => {
    const result = [];
    items.forEach((item) => {
      result.push(item);
      if (item.toLowerCase() === item) {
        result.push(item.toUpperCase());
      } else {
        result.push(item.toLowerCase());
      }
    });
    return result;
  };
  const KEYWORDS2 = {
    keyword: KWS,
    literal: dualCase(LITERALS2),
    built_in: BUILT_INS2
  };
  const normalizeKeywords = (items) => {
    return items.map((item) => {
      return item.replace(/\|\d+$/, "");
    });
  };
  const CONSTRUCTOR_CALL = { variants: [
    {
      match: [
        /new/,
        regex.concat(WHITESPACE, "+"),
        regex.concat("(?!", normalizeKeywords(BUILT_INS2).join("\\b|"), "\\b)"),
        PASCAL_CASE_CLASS_NAME_RE
      ],
      scope: {
        1: "keyword",
        4: "title.class"
      }
    }
  ] };
  const CONSTANT_REFERENCE = regex.concat(IDENT_RE2, "\\b(?!\\()");
  const LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON = { variants: [
    {
      match: [
        regex.concat(
          /::/,
          regex.lookahead(/(?!class\b)/)
        ),
        CONSTANT_REFERENCE
      ],
      scope: { 2: "variable.constant" }
    },
    {
      match: [
        /::/,
        /class/
      ],
      scope: { 2: "variable.language" }
    },
    {
      match: [
        PASCAL_CASE_CLASS_NAME_RE,
        regex.concat(
          /::/,
          regex.lookahead(/(?!class\b)/)
        ),
        CONSTANT_REFERENCE
      ],
      scope: {
        1: "title.class",
        3: "variable.constant"
      }
    },
    {
      match: [
        PASCAL_CASE_CLASS_NAME_RE,
        regex.concat(
          "::",
          regex.lookahead(/(?!class\b)/)
        )
      ],
      scope: { 1: "title.class" }
    },
    {
      match: [
        PASCAL_CASE_CLASS_NAME_RE,
        /::/,
        /class/
      ],
      scope: {
        1: "title.class",
        3: "variable.language"
      }
    }
  ] };
  const NAMED_ARGUMENT = {
    scope: "attr",
    match: regex.concat(IDENT_RE2, regex.lookahead(":"), regex.lookahead(/(?!::)/))
  };
  const PARAMS_MODE = {
    relevance: 0,
    begin: /\(/,
    end: /\)/,
    keywords: KEYWORDS2,
    contains: [
      NAMED_ARGUMENT,
      VARIABLE,
      LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
      hljs.C_BLOCK_COMMENT_MODE,
      STRING,
      NUMBER,
      CONSTRUCTOR_CALL
    ]
  };
  const FUNCTION_INVOKE = {
    relevance: 0,
    match: [
      /\b/,
      regex.concat("(?!fn\\b|function\\b|", normalizeKeywords(KWS).join("\\b|"), "|", normalizeKeywords(BUILT_INS2).join("\\b|"), "\\b)"),
      IDENT_RE2,
      regex.concat(WHITESPACE, "*"),
      regex.lookahead(/(?=\()/)
    ],
    scope: { 3: "title.function.invoke" },
    contains: [PARAMS_MODE]
  };
  PARAMS_MODE.contains.push(FUNCTION_INVOKE);
  const ATTRIBUTE_CONTAINS = [
    NAMED_ARGUMENT,
    LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
    hljs.C_BLOCK_COMMENT_MODE,
    STRING,
    NUMBER,
    CONSTRUCTOR_CALL
  ];
  const ATTRIBUTES2 = {
    begin: regex.concat(/#\[\s*/, PASCAL_CASE_CLASS_NAME_RE),
    beginScope: "meta",
    end: /]/,
    endScope: "meta",
    keywords: {
      literal: LITERALS2,
      keyword: [
        "new",
        "array"
      ]
    },
    contains: [
      {
        begin: /\[/,
        end: /]/,
        keywords: {
          literal: LITERALS2,
          keyword: [
            "new",
            "array"
          ]
        },
        contains: [
          "self",
          ...ATTRIBUTE_CONTAINS
        ]
      },
      ...ATTRIBUTE_CONTAINS,
      {
        scope: "meta",
        match: PASCAL_CASE_CLASS_NAME_RE
      }
    ]
  };
  return {
    case_insensitive: false,
    keywords: KEYWORDS2,
    contains: [
      ATTRIBUTES2,
      hljs.HASH_COMMENT_MODE,
      hljs.COMMENT("//", "$"),
      hljs.COMMENT(
        "/\\*",
        "\\*/",
        { contains: [
          {
            scope: "doctag",
            match: "@[A-Za-z]+"
          }
        ] }
      ),
      {
        match: /__halt_compiler\(\);/,
        keywords: "__halt_compiler",
        starts: {
          scope: "comment",
          end: hljs.MATCH_NOTHING_RE,
          contains: [
            {
              match: /\?>/,
              scope: "meta",
              endsParent: true
            }
          ]
        }
      },
      PREPROCESSOR,
      {
        scope: "variable.language",
        match: /\$this\b/
      },
      VARIABLE,
      FUNCTION_INVOKE,
      LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
      {
        match: [
          /const/,
          /\s/,
          IDENT_RE2
        ],
        scope: {
          1: "keyword",
          3: "variable.constant"
        }
      },
      CONSTRUCTOR_CALL,
      {
        scope: "function",
        relevance: 0,
        beginKeywords: "fn function",
        end: /[;{]/,
        excludeEnd: true,
        illegal: "[$%\\[]",
        contains: [
          { beginKeywords: "use" },
          hljs.UNDERSCORE_TITLE_MODE,
          {
            begin: "=>",
            endsParent: true
          },
          {
            scope: "params",
            begin: "\\(",
            end: "\\)",
            excludeBegin: true,
            excludeEnd: true,
            keywords: KEYWORDS2,
            contains: [
              "self",
              VARIABLE,
              LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
              hljs.C_BLOCK_COMMENT_MODE,
              STRING,
              NUMBER
            ]
          }
        ]
      },
      {
        scope: "class",
        variants: [
          {
            beginKeywords: "enum",
            illegal: /[($"]/
          },
          {
            beginKeywords: "class interface trait",
            illegal: /[:($"]/
          }
        ],
        relevance: 0,
        end: /\{/,
        excludeEnd: true,
        contains: [
          { beginKeywords: "extends implements" },
          hljs.UNDERSCORE_TITLE_MODE
        ]
      },
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: ";",
        illegal: /[.']/,
        contains: [hljs.inherit(hljs.UNDERSCORE_TITLE_MODE, { scope: "title.class" })]
      },
      {
        beginKeywords: "use",
        relevance: 0,
        end: ";",
        contains: [
          {
            match: /\b(as|const|function)\b/,
            scope: "keyword"
          },
          hljs.UNDERSCORE_TITLE_MODE
        ]
      },
      STRING,
      NUMBER
    ]
  };
}
function python(hljs) {
  const regex = hljs.regex;
  const IDENT_RE2 = /[\p{XID_Start}_]\p{XID_Continue}*/u;
  const RESERVED_WORDS = [
    "and",
    "as",
    "assert",
    "async",
    "await",
    "break",
    "case",
    "class",
    "continue",
    "def",
    "del",
    "elif",
    "else",
    "except",
    "finally",
    "for",
    "from",
    "global",
    "if",
    "import",
    "in",
    "is",
    "lambda",
    "match",
    "nonlocal|10",
    "not",
    "or",
    "pass",
    "raise",
    "return",
    "try",
    "while",
    "with",
    "yield"
  ];
  const BUILT_INS2 = [
    "__import__",
    "abs",
    "all",
    "any",
    "ascii",
    "bin",
    "bool",
    "breakpoint",
    "bytearray",
    "bytes",
    "callable",
    "chr",
    "classmethod",
    "compile",
    "complex",
    "delattr",
    "dict",
    "dir",
    "divmod",
    "enumerate",
    "eval",
    "exec",
    "filter",
    "float",
    "format",
    "frozenset",
    "getattr",
    "globals",
    "hasattr",
    "hash",
    "help",
    "hex",
    "id",
    "input",
    "int",
    "isinstance",
    "issubclass",
    "iter",
    "len",
    "list",
    "locals",
    "map",
    "max",
    "memoryview",
    "min",
    "next",
    "object",
    "oct",
    "open",
    "ord",
    "pow",
    "print",
    "property",
    "range",
    "repr",
    "reversed",
    "round",
    "set",
    "setattr",
    "slice",
    "sorted",
    "staticmethod",
    "str",
    "sum",
    "super",
    "tuple",
    "type",
    "vars",
    "zip"
  ];
  const LITERALS2 = [
    "__debug__",
    "Ellipsis",
    "False",
    "None",
    "NotImplemented",
    "True"
  ];
  const TYPES2 = [
    "Any",
    "Callable",
    "Coroutine",
    "Dict",
    "List",
    "Literal",
    "Generic",
    "Optional",
    "Sequence",
    "Set",
    "Tuple",
    "Type",
    "Union"
  ];
  const KEYWORDS2 = {
    $pattern: /[A-Za-z]\w+|__\w+__/,
    keyword: RESERVED_WORDS,
    built_in: BUILT_INS2,
    literal: LITERALS2,
    type: TYPES2
  };
  const PROMPT = {
    className: "meta",
    begin: /^(>>>|\.\.\.) /
  };
  const SUBST = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: KEYWORDS2,
    illegal: /#/
  };
  const LITERAL_BRACKET = {
    begin: /\{\{/,
    relevance: 0
  };
  const STRING = {
    className: "string",
    contains: [hljs.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
        end: /'''/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          PROMPT
        ],
        relevance: 10
      },
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
        end: /"""/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          PROMPT
        ],
        relevance: 10
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'''/,
        end: /'''/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          PROMPT,
          LITERAL_BRACKET,
          SUBST
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"""/,
        end: /"""/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          PROMPT,
          LITERAL_BRACKET,
          SUBST
        ]
      },
      {
        begin: /([uU]|[rR])'/,
        end: /'/,
        relevance: 10
      },
      {
        begin: /([uU]|[rR])"/,
        end: /"/,
        relevance: 10
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])'/,
        end: /'/
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])"/,
        end: /"/
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'/,
        end: /'/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          LITERAL_BRACKET,
          SUBST
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"/,
        end: /"/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          LITERAL_BRACKET,
          SUBST
        ]
      },
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE
    ]
  };
  const digitpart = "[0-9](_?[0-9])*";
  const pointfloat = `(\\b(${digitpart}))?\\.(${digitpart})|\\b(${digitpart})\\.`;
  const lookahead2 = `\\b|${RESERVED_WORDS.join("|")}`;
  const NUMBER = {
    className: "number",
    relevance: 0,
    variants: [
      {
        begin: `(\\b(${digitpart})|(${pointfloat}))[eE][+-]?(${digitpart})[jJ]?(?=${lookahead2})`
      },
      {
        begin: `(${pointfloat})[jJ]?`
      },
      {
        begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${lookahead2})`
      },
      {
        begin: `\\b0[bB](_?[01])+[lL]?(?=${lookahead2})`
      },
      {
        begin: `\\b0[oO](_?[0-7])+[lL]?(?=${lookahead2})`
      },
      {
        begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${lookahead2})`
      },
      {
        begin: `\\b(${digitpart})[jJ](?=${lookahead2})`
      }
    ]
  };
  const COMMENT_TYPE = {
    className: "comment",
    begin: regex.lookahead(/# type:/),
    end: /$/,
    keywords: KEYWORDS2,
    contains: [
      {
        begin: /# type:/
      },
      {
        begin: /#/,
        end: /\b\B/,
        endsWithParent: true
      }
    ]
  };
  const PARAMS = {
    className: "params",
    variants: [
      {
        className: "",
        begin: /\(\s*\)/,
        skip: true
      },
      {
        begin: /\(/,
        end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: KEYWORDS2,
        contains: [
          "self",
          PROMPT,
          NUMBER,
          STRING,
          hljs.HASH_COMMENT_MODE
        ]
      }
    ]
  };
  SUBST.contains = [
    STRING,
    NUMBER,
    PROMPT
  ];
  return {
    name: "Python",
    aliases: [
      "py",
      "gyp",
      "ipython"
    ],
    unicodeRegex: true,
    keywords: KEYWORDS2,
    illegal: /(<\/|\?)|=>/,
    contains: [
      PROMPT,
      NUMBER,
      {
        begin: /\bself\b/
      },
      {
        beginKeywords: "if",
        relevance: 0
      },
      STRING,
      COMMENT_TYPE,
      hljs.HASH_COMMENT_MODE,
      {
        match: [
          /\bdef/,
          /\s+/,
          IDENT_RE2
        ],
        scope: {
          1: "keyword",
          3: "title.function"
        },
        contains: [PARAMS]
      },
      {
        variants: [
          {
            match: [
              /\bclass/,
              /\s+/,
              IDENT_RE2,
              /\s*/,
              /\(\s*/,
              IDENT_RE2,
              /\s*\)/
            ]
          },
          {
            match: [
              /\bclass/,
              /\s+/,
              IDENT_RE2
            ]
          }
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          6: "title.class.inherited"
        }
      },
      {
        className: "meta",
        begin: /^[\t ]*@/,
        end: /(?=#)|$/,
        contains: [
          NUMBER,
          PARAMS,
          STRING
        ]
      }
    ]
  };
}
const mviHljs = "";
HighlightJS.registerLanguage("plaintext", plaintext);
HighlightJS.registerLanguage("javascript", javascript$1);
HighlightJS.registerLanguage("java", java);
HighlightJS.registerLanguage("typescript", typescript);
HighlightJS.registerLanguage("html", xml);
HighlightJS.registerLanguage("markdown", markdown);
HighlightJS.registerLanguage("css", css);
HighlightJS.registerLanguage("less", less);
HighlightJS.registerLanguage("scss", scss);
HighlightJS.registerLanguage("objectivec", objectivec);
HighlightJS.registerLanguage("swift", swift);
HighlightJS.registerLanguage("dart", dart);
HighlightJS.registerLanguage("nginx", nginx);
HighlightJS.registerLanguage("php", php);
HighlightJS.registerLanguage("python", python);
HighlightJS.configure({
  cssSelector: "pre",
  classPrefix: "mvi-hljs-",
  ignoreUnescapedHTML: true
});
const getHljsHtml = function(code, language) {
  if (language) {
    return HighlightJS.highlight(code, {
      language,
      ignoreIllegals: true
    }).value;
  }
  return HighlightJS.highlightAuto(code).value;
};
const languages = ["plaintext", "javascript", "html", "css", "less", "scss", "java", "markdown", "swift", "objectivec", "typescript", "dart", "nginx", "php", "python"];
const editor_vue_vue_type_style_index_0_scoped_671aac24_lang = "";
const _sfc_main$7 = {
  name: "m-editor",
  emits: ["update:modelValue", "focus", "blur", "change", "paste-image", "paste-video", "range-update", "after-render", "keydown"],
  props: {
    modelValue: {
      type: String,
      default: "<p><br></p>"
    },
    autofocus: {
      type: Boolean,
      default: false
    },
    placeholder: {
      type: String,
      default: ""
    },
    height: {
      type: String,
      default: "8rem"
    },
    autoheight: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    border: {
      type: Boolean,
      default: false
    },
    activeColor: {
      type: String,
      default: "#0b73de",
      validator(value) {
        return obj$1.common.matchingText(value, "hex");
      }
    },
    htmlPaste: {
      type: Boolean,
      default: false
    },
    customImagePaste: {
      type: Boolean,
      default: false
    },
    customVideoPaste: {
      type: Boolean,
      default: false
    },
    renderRules: {
      type: Array,
      default: function() {
        return [];
      }
    },
    highlight: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      codeViewShow: false,
      isTable: false,
      isPre: false,
      isLink: false,
      editor: null,
      compositionFlag: false,
      isModelChange: false,
      useMenus: false,
      canUseMenus: false,
      linkAdjusterProps: {
        show: false,
        target: "",
        newWindow: false,
        url: "",
        element: null,
        props: {
          placeholder: "\u8F93\u5165\u5730\u5740",
          targetText: "\u65B0\u7A97\u53E3\u6253\u5F00",
          removeText: "\u79FB\u9664\u94FE\u63A5",
          insertText: "\u63D2\u5165"
        }
      },
      mediaAdjusterProps: {
        show: false,
        target: "",
        element: null
      },
      tableAdjusterProps: {
        show: false,
        target: "",
        element: null,
        props: {
          insertRowText: "\u63D2\u5165\u884C",
          removeRowText: "\u5220\u9664\u884C",
          insertColumnText: "\u63D2\u5165\u5217",
          removeColumnText: "\u5220\u9664\u5217"
        }
      },
      preAdjusterProps: {
        show: false,
        target: "",
        element: null,
        languages: [
          {
            label: "\u81EA\u52A8\u8BC6\u522B",
            value: ""
          },
          ...languages
        ],
        language: ""
      },
      tableColumnResizeParams: {
        element: null,
        start: 0
      }
    };
  },
  setup() {
    const instance = getCurrentInstance();
    return {
      uid: instance.uid
    };
  },
  components: {
    Icon,
    Checkbox
  },
  computed: {
    cmpValue: {
      set(val) {
        this.$emit("update:modelValue", val);
      },
      get() {
        return this.modelValue || "<p><br></p>";
      }
    },
    contentStyle() {
      let style = {};
      if (this.autoheight) {
        style.minHeight = this.height;
      } else {
        style.height = this.height;
      }
      return style;
    },
    isEmpty() {
      return this.cmpValue == "<p><br></p>" && !this.compositionFlag;
    }
  },
  watch: {
    disabled(newVal) {
      if (newVal) {
        this.editor.setDisabled();
      } else {
        this.editor.setEnabled();
      }
    },
    cmpValue(newVal) {
      if (this.codeViewShow) {
        return;
      }
      if (this.isModelChange) {
        return;
      }
      this.editor.stack = this.editor.parseHtml(newVal);
      this.editor.formatElementStack();
      this.editor.range.anchor.moveToStart(this.editor.stack[0]);
      this.editor.range.focus.moveToStart(this.editor.stack[0]);
      this.editor.domRender();
      this.editor.rangeRender();
    }
  },
  mounted() {
    this.editor = new AlexEditor(this.$refs.content, {
      disabled: this.disabled,
      value: this.cmpValue,
      renderRules: [this.orderListHandle, this.codeHandle, this.mediaHandle, this.tableHandle, this.preHandle, ...this.renderRules],
      htmlPaste: this.htmlPaste
    });
    this.internalModify(this.editor.value);
    this.editor.on("change", this.handleContentChange);
    this.editor.on("focus", this.handleContentFocus);
    this.editor.on("blur", this.handleContentBlur);
    this.editor.on("insertParagraph", this.handleInsertParagraph);
    this.editor.on("deleteInStart", this.handleDelete);
    this.editor.on("rangeUpdate", this.handleRangeUpdate);
    this.editor.on("afterRender", this.handleAfterRender);
    this.editor.on("pasteHtml", this.handlePasteHtml);
    if (this.customImagePaste) {
      this.editor.on("pasteImage", (url) => {
        this.$emit("paste-image", url);
      });
    }
    if (this.customVideoPaste) {
      this.editor.on("pasteVideo", (url) => {
        this.$emit("paste-video", url);
      });
    }
    this.onScroll();
    this.editor.formatElementStack();
    this.editor.domRender();
    if (this.autofocus && !this.codeViewShow && !this.disabled) {
      this.collapseToEnd();
    }
    obj$1.event.on(document.documentElement, `mousedown.editor_${this.uid}`, this.documentMouseDown);
    obj$1.event.on(document.documentElement, `mousemove.editor_${this.uid}`, this.documentMouseMove);
    obj$1.event.on(document.documentElement, `mouseup.editor_${this.uid}`, this.documentMouseUp);
  },
  methods: {
    documentMouseDown(e) {
      if (this.disabled) {
        return;
      }
      const elm = e.target;
      const key = obj$1.data.get(elm, "data-alex-editor-key");
      if (key) {
        const element2 = this.editor.getElementByKey(key);
        if (element2.parsedom == "td") {
          const length = element2.parent.children.length;
          if (element2.parent.children[length - 1].isEqual(element2)) {
            return;
          }
          const rect = obj$1.element.getElementBounding(elm);
          if (Math.abs(rect.left + elm.offsetWidth - e.pageX) < obj$1.element.rem2px(0.2)) {
            this.tableColumnResizeParams.element = element2;
            this.tableColumnResizeParams.start = e.pageX;
          }
        }
      }
    },
    documentMouseMove(e) {
      if (this.disabled) {
        return;
      }
      if (!this.tableColumnResizeParams.element) {
        return;
      }
      const table = this.getCurrentParsedomElement("table");
      if (!table) {
        return;
      }
      const colgroup = table.children.find((item) => {
        return item.parsedom == "colgroup";
      });
      const index = this.tableColumnResizeParams.element.parent.children.findIndex((el) => {
        return el.isEqual(this.tableColumnResizeParams.element);
      });
      const width = `${this.tableColumnResizeParams.element._elm.offsetWidth + e.pageX - this.tableColumnResizeParams.start}`;
      colgroup.children[index].marks["width"] = width;
      colgroup.children[index]._elm.setAttribute("width", width);
      this.tableColumnResizeParams.start = e.pageX;
    },
    documentMouseUp(e) {
      if (this.disabled) {
        return;
      }
      if (!this.tableColumnResizeParams.element) {
        return;
      }
      const table = this.getCurrentParsedomElement("table");
      if (!table) {
        return;
      }
      const colgroup = table.children.find((item) => {
        return item.parsedom == "colgroup";
      });
      const index = this.tableColumnResizeParams.element.parent.children.findIndex((el) => {
        return el.isEqual(this.tableColumnResizeParams.element);
      });
      const width = Number(colgroup.children[index].marks["width"]);
      if (!isNaN(width)) {
        colgroup.children[index].marks["width"] = `${Number((width / this.tableColumnResizeParams.element.parent._elm.offsetWidth * 100).toFixed(2))}%`;
        this.editor.formatElementStack();
        this.editor.domRender();
        this.editor.rangeRender();
      }
      this.tableColumnResizeParams.element = null;
      this.tableColumnResizeParams.start = 0;
    },
    contentKeyDown(e) {
      if (e.keyCode == 9 && !e.metaKey && !e.shiftKey && !e.ctrlKey && !e.altKey) {
        e.preventDefault();
        this.setIndent();
      } else if (e.keyCode == 9 && !e.metaKey && e.shiftKey && !e.ctrlKey && !e.altKey) {
        e.preventDefault();
        this.setOutdent();
      } else {
        this.$emit("keydown", e);
      }
    },
    inputFocus(event2) {
      event2.currentTarget.style.borderColor = this.activeColor;
    },
    inputBlur(event2) {
      event2.currentTarget.style.borderColor = "";
    },
    autoLayerOffset(refName) {
      let b1 = obj$1.element.getElementBounding(this.$el);
      let b2 = obj$1.element.getElementBounding(this.$refs[refName].$el);
      if (b1.top >= b2.top || b1.bottom >= b2.bottom) {
        this.$refs[refName].$el.style.bottom = b1.bottom + "px";
        this.$refs[refName].$el.style.top = "auto";
      } else {
        this.$refs[refName].reset();
      }
      b1 = obj$1.element.getElementBounding(this.$el);
      b2 = obj$1.element.getElementBounding(this.$refs[refName].$el);
      if (b1.top >= b2.top || b1.bottom >= b2.bottom) {
        this.$refs[refName].$el.style.bottom = b1.bottom + "px";
        this.$refs[refName].$el.style.top = "auto";
      }
    },
    onScroll() {
      const setScroll = (el) => {
        obj$1.event.on(el, `scroll.editor_${this.uid}`, (e) => {
          this.linkAdjusterProps.show = false;
          this.mediaAdjusterProps.show = false;
          this.tableAdjusterProps.show = false;
          this.preAdjusterProps.show = false;
        });
        if (el.parentNode) {
          setScroll(el.parentNode);
        }
      };
      setScroll(this.$refs.content);
    },
    removeScroll() {
      const removeScroll = (el) => {
        obj$1.event.off(el, `scroll.editor_${this.uid}`);
        if (el.parentNode) {
          removeScroll(el.parentNode);
        }
      };
      removeScroll(this.$refs.content);
    },
    internalModify(val) {
      this.isModelChange = true;
      this.cmpValue = val;
      this.$nextTick(() => {
        this.isModelChange = false;
      });
    },
    orderListHandle(element2) {
      if (element2.parsedom == "ol" || element2.parsedom == "ul") {
        if (element2.hasChildren()) {
          element2.children.forEach((el, index) => {
            const newEl = el.clone();
            newEl.parsedom = "div";
            newEl.type = "block";
            if (!newEl.hasMarks()) {
              newEl.marks = {};
            }
            newEl.marks["data-list"] = element2.parsedom;
            if (element2.parsedom == "ol") {
              newEl.marks["data-value"] = index + 1;
            }
            this.editor.addElementAfter(newEl, element2);
          });
        }
        element2.toEmpty();
      }
      if (element2.type == "block" && element2.hasMarks() && element2.marks["data-list"] == "ol") {
        const previousElement = this.editor.getPreviousElement(element2);
        if (previousElement && previousElement.hasMarks() && previousElement.marks["data-list"] == "ol") {
          const previousValue = Number(previousElement.marks["data-value"]);
          element2.marks["data-value"] = previousValue + 1;
        } else {
          element2.marks["data-value"] = 1;
        }
      }
    },
    mediaHandle(element2) {
      if (element2.parsedom == "img") {
        const marks = {
          "mvi-editor-element-key": element2.key
        };
        if (element2.hasMarks()) {
          Object.assign(element2.marks, marks);
        } else {
          element2.marks = marks;
        }
      }
      if (element2.parsedom == "video") {
        const marks = {
          controls: true,
          autoplay: true,
          muted: true,
          "mvi-editor-element-key": element2.key
        };
        if (element2.hasMarks()) {
          Object.assign(element2.marks, marks);
        } else {
          element2.marks = marks;
        }
      }
      if (element2.parsedom == "a") {
        const marks = {
          "mvi-editor-element-key": element2.key
        };
        if (element2.hasMarks()) {
          Object.assign(element2.marks, marks);
        } else {
          element2.marks = marks;
        }
      }
    },
    codeHandle(element2) {
      if (element2.parsedom == "code") {
        element2.parsedom = "span";
        const marks = {
          "data-code-style": true
        };
        if (element2.hasMarks()) {
          Object.assign(element2.marks, marks);
        } else {
          element2.marks = marks;
        }
      }
    },
    tableHandle(element2) {
      if (element2.parsedom == "table") {
        const marks = {
          "mvi-editor-element-key": element2.key
        };
        if (element2.hasMarks()) {
          Object.assign(element2.marks, marks);
        } else {
          element2.marks = marks;
        }
        const elements = AlexElement.flatElements(element2.children);
        const rows = elements.filter((el) => {
          return el.parsedom == "tr";
        });
        let colgroup = elements.find((el) => {
          return el.parsedom == "colgroup";
        });
        if (colgroup) {
          colgroup.children.forEach((col) => {
            if (!col.hasMarks()) {
              col.marks = {
                width: "auto"
              };
            } else if (!col.marks["width"]) {
              col.marks["width"] = "auto";
            }
          });
        } else {
          colgroup = new AlexElement("inblock", "colgroup", null, null, null);
          for (let i = rows[0].children.length - 1; i >= 0; i--) {
            const col = new AlexElement(
              "closed",
              "col",
              {
                width: "auto"
              },
              null,
              null
            );
            this.editor.addElementTo(col, colgroup);
          }
        }
        element2.children = [];
        const tbody = new AlexElement("inblock", "tbody", null, null, null);
        rows.reverse().forEach((row) => {
          this.editor.addElementTo(row, tbody);
        });
        this.editor.addElementTo(tbody, element2);
        this.editor.addElementTo(colgroup, element2);
      } else if (element2.parsedom == "th") {
        element2.parsedom = "td";
      }
    },
    preHandle(element2) {
      if ((element2.isBlock() || element2.isInblock()) && element2.isPreStyle()) {
        const marks = {
          "mvi-editor-element-key": element2.key
        };
        if (element2.hasMarks()) {
          Object.assign(element2.marks, marks);
        } else {
          element2.marks = marks;
        }
        if (this.highlight && element2.hasChildren()) {
          let language = element2.marks["mvi-hljs-language"] || "";
          if (language && !this.preAdjusterProps.languages.includes(language)) {
            language = "";
          }
          const originalTextElements = AlexElement.flatElements(element2.children).filter((el) => el.isText() && !el.isEmpty());
          const textContent = originalTextElements.reduce((val, item) => {
            return val + item.textContent;
          }, "");
          const html = getHljsHtml(textContent, language);
          if (html) {
            const newElements = this.editor.parseHtml(html);
            this.updateRangeInPre(element2, originalTextElements, newElements);
            element2.children = newElements;
            newElements.forEach((newEl) => {
              newEl.parent = element2;
            });
          }
        }
      }
    },
    clickEditor(e) {
      if (this.disabled) {
        return;
      }
      const node = e.target;
      e.preventDefault();
      if (node.nodeName.toLocaleLowerCase() == "img" || node.nodeName.toLocaleLowerCase() == "video") {
        const key = node.getAttribute("mvi-editor-element-key");
        const element2 = this.editor.getElementByKey(key);
        this.editor.range.anchor.moveToStart(element2);
        this.editor.range.focus.moveToEnd(element2);
        this.editor.rangeRender();
      }
    },
    handleContentChange(newVal, oldVal) {
      if (this.disabled) {
        return;
      }
      this.internalModify(newVal);
      this.$emit("change", newVal, oldVal);
    },
    handleContentFocus(val) {
      if (this.disabled) {
        return;
      }
      if (this.border && this.activeColor) {
        this.$refs.content.style.borderColor = this.activeColor;
        const rgb = obj$1.color.hex2rgb(this.activeColor);
        this.$refs.content.style.boxShadow = `0 0 0.16rem rgba(${rgb[0]},${rgb[1]},${rgb[2]},0.5)`;
      }
      setTimeout(() => {
        this.canUseMenus = true;
      }, 0);
      this.$emit("focus", val);
    },
    handleContentBlur(val) {
      if (this.disabled) {
        return;
      }
      if (this.border && this.activeColor) {
        this.$refs.content.style.borderColor = "";
        this.$refs.content.style.boxShadow = "";
      }
      this.$emit("blur", val);
    },
    handleInsertParagraph(element2, previousElement) {
      if (previousElement.isOnlyHasBreak() && element2.isOnlyHasBreak()) {
        if (!previousElement.isBlock()) {
          previousElement.convertToBlock();
        }
        if (previousElement.parsedom != AlexElement.BLOCK_NODE) {
          elementUtil.toParagraph(previousElement);
          this.editor.range.anchor.moveToStart(previousElement);
          this.editor.range.focus.moveToStart(previousElement);
          element2.toEmpty();
        }
      }
    },
    handleDelete(element2) {
      if (element2.isBlock()) {
        elementUtil.toParagraph(element2);
      }
    },
    handleRangeUpdate(range) {
      if (this.disabled) {
        return;
      }
      this.$emit("range-update", range);
      const img = this.getCurrentParsedomElement("img");
      const link = this.getCurrentParsedomElement("a");
      const video = this.getCurrentParsedomElement("video");
      const table = this.getCurrentParsedomElement("table");
      const pre = this.getCurrentParsedomElement("pre");
      this.isTable = !!table;
      this.isPre = !!pre;
      this.isLink = !!link;
      setTimeout(() => {
        if (img || video) {
          const el = img || video;
          this.mediaAdjusterProps.target = `[mvi-editor-element-key='${el.key}']`;
          this.mediaAdjusterProps.element = el;
          this.mediaAdjusterProps.show = true;
          this.linkAdjusterProps.show = false;
          this.tableAdjusterProps.show = false;
          this.preAdjusterProps.show = false;
        } else if (link) {
          this.linkAdjusterProps.target = `[mvi-editor-element-key='${link.key}']`;
          this.linkAdjusterProps.url = link.marks["href"];
          this.linkAdjusterProps.newWindow = link.marks["target"] == "_blank";
          this.linkAdjusterProps.element = link;
          this.linkAdjusterProps.show = true;
          this.mediaAdjusterProps.show = false;
          this.tableAdjusterProps.show = false;
          this.preAdjusterProps.show = false;
        } else if (table) {
          this.tableAdjusterProps.target = `[mvi-editor-element-key='${table.key}']`;
          this.tableAdjusterProps.element = table;
          this.tableAdjusterProps.show = true;
          this.mediaAdjusterProps.show = false;
          this.linkAdjusterProps.show = false;
          this.preAdjusterProps.show = false;
        } else if (pre) {
          this.preAdjusterProps.target = `[mvi-editor-element-key='${pre.key}']`;
          this.preAdjusterProps.language = pre.marks["mvi-hljs-language"] || "";
          this.preAdjusterProps.element = pre;
          this.preAdjusterProps.show = true;
          this.mediaAdjusterProps.show = false;
          this.linkAdjusterProps.show = false;
          this.tableAdjusterProps.show = false;
        } else {
          this.tableAdjusterProps.show = false;
          this.mediaAdjusterProps.show = false;
          this.linkAdjusterProps.show = false;
          this.preAdjusterProps.show = false;
        }
      }, 100);
    },
    handleAfterRender() {
      if (this.preAdjusterProps.show) {
        this.autoLayerOffset("preLayer");
      }
      this.$emit("after-render");
    },
    handlePasteHtml(data2, elements) {
      AlexElement.flatElements(elements).forEach((el) => {
        if (["table", "tr", "th", "td", "tbody", "br", "blockquote", "ol", "ul", "li", "pre", "code", "label", "hr", "colgroup"].includes(el.parsedom)) {
          el.marks = null;
          if (el.isBlock() || el.isInblock()) {
            if (el.hasStyles()) {
              let styles = {};
              for (let key in el.styles) {
                if (["text-indent", "text-align"].includes(key)) {
                  styles[key] = el.styles[key];
                }
              }
              el.styles = styles;
            }
          } else {
            el.styles = null;
          }
        }
      });
    },
    deleteLink() {
      if (this.disabled) {
        return;
      }
      const element2 = this.linkAdjusterProps.element;
      element2.parsedom = AlexElement.TEXT_NODE;
      delete element2.marks.target;
      delete element2.marks.href;
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
      this.linkAdjusterProps.show = false;
    },
    updateLink() {
      if (this.disabled) {
        return;
      }
      if (!this.linkAdjusterProps.url) {
        return;
      }
      const element2 = this.linkAdjusterProps.element;
      element2.marks.href = this.linkAdjusterProps.url;
      if (this.linkAdjusterProps.newWindow) {
        element2.marks.target = "_blank";
      } else {
        delete element2.marks.target;
      }
      this.editor.formatElementStack();
      this.editor.domRender();
    },
    setMediaWidth(value) {
      if (this.disabled) {
        return;
      }
      const element2 = this.mediaAdjusterProps.element;
      const styles = {
        width: value
      };
      if (element2.hasStyles()) {
        Object.assign(element2.styles, styles);
      } else {
        element2.styles = styles;
      }
      this.editor.range.anchor.moveToEnd(element2);
      this.editor.range.focus.moveToEnd(element2);
      this.editor.domRender();
      this.editor.rangeRender();
      this.mediaAdjusterProps.show = false;
    },
    deleteMedia() {
      if (this.disabled) {
        return;
      }
      this.editor.delete();
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
      this.mediaAdjusterProps.show = false;
    },
    insertParagraphToTable(type) {
      if (this.disabled) {
        return;
      }
      if (!this.editor.range.anchor.isEqual(this.editor.range.focus)) {
        this.editor.range.anchor.element = this.editor.range.focus.element;
        this.editor.range.anchor.offset = this.editor.range.focus.offset;
      }
      const table = this.tableAdjusterProps.element;
      const paragraph = new AlexElement("block", AlexElement.BLOCK_NODE, null, null, null);
      const breakEl = new AlexElement("closed", "br", null, null, null);
      this.editor.addElementTo(breakEl, paragraph);
      if (type == "up") {
        this.editor.addElementBefore(paragraph, table);
      } else {
        this.editor.addElementAfter(paragraph, table);
      }
      this.editor.range.anchor.moveToEnd(paragraph);
      this.editor.range.focus.moveToEnd(paragraph);
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    addTableRow() {
      if (this.disabled) {
        return;
      }
      if (!this.editor.range.anchor.isEqual(this.editor.range.focus)) {
        this.editor.range.anchor.element = this.editor.range.focus.element;
        this.editor.range.anchor.offset = this.editor.range.focus.offset;
      }
      const row = this.getCurrentParsedomElement("tr");
      if (row) {
        const newRow = row.clone();
        newRow.children.forEach((column) => {
          column.children = [];
          const breakEl = new AlexElement("closed", "br", null, null, null);
          this.editor.addElementTo(breakEl, column);
        });
        this.editor.addElementAfter(newRow, row);
        this.editor.formatElementStack();
        this.editor.range.anchor.moveToStart(newRow);
        this.editor.range.focus.moveToStart(newRow);
        this.editor.domRender();
        this.editor.rangeRender();
        this.autoLayerOffset("tableLayer");
      }
    },
    removeTableRow() {
      if (this.disabled) {
        return;
      }
      if (!this.editor.range.anchor.isEqual(this.editor.range.focus)) {
        this.editor.range.anchor.element = this.editor.range.focus.element;
        this.editor.range.anchor.offset = this.editor.range.focus.offset;
      }
      const row = this.getCurrentParsedomElement("tr");
      if (row) {
        const parent = row.parent;
        if (parent.children.length == 1) {
          this.deleteTable();
          return;
        }
        const previousRow = this.editor.getPreviousElement(row);
        const nextRow = this.editor.getNextElement(row);
        row.toEmpty();
        this.editor.formatElementStack();
        if (previousRow) {
          this.editor.range.anchor.moveToEnd(previousRow.children[0]);
          this.editor.range.focus.moveToEnd(previousRow.children[0]);
        } else {
          this.editor.range.anchor.moveToEnd(nextRow.children[0]);
          this.editor.range.focus.moveToEnd(nextRow.children[0]);
        }
        this.editor.domRender();
        this.editor.rangeRender();
        this.autoLayerOffset("tableLayer");
      }
    },
    addTableColumn() {
      if (this.disabled) {
        return;
      }
      if (!this.editor.range.anchor.isEqual(this.editor.range.focus)) {
        this.editor.range.anchor.element = this.editor.range.focus.element;
        this.editor.range.anchor.offset = this.editor.range.focus.offset;
      }
      const column = this.getCurrentParsedomElement("td");
      const tbody = this.getCurrentParsedomElement("tbody");
      const table = this.getCurrentParsedomElement("table");
      if (column && table && tbody) {
        const rows = tbody.children;
        const index = column.parent.children.findIndex((item) => {
          return item.isEqual(column);
        });
        rows.forEach((row) => {
          const newColumn = column.clone(false);
          const breakEl = new AlexElement("closed", "br", null, null, null);
          this.editor.addElementTo(breakEl, newColumn);
          this.editor.addElementTo(newColumn, row, index + 1);
        });
        const colgroup = table.children.find((item) => {
          return item.parsedom == "colgroup";
        });
        const col = new AlexElement("closed", "col", null, null, null);
        this.editor.addElementTo(col, colgroup, index + 1);
        this.editor.formatElementStack();
        const nextColumn = this.editor.getNextElement(column);
        this.editor.range.anchor.moveToStart(nextColumn);
        this.editor.range.focus.moveToStart(nextColumn);
        this.editor.domRender();
        this.editor.rangeRender();
      }
    },
    removeTableColumn() {
      if (this.disabled) {
        return;
      }
      if (!this.editor.range.anchor.isEqual(this.editor.range.focus)) {
        this.editor.range.anchor.element = this.editor.range.focus.element;
        this.editor.range.anchor.offset = this.editor.range.focus.offset;
      }
      const column = this.getCurrentParsedomElement("td");
      const tbody = this.getCurrentParsedomElement("tbody");
      const table = this.getCurrentParsedomElement("table");
      if (column && table && tbody) {
        const rows = tbody.children;
        const parent = column.parent;
        if (parent.children.length == 1) {
          this.deleteTable();
          return;
        }
        const previousColumn = this.editor.getPreviousElement(column);
        const nextColumn = this.editor.getNextElement(column);
        const index = column.parent.children.findIndex((item) => {
          return item.isEqual(column);
        });
        rows.forEach((row) => {
          row.children[index].toEmpty();
        });
        const colgroup = table.children.find((item) => {
          return item.parsedom == "colgroup";
        });
        colgroup.children[index].toEmpty();
        this.editor.formatElementStack();
        if (previousColumn) {
          this.editor.range.anchor.moveToEnd(previousColumn);
          this.editor.range.focus.moveToEnd(previousColumn);
        } else {
          this.editor.range.anchor.moveToEnd(nextColumn);
          this.editor.range.focus.moveToEnd(nextColumn);
        }
        this.editor.domRender();
        this.editor.rangeRender();
      }
    },
    deleteTable() {
      if (this.disabled) {
        return;
      }
      if (!this.editor.range.anchor.isEqual(this.editor.range.focus)) {
        this.editor.range.anchor.element = this.editor.range.focus.element;
        this.editor.range.anchor.offset = this.editor.range.focus.offset;
      }
      const table = this.tableAdjusterProps.element;
      table.toEmpty();
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    insertParagraphToPre(type) {
      if (this.disabled) {
        return;
      }
      if (!this.editor.range.anchor.isEqual(this.editor.range.focus)) {
        this.editor.range.anchor.element = this.editor.range.focus.element;
        this.editor.range.anchor.offset = this.editor.range.focus.offset;
      }
      const pre = this.preAdjusterProps.element;
      const paragraph = new AlexElement("block", AlexElement.BLOCK_NODE, null, null, null);
      const breakEl = new AlexElement("closed", "br", null, null, null);
      this.editor.addElementTo(breakEl, paragraph);
      if (type == "up") {
        this.editor.addElementBefore(paragraph, pre);
      } else {
        this.editor.addElementAfter(paragraph, pre);
      }
      this.editor.range.anchor.moveToEnd(paragraph);
      this.editor.range.focus.moveToEnd(paragraph);
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    selectLanguage(data2) {
      if (this.disabled) {
        return;
      }
      const element2 = this.preAdjusterProps.element;
      Object.assign(element2.marks, {
        "mvi-hljs-language": data2.value
      });
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    updateRangeInPre(element2, originalTextElements, newElements) {
      if (this.editor.range.anchor.element.getBlock().isEqual(element2)) {
        const elIndex = originalTextElements.findIndex((el) => this.editor.range.anchor.element.isEqual(el));
        const offset = originalTextElements.filter((el, i2) => i2 < elIndex).reduce((total, item, i2) => total + item.textContent.length, 0) + this.editor.range.anchor.offset;
        const newTextElements = AlexElement.flatElements(newElements).filter((el) => el.isText() && !el.isEmpty());
        let i = 0;
        let index = 0;
        while (i < newTextElements.length) {
          let newIndex = index + newTextElements[i].textContent.length;
          if (offset >= index && offset <= newIndex) {
            this.editor.range.anchor.element = newTextElements[i];
            this.editor.range.anchor.offset = offset - index;
            break;
          }
          i++;
          index = newIndex;
        }
      }
      if (this.editor.range.focus.element.getBlock().isEqual(element2)) {
        const elIndex = originalTextElements.findIndex((el) => this.editor.range.focus.element.isEqual(el));
        const offset = originalTextElements.filter((el, i2) => i2 < elIndex).reduce((total, item, i2) => total + item.textContent.length, 0) + this.editor.range.focus.offset;
        const newTextElements = AlexElement.flatElements(newElements).filter((el) => el.isText() && !el.isEmpty());
        let i = 0;
        let index = 0;
        while (i < newTextElements.length) {
          let newIndex = index + newTextElements[i].textContent.length;
          if (offset >= index && offset <= newIndex) {
            this.editor.range.focus.element = newTextElements[i];
            this.editor.range.focus.offset = offset - index;
            break;
          }
          i++;
          index = newIndex;
        }
      }
    },
    use(menus) {
      if (this.useMenus) {
        throw new Error("The editor has already used a menu bar and cannot be used repeatedly");
      }
      menus.instance = this;
      this.useMenus = true;
    },
    getCurrentParsedomElement(parsedom) {
      const fn = (element2) => {
        if (element2.isBlock()) {
          return element2.parsedom == parsedom ? element2 : null;
        }
        if (!element2.isText() && element2.parsedom == parsedom) {
          return element2;
        }
        return fn(element2.parent);
      };
      if (this.editor.range.anchor.element.isEqual(this.editor.range.focus.element)) {
        return fn(this.editor.range.anchor.element);
      }
      const arr = this.editor.getElementsByRange(true, false).map((item) => {
        return fn(item.element);
      });
      let hasNull = arr.some((el) => {
        return el == null;
      });
      if (hasNull) {
        return null;
      }
      if (arr.length == 1) {
        return arr[0];
      }
      let flag = true;
      for (let i = 1; i < arr.length; i++) {
        if (!arr[i].isEqual(arr[0])) {
          flag = false;
          break;
        }
      }
      if (flag) {
        return arr[0];
      }
      return null;
    },
    collapseToEnd() {
      if (this.disabled) {
        return;
      }
      this.editor.collapseToEnd();
      this.editor.rangeRender();
      obj$1.element.setScrollTop({
        el: this.$refs.content,
        number: 1e6,
        time: 0
      });
    },
    collapseToStart() {
      if (this.disabled) {
        return;
      }
      this.editor.collapseToStart();
      this.editor.rangeRender();
      this.$nextTick(() => {
        obj$1.element.setScrollTop({
          el: this.$refs.content,
          number: 0,
          time: 0
        });
      });
    },
    insertImage(url) {
      const image = new AlexElement(
        "closed",
        "img",
        {
          src: url
        },
        null,
        null
      );
      this.editor.insertElement(image);
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    insertVideo(url) {
      const video = new AlexElement(
        "closed",
        "video",
        {
          src: url
        },
        null,
        null
      );
      this.editor.insertElement(video);
      const leftSpace = AlexElement.getSpaceElement();
      const rightSpace = AlexElement.getSpaceElement();
      this.editor.addElementAfter(rightSpace, video);
      this.editor.addElementBefore(leftSpace, video);
      this.editor.range.anchor.moveToEnd(rightSpace);
      this.editor.range.focus.moveToEnd(rightSpace);
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    insertHtml(html) {
      if (!html) {
        return;
      }
      const elements = this.editor.parseHtml(html);
      elements.reverse().forEach((el, index) => {
        if (index == 0) {
          this.editor.insertElement(el);
        } else {
          this.editor.addElementBefore(el, elements[0]);
        }
      });
      this.editor.range.anchor.moveToEnd(elements[elements.length - 1]);
      this.editor.range.focus.moveToEnd(elements[elements.length - 1]);
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    insertText(text) {
      if (!text) {
        return;
      }
      this.editor.insertText(text);
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    undo() {
      const historyRecord = this.editor.history.get(-1);
      if (historyRecord) {
        this.editor.stack = historyRecord.stack;
        this.editor.range = historyRecord.range;
        this.editor.formatElementStack();
        this.editor.domRender(true);
        this.editor.rangeRender();
      }
    },
    redo() {
      const historyRecord = this.editor.history.get(1);
      if (historyRecord) {
        this.editor.stack = historyRecord.stack;
        this.editor.range = historyRecord.range;
        this.editor.formatElementStack();
        this.editor.domRender(true);
        this.editor.rangeRender();
      }
    },
    removeFormat() {
      this.editor.removeTextStyle();
      this.editor.removeTextMark();
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    setIndent() {
      const fn = (element2) => {
        if (element2.hasStyles()) {
          if (element2.styles.hasOwnProperty("text-indent")) {
            let val = element2.styles["text-indent"];
            if (val.endsWith("em")) {
              val = parseFloat(val);
            } else {
              val = 0;
            }
            element2.styles["text-indent"] = `${val + 2}em`;
          } else {
            element2.styles["text-indent"] = "2em";
          }
        } else {
          element2.styles = {
            "text-indent": "2em"
          };
        }
      };
      if (this.editor.range.anchor.isEqual(this.editor.range.focus)) {
        const block2 = this.editor.range.anchor.element.getBlock();
        const inblock2 = this.editor.range.anchor.element.getInblock();
        if (inblock2) {
          if (inblock2.isPreStyle()) {
            this.editor.insertText("    ");
          } else if (inblock2.behavior == "block") {
            fn(inblock2);
          }
        } else {
          if (block2.isPreStyle()) {
            this.editor.insertText("    ");
          } else {
            fn(block2);
          }
        }
      } else {
        const result = this.editor.getElementsByRange(true, false);
        result.forEach((item) => {
          const block2 = item.element.getBlock();
          const inblock2 = item.element.getInblock();
          if (inblock2 && inblock2.behavior == "block") {
            fn(inblock2);
          } else {
            fn(block2);
          }
        });
      }
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    setOutdent() {
      const fn = (element2) => {
        if (element2.hasStyles() && element2.styles.hasOwnProperty("text-indent")) {
          let val = element2.styles["text-indent"];
          if (val.endsWith("em")) {
            val = parseFloat(val);
          } else {
            val = 0;
          }
          element2.styles["text-indent"] = `${val - 2 >= 0 ? val - 2 : 0}em`;
        }
      };
      if (this.editor.range.anchor.isEqual(this.editor.range.focus)) {
        const block2 = this.editor.range.anchor.element.getBlock();
        const inblock2 = this.editor.range.anchor.element.getInblock();
        if (inblock2 && inblock2.behavior == "block" && !inblock2.isPreStyle()) {
          fn(inblock2);
        } else if (!block2.isPreStyle()) {
          fn(block2);
        }
      } else {
        const result = this.getElementsByRange(true, false);
        result.forEach((item) => {
          const block2 = item.element.getBlock();
          const inblock2 = item.element.getInblock();
          if (inblock2 && inblock2.behavior == "block") {
            fn(inblock2);
          } else {
            fn(block2);
          }
        });
      }
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    insertDivider() {
      const paragraph = new AlexElement("block", AlexElement.BLOCK_NODE, null, null, null);
      const divider = new AlexElement("closed", "hr", null, null, null);
      this.editor.addElementTo(divider, paragraph);
      this.editor.insertElement(paragraph);
      const nextParagraph = new AlexElement("block", AlexElement.BLOCK_NODE, null, null, null);
      const breakEl = new AlexElement("closed", "br", null, null, null);
      this.editor.addElementTo(breakEl, nextParagraph);
      this.editor.addElementAfter(nextParagraph, paragraph);
      this.editor.range.anchor.moveToEnd(nextParagraph);
      this.editor.range.focus.moveToEnd(nextParagraph);
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    setCodeStyle() {
      const active = this.editor.queryTextMark("data-code-style");
      if (active) {
        this.editor.removeTextMark(["data-code-style"]);
      } else {
        this.editor.setTextMark({
          "data-code-style": "mvi-editor-code"
        });
      }
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    setBold() {
      const active = this.editor.queryTextStyle("font-weight", "bold");
      if (active) {
        this.editor.removeTextStyle(["font-weight"]);
      } else {
        this.editor.setTextStyle({
          "font-weight": "bold"
        });
      }
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    setItalic() {
      const active = this.editor.queryTextStyle("font-style", "italic");
      if (active) {
        this.editor.removeTextStyle(["font-style"]);
      } else {
        this.editor.setTextStyle({
          "font-style": "italic"
        });
      }
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    setUnderline() {
      const active = this.editor.queryTextStyle("text-decoration-line", "underline") || this.editor.queryTextStyle("text-decoration", "underline");
      if (active) {
        this.editor.removeTextStyle(["text-decoration-line", "text-decoration"]);
      } else {
        this.editor.setTextStyle({
          "text-decoration-line": "underline"
        });
      }
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    setStrikeThrough() {
      const active = this.editor.queryTextStyle("text-decoration-line", "line-through") || this.editor.queryTextStyle("text-decoration", "line-through");
      if (active) {
        this.editor.removeTextStyle(["text-decoration-line", "text-decoration"]);
      } else {
        this.editor.setTextStyle({
          "text-decoration-line": "line-through"
        });
      }
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    setSub() {
      const active = this.editor.queryTextStyle("vertical-align", "sub");
      if (active) {
        this.editor.removeTextStyle(["vertical-align"]);
      } else {
        this.editor.setTextStyle({
          "vertical-align": "sub"
        });
      }
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    setSuper() {
      const active = this.editor.queryTextStyle("vertical-align", "super");
      if (active) {
        this.editor.removeTextStyle(["vertical-align"]);
      } else {
        this.editor.setTextStyle({
          "vertical-align": "super"
        });
      }
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    setTitle(value) {
      if (this.editor.range.anchor.isEqual(this.editor.range.focus)) {
        const block2 = this.editor.range.anchor.element.getBlock();
        elementUtil.toParagraph(block2);
        block2.parsedom = value;
      } else {
        const result = this.editor.getElementsByRange(true, false);
        result.forEach((el) => {
          if (el.element.isBlock()) {
            elementUtil.toParagraph(el.element);
            el.element.parsedom = value;
          } else {
            const block2 = el.element.getBlock();
            elementUtil.toParagraph(block2);
            block2.parsedom = value;
          }
        });
      }
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    setFontFamily(value) {
      this.editor.setTextStyle({
        "font-family": value
      });
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    setFontSize(value) {
      this.editor.setTextStyle({
        "font-size": value
      });
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    setForeColor(value) {
      this.editor.setTextStyle({
        color: value
      });
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    setBackColor(value) {
      this.editor.setTextStyle({
        "background-color": value
      });
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    setList(ordered) {
      if (this.editor.range.anchor.isEqual(this.editor.range.focus)) {
        const block2 = this.editor.range.anchor.element.getBlock();
        const isList = elementUtil.isList(block2, ordered);
        elementUtil.toParagraph(block2);
        if (!isList) {
          elementUtil.toList(block2, ordered);
        }
      } else {
        const result = this.editor.getElementsByRange(true, false);
        result.forEach((item) => {
          if (item.element.isBlock()) {
            const isList = elementUtil.isList(item.element, ordered);
            elementUtil.toParagraph(item.element);
            if (!isList) {
              elementUtil.toList(item.element, ordered);
            }
          } else {
            const block2 = item.element.getBlock();
            const isList = elementUtil.isList(block2, ordered);
            elementUtil.toParagraph(block2);
            if (!isList) {
              elementUtil.toList(block2, ordered);
            }
          }
        });
      }
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    setJustify(value) {
      if (this.editor.range.anchor.isEqual(this.editor.range.focus)) {
        const block2 = this.editor.range.anchor.element.getBlock();
        const inblock2 = this.editor.range.anchor.element.getInblock();
        if (inblock2) {
          if (inblock2.hasStyles()) {
            inblock2.styles["text-align"] = value;
          } else {
            inblock2.styles = {
              "text-align": value
            };
          }
        } else {
          if (block2.hasStyles()) {
            block2.styles["text-align"] = value;
          } else {
            block2.styles = {
              "text-align": value
            };
          }
        }
      } else {
        const result = this.editor.getElementsByRange(true, false);
        result.forEach((el) => {
          if (el.element.isBlock() || el.element.isInblock()) {
            if (el.element.hasStyles()) {
              el.element.styles["text-align"] = value;
            } else {
              el.element.styles = {
                "text-align": value
              };
            }
          } else {
            const block2 = el.element.getBlock();
            const inblock2 = el.element.getInblock();
            if (inblock2) {
              if (inblock2.hasStyles()) {
                inblock2.styles["text-align"] = value;
              } else {
                inblock2.styles = {
                  "text-align": value
                };
              }
            } else {
              if (block2.hasStyles()) {
                block2.styles["text-align"] = value;
              } else {
                block2.styles = {
                  "text-align": value
                };
              }
            }
          }
        });
      }
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    setQuote() {
      if (this.editor.range.anchor.isEqual(this.editor.range.focus)) {
        const block2 = this.editor.range.anchor.element.getBlock();
        const oldParsedom = block2.parsedom;
        elementUtil.toParagraph(block2);
        if (oldParsedom != "blockquote") {
          block2.parsedom = "blockquote";
        }
      } else {
        const result = this.editor.getElementsByRange(true, false);
        result.forEach((el) => {
          if (el.element.isBlock()) {
            const oldParsedom = el.element.parsedom;
            elementUtil.toParagraph(el.element);
            if (oldParsedom != "blockquote") {
              el.element.parsedom = "blockquote";
            }
          } else {
            const block2 = el.element.getBlock();
            const oldParsedom = block2.parsedom;
            elementUtil.toParagraph(block2);
            if (oldParsedom != "blockquote") {
              block2.parsedom = "blockquote";
            }
          }
        });
      }
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    },
    setCodeBlock() {
      const pre = this.getCurrentParsedomElement("pre");
      if (pre) {
        elementUtil.toParagraph(pre);
      } else {
        if (this.editor.range.anchor.isEqual(this.editor.range.focus)) {
          const block2 = this.editor.range.anchor.element.getBlock();
          elementUtil.toParagraph(block2);
          block2.parsedom = "pre";
          const paragraph = new AlexElement("block", AlexElement.BLOCK_NODE, null, null, null);
          const breakEl = new AlexElement("closed", "br", null, null, null);
          this.editor.addElementTo(breakEl, paragraph);
          this.editor.addElementAfter(paragraph, block2);
        } else {
          let result = this.editor.getElementsByRange(true, false);
          this.editor.range.anchor.moveToStart(result[0].element.getBlock());
          this.editor.range.focus.moveToEnd(result[result.length - 1].element.getBlock());
          const res = this.editor.getElementsByRange(true, true).filter((el) => el.element.isText());
          const obj2 = {};
          res.forEach((el) => {
            if (obj2[el.element.getBlock().key]) {
              obj2[el.element.getBlock().key].push(el.element.clone());
            } else {
              obj2[el.element.getBlock().key] = [el.element.clone()];
            }
          });
          const pre2 = new AlexElement("block", "pre", null, null, null);
          Object.keys(obj2).forEach((key, index) => {
            if (index > 0) {
              const text = new AlexElement("text", null, null, null, "\n");
              if (pre2.hasChildren()) {
                this.editor.addElementTo(text, pre2, pre2.children.length);
              } else {
                this.editor.addElementTo(text, pre2);
              }
            }
            obj2[key].forEach((el) => {
              if (pre2.hasChildren()) {
                this.editor.addElementTo(el, pre2, pre2.children.length);
              } else {
                this.editor.addElementTo(el, pre2);
              }
            });
          });
          this.editor.delete();
          this.editor.insertElement(pre2);
          const paragraph = new AlexElement("block", AlexElement.BLOCK_NODE, null, null, null);
          const breakEl = new AlexElement("closed", "br", null, null, null);
          this.editor.addElementTo(breakEl, paragraph);
          this.editor.addElementAfter(paragraph, pre2);
        }
      }
      this.editor.formatElementStack();
      this.editor.domRender();
      this.editor.rangeRender();
    }
  },
  beforeUnmount() {
    this.removeScroll();
    obj$1.event.off(document.documentElement, `mousedown.editor_${this.uid} mousemove.editor_${this.uid} mouseup.editor_${this.uid}`);
  }
};
const _hoisted_1$2 = { class: "mvi-editor" };
const _hoisted_2$2 = ["value"];
const _hoisted_3$1 = ["data-placeholder", "disabled"];
const _hoisted_4$1 = { class: "mvi-editor-layer-link" };
const _hoisted_5$1 = ["placeholder"];
const _hoisted_6$1 = { class: "mvi-editor-layer-link-footer" };
const _hoisted_7$1 = { class: "mvi-editor-layer" };
const _hoisted_8$1 = { class: "mvi-editor-layer" };
const _hoisted_9$1 = { class: "mvi-editor-layer" };
const _hoisted_10$1 = {
  key: 0,
  class: "mvi-editor-layer-item"
};
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Checkbox = resolveComponent("Checkbox");
  const _component_m_layer = resolveComponent("m-layer");
  const _component_Icon = resolveComponent("Icon");
  const _component_m_select = resolveComponent("m-select");
  return openBlock(), createElementBlock("div", _hoisted_1$2, [
    $data.codeViewShow ? (openBlock(), createElementBlock("textarea", {
      key: 0,
      ref: "code",
      readonly: "",
      class: "mvi-editor-code",
      value: $options.cmpValue
    }, null, 8, _hoisted_2$2)) : createCommentVNode("", true),
    createElementVNode("div", {
      ref: "content",
      "data-placeholder": $props.placeholder,
      class: normalizeClass(["mvi-editor-content", $props.border ? "border" : "", $options.isEmpty ? "empty" : ""]),
      style: normalizeStyle($options.contentStyle),
      onCompositionstart: _cache[0] || (_cache[0] = ($event) => $data.compositionFlag = true),
      onCompositionend: _cache[1] || (_cache[1] = ($event) => $data.compositionFlag = false),
      onClick: _cache[2] || (_cache[2] = (...args) => $options.clickEditor && $options.clickEditor(...args)),
      disabled: $props.disabled || null,
      onKeydown: _cache[3] || (_cache[3] = (...args) => $options.contentKeyDown && $options.contentKeyDown(...args))
    }, null, 46, _hoisted_3$1),
    createVNode(_component_m_layer, {
      modelValue: $data.linkAdjusterProps.show,
      "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => $data.linkAdjusterProps.show = $event),
      fixed: "",
      target: $data.linkAdjusterProps.target,
      placement: "bottom-start",
      animation: "mvi-editor-layer-animation",
      timeout: 50,
      border: "",
      background: "#fff",
      "border-color": "#eee",
      offset: "0.05rem",
      closable: "",
      ref: "linkLayer",
      onShowing: _cache[11] || (_cache[11] = ($event) => $options.autoLayerOffset("linkLayer"))
    }, {
      default: withCtx(() => [
        createElementVNode("div", _hoisted_4$1, [
          withDirectives(createElementVNode("input", {
            onChange: _cache[4] || (_cache[4] = (...args) => $options.updateLink && $options.updateLink(...args)),
            ref: "linkUrl",
            onFocus: _cache[5] || (_cache[5] = (...args) => $options.inputFocus && $options.inputFocus(...args)),
            onBlur: _cache[6] || (_cache[6] = (...args) => $options.inputBlur && $options.inputBlur(...args)),
            "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => $data.linkAdjusterProps.url = $event),
            placeholder: $data.linkAdjusterProps.props.placeholder,
            type: "text"
          }, null, 40, _hoisted_5$1), [
            [
              vModelText,
              $data.linkAdjusterProps.url,
              void 0,
              { trim: true }
            ]
          ]),
          createElementVNode("div", _hoisted_6$1, [
            createVNode(_component_Checkbox, {
              onChange: $options.updateLink,
              label: $data.linkAdjusterProps.props.targetText,
              placement: "right",
              size: "0.24rem",
              color: $props.activeColor,
              modelValue: $data.linkAdjusterProps.newWindow,
              "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => $data.linkAdjusterProps.newWindow = $event)
            }, null, 8, ["onChange", "label", "color", "modelValue"]),
            createElementVNode("span", {
              class: "mvi-editor-layer-link-delete",
              onClick: _cache[9] || (_cache[9] = (...args) => $options.deleteLink && $options.deleteLink(...args))
            }, toDisplayString($data.linkAdjusterProps.props.removeText), 1)
          ])
        ])
      ]),
      _: 1
    }, 8, ["modelValue", "target"]),
    createVNode(_component_m_layer, {
      modelValue: $data.mediaAdjusterProps.show,
      "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => $data.mediaAdjusterProps.show = $event),
      fixed: "",
      target: $data.mediaAdjusterProps.target,
      placement: "bottom-start",
      animation: "mvi-editor-layer-animation",
      timeout: 50,
      border: "",
      background: "#fff",
      "border-color": "#eee",
      offset: "0.05rem",
      closable: "",
      ref: "mediaLayer",
      onShowing: _cache[17] || (_cache[17] = ($event) => $options.autoLayerOffset("mediaLayer"))
    }, {
      default: withCtx(() => [
        createElementVNode("div", _hoisted_7$1, [
          createElementVNode("div", {
            onClick: _cache[12] || (_cache[12] = ($event) => $options.setMediaWidth("20%")),
            class: "mvi-editor-layer-item"
          }, "20%"),
          createElementVNode("div", {
            onClick: _cache[13] || (_cache[13] = ($event) => $options.setMediaWidth("50%")),
            class: "mvi-editor-layer-item"
          }, "50%"),
          createElementVNode("div", {
            onClick: _cache[14] || (_cache[14] = ($event) => $options.setMediaWidth("100%")),
            class: "mvi-editor-layer-item"
          }, "100%"),
          createElementVNode("div", {
            onClick: _cache[15] || (_cache[15] = (...args) => $options.deleteMedia && $options.deleteMedia(...args)),
            class: "mvi-editor-layer-item"
          }, [
            createVNode(_component_Icon, { type: "trash-alt" })
          ])
        ])
      ]),
      _: 1
    }, 8, ["modelValue", "target"]),
    createVNode(_component_m_layer, {
      modelValue: $data.tableAdjusterProps.show,
      "onUpdate:modelValue": _cache[25] || (_cache[25] = ($event) => $data.tableAdjusterProps.show = $event),
      fixed: "",
      target: $data.tableAdjusterProps.target,
      placement: "bottom-start",
      animation: "mvi-editor-layer-animation",
      timeout: 50,
      border: "",
      background: "#fff",
      "border-color": "#eee",
      offset: "0.05rem",
      closable: "",
      ref: "tableLayer",
      onShowing: _cache[26] || (_cache[26] = ($event) => $options.autoLayerOffset("tableLayer"))
    }, {
      default: withCtx(() => [
        createElementVNode("div", _hoisted_8$1, [
          createElementVNode("div", {
            onClick: _cache[18] || (_cache[18] = ($event) => $options.insertParagraphToTable("up")),
            class: "mvi-editor-layer-item"
          }, [
            createVNode(_component_Icon, {
              style: { "transform": "rotate(180deg)" },
              type: "turn-arrow-text"
            })
          ]),
          createElementVNode("div", {
            onClick: _cache[19] || (_cache[19] = ($event) => $options.insertParagraphToTable("down")),
            class: "mvi-editor-layer-item"
          }, [
            createVNode(_component_Icon, { type: "turn-arrow-text" })
          ]),
          createElementVNode("div", {
            onClick: _cache[20] || (_cache[20] = (...args) => $options.addTableRow && $options.addTableRow(...args)),
            style: normalizeStyle({ color: $props.activeColor }),
            class: "mvi-editor-layer-item"
          }, toDisplayString($data.tableAdjusterProps.props.insertRowText), 5),
          createElementVNode("div", {
            onClick: _cache[21] || (_cache[21] = (...args) => $options.removeTableRow && $options.removeTableRow(...args)),
            class: "mvi-editor-layer-item"
          }, toDisplayString($data.tableAdjusterProps.props.removeRowText), 1),
          createElementVNode("div", {
            onClick: _cache[22] || (_cache[22] = (...args) => $options.addTableColumn && $options.addTableColumn(...args)),
            style: normalizeStyle({ color: $props.activeColor }),
            class: "mvi-editor-layer-item"
          }, toDisplayString($data.tableAdjusterProps.props.insertColumnText), 5),
          createElementVNode("div", {
            onClick: _cache[23] || (_cache[23] = (...args) => $options.removeTableColumn && $options.removeTableColumn(...args)),
            class: "mvi-editor-layer-item"
          }, toDisplayString($data.tableAdjusterProps.props.removeColumnText), 1),
          createElementVNode("div", {
            onClick: _cache[24] || (_cache[24] = (...args) => $options.deleteTable && $options.deleteTable(...args)),
            class: "mvi-editor-layer-item"
          }, [
            createVNode(_component_Icon, { type: "trash-alt" })
          ])
        ])
      ]),
      _: 1
    }, 8, ["modelValue", "target"]),
    createVNode(_component_m_layer, {
      modelValue: $data.preAdjusterProps.show,
      "onUpdate:modelValue": _cache[30] || (_cache[30] = ($event) => $data.preAdjusterProps.show = $event),
      fixed: "",
      target: $data.preAdjusterProps.target,
      placement: "bottom-start",
      animation: "mvi-editor-layer-animation",
      timeout: 50,
      border: "",
      background: "#fff",
      "border-color": "#eee",
      offset: "0.05rem",
      closable: "",
      ref: "preLayer",
      onShowing: _cache[31] || (_cache[31] = ($event) => $options.autoLayerOffset("preLayer"))
    }, {
      default: withCtx(() => [
        createElementVNode("div", _hoisted_9$1, [
          createElementVNode("div", {
            onClick: _cache[27] || (_cache[27] = ($event) => $options.insertParagraphToPre("up")),
            class: "mvi-editor-layer-item"
          }, [
            createVNode(_component_Icon, {
              style: { "transform": "rotate(180deg)" },
              type: "turn-arrow-text"
            })
          ]),
          createElementVNode("div", {
            onClick: _cache[28] || (_cache[28] = ($event) => $options.insertParagraphToPre("down")),
            class: "mvi-editor-layer-item"
          }, [
            createVNode(_component_Icon, { type: "turn-arrow-text" })
          ]),
          $props.highlight ? (openBlock(), createElementBlock("div", _hoisted_10$1, [
            createVNode(_component_m_select, {
              "active-color": $props.activeColor,
              modelValue: $data.preAdjusterProps.language,
              "onUpdate:modelValue": _cache[29] || (_cache[29] = ($event) => $data.preAdjusterProps.language = $event),
              options: $data.preAdjusterProps.languages,
              height: "4rem",
              "layer-props": { width: "2.4rem" },
              icon: "angle-down",
              onChange: $options.selectLanguage
            }, null, 8, ["active-color", "modelValue", "options", "onChange"])
          ])) : createCommentVNode("", true)
        ])
      ]),
      _: 1
    }, 8, ["modelValue", "target"])
  ]);
}
const Editor = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7], ["__scopeId", "data-v-671aac24"]]);
Editor.install = (app) => {
  app.component(Editor.name, Editor);
};
const defaultTooltipProps = {
  placement: "bottom",
  timeout: 200,
  color: "#333",
  textColor: "#fff",
  borderColor: "#333",
  offset: "0.1rem",
  zIndex: 100,
  fixed: false,
  fixedAuto: false,
  width: null,
  showTriangle: true,
  animation: null
};
const defaultLayerProps = {
  placement: "bottom-start",
  offset: "0rem",
  zIndex: 400,
  fixed: false,
  fixedAuto: false,
  width: null,
  timeout: 100,
  showTriangle: false,
  animation: null,
  shadow: true,
  border: true
};
const defaultUploadImageProps = {
  multiple: false,
  allowedFileType: ["jpg", "png", "JPG", "PNG", "JPEG", "jpeg", "gif", "GIF", "jfif", "JFIF", "webp", "WEBP"],
  accept: "image",
  minSize: -1,
  maxSize: -1,
  minLength: -1,
  maxLength: -1
};
const defaultUploadVideoProps = {
  multiple: false,
  allowedFileType: ["mp4", "MP4", "avi", "AVI", "WAV", "wav"],
  accept: "video",
  minSize: -1,
  maxSize: -1,
  minLength: -1,
  maxLength: -1
};
const editorMenus_vue_vue_type_style_index_0_scoped_d018c9c2_lang = "";
const _sfc_main$6 = {
  name: "m-editor-menus",
  data() {
    return {
      instance: null
    };
  },
  emits: ["upload-image", "upload-video"],
  provide() {
    return {
      menus: this
    };
  },
  props: {
    useTooltip: {
      type: Boolean,
      default: false
    },
    layerProps: {
      type: Object,
      default: function() {
        return {};
      }
    },
    uploadImageProps: {
      type: Object,
      default: function() {
        return {};
      }
    },
    uploadVideoProps: {
      type: Object,
      default: function() {
        return {};
      }
    },
    useBase64: {
      type: Boolean,
      default: true
    },
    uploadImageError: {
      type: Function
    },
    uploadVideoError: {
      type: Function
    },
    trigger: {
      type: String,
      default: "click",
      validator(value) {
        return ["hover", "click"].includes(value);
      }
    },
    tooltipProps: {
      type: Object,
      default: function() {
        return {};
      }
    },
    border: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    combinedTooltipProps() {
      return this.initOption(defaultTooltipProps, this.tooltipProps);
    },
    combinedLayerProps() {
      return this.initOption(defaultLayerProps, this.layerProps);
    },
    combinedUploadImageProps() {
      return this.initOption(defaultUploadImageProps, this.uploadImageProps);
    },
    combinedUploadVideoProps() {
      return this.initOption(defaultUploadVideoProps, this.uploadVideoProps);
    }
  },
  setup() {
    const instance = getCurrentInstance();
    return {
      uid: instance.uid
    };
  },
  mounted() {
    obj$1.event.on(document.documentElement, `mousedown.editor_menus_${this.uid}`, (e) => {
      if (!this.instance) {
        return;
      }
      if (!obj$1.element.isContains(this.$el, e.target) && !obj$1.element.isContains(this.instance.$el, e.target) && !this.instance.codeViewShow) {
        this.instance.canUseMenus = false;
      }
    });
  },
  methods: {
    initOption(defaultObj, propObj) {
      let obj2 = {};
      Object.assign(obj2, defaultObj);
      Object.assign(obj2, propObj);
      return obj2;
    }
  },
  beforeUnmount() {
    obj$1.event.off(document.documentElement, `click.editor_menus_${this.uid}`);
  }
};
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["mvi-editor-menus", $props.border ? "border" : ""])
  }, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true)
  ], 2);
}
const EditorMenus = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6], ["__scopeId", "data-v-d018c9c2"]]);
EditorMenus.install = (app) => {
  app.component(EditorMenus.name, EditorMenus);
};
const _sfc_main$5 = {
  props: {
    tag: {
      type: String,
      default: "div"
    }
  },
  components: {
    Tag: {
      render() {
        return h(
          this.$parent.tag,
          {},
          {
            default: this.$slots.default
          }
        );
      }
    }
  }
};
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Tag = resolveComponent("Tag");
  return openBlock(), createBlock(_component_Tag, null, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  });
}
const EditorTag = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
const definedMenus = [
  {
    name: "undo",
    type: "default",
    icon: "undo",
    title: "\u64A4\u9500"
  },
  {
    name: "redo",
    type: "default",
    icon: "redo",
    title: "\u91CD\u505A"
  },
  {
    name: "removeformat",
    type: "default",
    icon: "clear",
    title: "\u6E05\u9664\u683C\u5F0F"
  },
  {
    name: "indent",
    type: "select",
    icon: "indent-right",
    title: "\u7F29\u8FDB",
    list: [
      {
        label: "\u589E\u52A0\u7F29\u8FDB",
        value: "indent-right",
        icon: "indent-right"
      },
      {
        label: "\u51CF\u5C11\u7F29\u8FDB",
        value: "indent-left",
        icon: "indent-left"
      }
    ]
  },
  {
    name: "divider",
    type: "default",
    icon: "divider",
    title: "\u5206\u9694\u7EBF"
  },
  {
    name: "code",
    type: "default",
    icon: "code",
    title: "\u4EE3\u7801"
  },
  {
    name: "bold",
    type: "default",
    icon: "bold",
    title: "\u52A0\u7C97"
  },
  {
    name: "italic",
    type: "default",
    icon: "italic",
    title: "\u659C\u4F53"
  },
  {
    name: "underline",
    type: "default",
    icon: "underline",
    title: "\u4E0B\u5212\u7EBF"
  },
  {
    name: "strikethrough",
    type: "default",
    icon: "strikethrough",
    title: "\u5220\u9664\u7EBF"
  },
  {
    name: "subscript",
    type: "default",
    icon: "subscript",
    title: "\u4E0B\u6807"
  },
  {
    name: "superscript",
    type: "default",
    icon: "superscript",
    title: "\u4E0A\u6807"
  },
  {
    name: "title",
    type: "display",
    title: "\u6807\u9898",
    list: [
      {
        label: "\u4E00\u7EA7\u6807\u9898",
        value: "h1"
      },
      {
        label: "\u4E8C\u7EA7\u6807\u9898",
        value: "h2"
      },
      {
        label: "\u4E09\u7EA7\u6807\u9898",
        value: "h3"
      },
      {
        label: "\u56DB\u7EA7\u6807\u9898",
        value: "h4"
      },
      {
        label: "\u4E94\u7EA7\u6807\u9898",
        value: "h5"
      },
      {
        label: "\u516D\u7EA7\u6807\u9898",
        value: "h6"
      },
      {
        label: "\u6B63\u6587",
        value: "p"
      }
    ],
    value: "p"
  },
  {
    name: "fontfamily",
    type: "display",
    title: "\u5B57\u4F53",
    value: "",
    list: [
      {
        label: "\u9ED8\u8BA4\u5B57\u4F53",
        value: ""
      },
      "\u9ED1\u4F53",
      "\u4EFF\u5B8B",
      "\u6977\u4F53",
      "\u5B8B\u4F53",
      "Arial",
      "Consolas"
    ]
  },
  {
    name: "fontsize",
    type: "display",
    title: "\u5B57\u53F7",
    value: "",
    list: [
      {
        label: "\u9ED8\u8BA4\u5B57\u53F7",
        value: ""
      },
      {
        label: "12px",
        value: "0.24rem"
      },
      {
        label: "16px",
        value: "0.32rem"
      },
      {
        label: "20px",
        value: "0.4rem"
      },
      {
        label: "28px",
        value: "0.56rem"
      },
      {
        label: "36px",
        value: "0.72rem"
      },
      {
        label: "48px",
        value: "0.96rem"
      }
    ]
  },
  {
    name: "forecolor",
    type: "select",
    title: "\u6587\u5B57\u989C\u8272",
    icon: "color-picker",
    list: ["#000000", "#505050", "#808080", "#BBBBBB", "#CCCCCC", "#EEEEEE", "#F7F7F7", "#FFFFFF", "#EC1A0A", "#FF9900", "#FFFF00", "#07C160", "#00FFFF", "#0B73DE", "#9C00FF", "#FF00FF", "#F7C6CE", "#FFE7CE", "#FFEFC6", "#D6EFD6", "#CEDEE7", "#CEE7F7", "#D6D6E7", "#E7D6DE", "#E79C9C", "#FFC69C", "#FFE79C", "#B5D6A5", "#A5C6CE", "#9CC6EF", "#B5A5D6", "#D6A5BD", "#e45649", "#F7AD6B", "#FFD663", "#94BD7B", "#73A5AD", "#6BADDE", "#8C7BC6", "#C67BA5", "#CE0000", "#E79439", "#EFC631", "#50a14f", "#4A7B8C", "#03A8F3", "#634AA5", "#A54A7B", "#9C0000", "#B56308", "#BD9400", "#397B21", "#104A5A", "#085294", "#311873", "#731842", "#630000", "#7B3900", "#986801", "#295218", "#083139", "#003163", "#21104A", "#4A1031"]
  },
  {
    name: "backcolor",
    type: "select",
    title: "\u80CC\u666F\u989C\u8272",
    icon: "brush",
    list: ["#000000", "#505050", "#808080", "#BBBBBB", "#CCCCCC", "#EEEEEE", "#F7F7F7", "#FFFFFF", "#EC1A0A", "#FF9900", "#FFFF00", "#07C160", "#00FFFF", "#0B73DE", "#9C00FF", "#FF00FF", "#F7C6CE", "#FFE7CE", "#FFEFC6", "#D6EFD6", "#CEDEE7", "#CEE7F7", "#D6D6E7", "#E7D6DE", "#E79C9C", "#FFC69C", "#FFE79C", "#B5D6A5", "#A5C6CE", "#9CC6EF", "#B5A5D6", "#D6A5BD", "#E76363", "#F7AD6B", "#FFD663", "#94BD7B", "#73A5AD", "#6BADDE", "#8C7BC6", "#C67BA5", "#CE0000", "#E79439", "#EFC631", "#6BA54A", "#4A7B8C", "#03A8F3", "#634AA5", "#A54A7B", "#9C0000", "#B56308", "#BD9400", "#397B21", "#104A5A", "#085294", "#311873", "#731842", "#630000", "#7B3900", "#846300", "#295218", "#083139", "#003163", "#21104A", "#4A1031"]
  },
  {
    name: "ol",
    type: "default",
    icon: "ol",
    title: "\u6709\u5E8F\u5217\u8868"
  },
  {
    name: "ul",
    type: "default",
    icon: "ul",
    title: "\u65E0\u5E8F\u5217\u8868"
  },
  {
    name: "justify",
    type: "select",
    icon: "align-left",
    title: "\u5BF9\u9F50\u65B9\u5F0F",
    list: [
      {
        label: "\u5DE6\u5BF9\u9F50",
        value: "left",
        icon: "align-left"
      },
      {
        label: "\u5C45\u4E2D\u5BF9\u9F50",
        value: "center",
        icon: "align-center"
      },
      {
        label: "\u53F3\u5BF9\u9F50",
        value: "right",
        icon: "align-right"
      },
      {
        label: "\u4E24\u7AEF\u5BF9\u9F50",
        value: "justify",
        icon: "align-justify"
      }
    ]
  },
  {
    name: "quote",
    type: "default",
    icon: "quote",
    title: "\u5F15\u7528"
  },
  {
    name: "link",
    type: "select",
    icon: "link",
    title: "\u63D2\u5165\u94FE\u63A5",
    props: {
      placeholder: ["\u8F93\u5165\u6587\u672C", "\u8F93\u5165\u5730\u5740"],
      targetText: "\u65B0\u7A97\u53E3\u6253\u5F00",
      removeText: "\u79FB\u9664\u94FE\u63A5",
      insertText: "\u63D2\u5165"
    }
  },
  {
    name: "image",
    icon: "image",
    title: "\u63D2\u5165\u56FE\u7247",
    type: "select",
    props: {
      placeholder: "\u56FE\u7247\u5730\u5740",
      insertText: "\u63D2\u5165"
    },
    list: [
      {
        label: "\u672C\u5730\u4E0A\u4F20",
        value: "upload"
      },
      {
        label: "\u7F51\u7EDC\u56FE\u7247",
        value: "remote"
      }
    ]
  },
  {
    name: "video",
    icon: "video",
    title: "\u63D2\u5165\u89C6\u9891",
    type: "select",
    props: {
      placeholder: "\u89C6\u9891\u5730\u5740",
      insertText: "\u63D2\u5165"
    },
    list: [
      {
        label: "\u672C\u5730\u4E0A\u4F20",
        value: "upload"
      },
      {
        label: "\u7F51\u7EDC\u89C6\u9891",
        value: "remote"
      }
    ]
  },
  {
    name: "table",
    type: "select",
    icon: "table-alt",
    title: "\u63D2\u5165\u8868\u683C",
    props: {
      insertRowText: "\u63D2\u5165\u884C",
      removeRowText: "\u5220\u9664\u884C",
      insertColumnText: "\u63D2\u5165\u5217",
      removeColumnText: "\u5220\u9664\u5217",
      deleteText: "\u5220\u9664\u8868\u683C"
    }
  },
  {
    name: "codeblock",
    type: "default",
    icon: "code-block",
    title: "\u4EE3\u7801\u5757"
  },
  {
    name: "empty",
    type: "default",
    icon: "trash",
    title: "\u6E05\u7A7A"
  },
  {
    name: "codeview",
    type: "default",
    icon: "eye",
    title: "\u6E90\u7801\u89C6\u56FE"
  }
];
const editorMenu_vue_vue_type_style_index_0_scoped_9f3babac_lang = "";
const getMenu = (name) => {
  if (name == "custom") {
    return null;
  }
  return definedMenus.find((item) => {
    return name == item.name;
  });
};
const getTableGrids = function() {
  const grids = [];
  for (let i = 0; i < 10; i++) {
    let row = [];
    for (let j = 0; j < 10; j++) {
      row.push({
        x: i + 1,
        y: j + 1,
        inside: false
      });
    }
    grids.push(row);
  }
  return grids;
};
const _sfc_main$4 = {
  name: "m-editor-menu",
  emits: ["custom"],
  props: {
    name: {
      type: String,
      default: null
    },
    type: {
      type: String,
      default: function(props) {
        const menu = getMenu(props.name);
        return menu ? menu.type : "default";
      },
      validator(value) {
        return ["default", "select", "display"].includes(value);
      }
    },
    icon: {
      type: [String, Object],
      default: function(props) {
        const menu = getMenu(props.name);
        return menu ? menu.icon : null;
      }
    },
    list: {
      type: Array,
      default: function(props) {
        const menu = getMenu(props.name);
        return menu ? menu.list || [] : [];
      }
    },
    title: {
      type: String,
      default: function(props) {
        const menu = getMenu(props.name);
        return menu ? menu.title : "";
      }
    },
    value: {
      type: [String, Number],
      default: function(props) {
        const menu = getMenu(props.name);
        return menu ? menu.value : null;
      }
    },
    props: {
      type: Object,
      default: function(props) {
        const menu = getMenu(props.name);
        return menu ? menu.props || {} : {};
      }
    },
    disabled: {
      type: Boolean,
      default: false
    },
    customActive: {
      type: Function
    }
  },
  inject: ["menus"],
  data() {
    return {
      rangeUpdateTimer: null,
      defaultVal: {},
      selectedVal: {},
      layerShow: false,
      active: false,
      linkParams: {
        url: "",
        text: "",
        target: false,
        showText: true
      },
      mediaParams: {
        tabIndex: 0,
        remoteUrl: ""
      },
      tableParams: {
        size: [],
        grids: getTableGrids()
      }
    };
  },
  computed: {
    parseIcon() {
      return (param) => {
        let icon = {
          spin: false,
          type: null,
          url: null,
          color: null,
          size: null
        };
        if (obj$1.common.isObject(param)) {
          if (typeof param.spin == "boolean") {
            icon.spin = param.spin;
          }
          if (typeof param.type == "string") {
            icon.type = param.type;
          }
          if (typeof param.url == "string") {
            icon.url = param.url;
          }
          if (typeof param.color == "string") {
            icon.color = param.color;
          }
          if (typeof param.size == "string") {
            icon.size = param.size;
          }
        } else if (typeof param == "string") {
          icon.type = param;
        }
        return icon;
      };
    },
    parseList() {
      if (Array.isArray(this.list)) {
        return this.list.map((item) => {
          let obj2 = {};
          if (obj$1.common.isObject(item)) {
            obj2.label = item.label;
            obj2.value = item.value;
            obj2.icon = this.parseIcon(item.icon);
          } else if (typeof item == "string") {
            obj2.label = item;
            obj2.value = item;
            obj2.icon = this.parseIcon(null);
          }
          return obj2;
        });
      }
      return [];
    },
    cmpDisabled() {
      if (this.disabled) {
        return true;
      }
      if (this.menus.disabled) {
        return true;
      }
      if (!this.menus.instance) {
        return true;
      }
      if (this.menus.instance.disabled) {
        return true;
      }
      if (!this.menus.instance.canUseMenus) {
        return true;
      }
      if (this.menus.instance.codeViewShow && this.name != "codeview") {
        return true;
      }
      if (this.menus.instance.isPre && !["codeblock", "undo", "redo"].includes(this.name)) {
        return true;
      }
      if (this.menus.instance.isTable && ["indent", "divider", "title", "ol", "ul", "codeblock"].includes(this.name)) {
        return true;
      }
      return false;
    },
    layerElTag() {
      return (item) => {
        if (this.name == "title") {
          return item.value;
        }
        return "div";
      };
    },
    activeColorStyle() {
      let style = {};
      if (this.cmpDisabled) {
        return style;
      }
      if (this.active) {
        style.opacity = 1;
        style.color = this.activeColor;
      }
      return style;
    },
    activeColor() {
      if (this.cmpDisabled) {
        return "";
      }
      if (this.menus.instance.activeColor) {
        return this.menus.instance.activeColor;
      }
      return "";
    },
    isDefinedMenu() {
      const menu = getMenu(this.name);
      return !!menu;
    },
    menuColorStyle() {
      return (item) => {
        let style = {};
        if (this.cmpDisabled) {
          return style;
        }
        if (this.selectedVal.value == item.value) {
          style.borderColor = this.activeColor;
        }
        return style;
      };
    },
    uploadOptions() {
      let options = {};
      if (this.cmpDisabled) {
        return options;
      }
      if (this.name == "image") {
        options = this.menus.combinedUploadImageProps;
      } else if (this.name == "video") {
        options = this.menus.combinedUploadVideoProps;
      }
      return {
        ...options,
        select: (files) => {
          if (this.menus.useBase64) {
            files.forEach((file2) => {
              obj$1.file.dataFileToBase64(file2).then((base64) => {
                if (this.name == "image") {
                  this.menus.instance.insertImage(base64);
                } else if (this.name == "video") {
                  this.menus.instance.insertVideo(base64);
                }
              });
            });
          } else {
            if (this.name == "image") {
              this.menus.$emit("upload-image", files);
            } else if (this.name == "video") {
              this.menus.$emit("upload-video", files);
            }
          }
          this.hideLayer();
        },
        error: (errorType, file2) => {
          let msg = "";
          if (errorType == "suffixError") {
            msg = "\u6587\u4EF6\u540E\u7F00\u4E0D\u7B26\u5408";
          } else if (errorType == "maxSizeError") {
            msg = "\u8D85\u51FA\u6700\u5927\u6587\u4EF6\u5C3A\u5BF8\u9650\u5236";
          } else if (errorType == "minSizeError") {
            msg = "\u6587\u4EF6\u5C3A\u5BF8\u6CA1\u6709\u8FBE\u5230\u8981\u6C42\u7684\u6700\u5C0F\u503C";
          } else if (errorType == "maxLengthError") {
            msg = "\u6587\u4EF6\u6570\u91CF\u8D85\u51FA\u9650\u5236";
          } else if (errorType == "minLengthError") {
            msg = "\u6587\u4EF6\u6570\u91CF\u6CA1\u6709\u8FBE\u5230\u6700\u5C0F\u503C";
          }
          if (this.name == "image") {
            if (typeof this.menus.uploadImageError == "function") {
              this.menus.uploadImageError(errorType, msg, file2);
            } else {
              Msgbox.msgbox({
                message: msg,
                animation: "scale"
              });
            }
          } else if (this.name == "video") {
            if (typeof this.menus.uploadVideoError == "function") {
              this.menus.uploadVideoError(errorType, msg, file2);
            } else {
              Msgbox.msgbox({
                message: msg,
                animation: "scale"
              });
            }
          }
          this.hideLayer();
        }
      };
    }
  },
  components: {
    Icon,
    Tooltip,
    Layer,
    Checkbox,
    Tabs,
    Tab,
    EditorTag
  },
  setup() {
    return {
      uid: getCurrentInstance().uid
    };
  },
  watch: {
    list: {
      handler: function(newVal) {
        if (newVal && this.type == "display") {
          if (this.value === null || this.value === void 0) {
            this.selectedVal = { ...this.parseList[0] };
            this.defaultVal = { ...this.parseList[0] };
          } else {
            this.selectedVal = this.parseList.find((item) => {
              return item.value == this.value;
            }) || { ...this.parseList[0] };
            this.defaultVal = this.parseList.find((item) => {
              return item.value == this.value;
            }) || { ...this.parseList[0] };
          }
        }
      },
      immediate: true
    }
  },
  mounted() {
    const unwatch = this.$watch("menus.instance", (instance) => {
      instance.editor.on("rangeUpdate", this.handleRangeUpdate);
      unwatch();
    });
  },
  methods: {
    beforeLayerShow() {
      if (this.name == "link") {
        this.linkParams = {
          url: "",
          text: "",
          target: false,
          showText: true
        };
        if (this.active) {
          this.linkParams.showText = false;
          const element2 = this.menus.instance.linkAdjusterProps.element;
          if (element2) {
            if (element2.hasChildren()) {
              const elements = AlexElement.flatElements(element2.children);
              let text = "";
              elements.forEach((el) => {
                if (el.isText()) {
                  text += el.textContent || "";
                }
              });
              this.linkParams.text = text;
            }
            if (element2.hasMarks()) {
              this.linkParams.url = element2.marks["href"] || "";
              this.linkParams.target = element2.marks["target"] == "_blank";
            }
          }
        } else {
          if (!this.menus.instance.editor.range.anchor.isEqual(this.menus.instance.editor.range.focus)) {
            let text = "";
            const result = this.menus.instance.editor.getElementsByRange(true, true);
            result.forEach((item) => {
              if (item.element.isText()) {
                if (item.offset) {
                  text += item.element.textContent.substring(item.offset[0], item.offset[1]);
                } else {
                  text += item.element.textContent || "";
                }
              }
            });
            this.linkParams.text = text;
          }
        }
      } else if (this.name == "image" || this.name == "video") {
        this.mediaParams.tabIndex = 0;
        this.mediaParams.remoteUrl = "";
        const elements = this.$el.querySelectorAll(".mvi-editor-menu-media-upload");
        if (elements.length) {
          for (let i = 0; i < elements.length; i++) {
            let upload = new Upload$1(elements[i], { ...this.uploadOptions });
            upload.init();
          }
        }
      } else if (this.name == "table") {
        this.tableParams.grids = getTableGrids();
      }
    },
    tabChange() {
      this.$nextTick(() => {
        const elements = this.$el.querySelectorAll(".mvi-editor-menu-media-upload");
        if (elements.length) {
          for (let i = 0; i < elements.length; i++) {
            let upload = new Upload$1(elements[i], { ...this.uploadOptions });
            upload.init();
          }
        }
      });
    },
    inputFocus(event2) {
      event2.currentTarget.style.borderColor = this.activeColor;
    },
    inputBlur(event2) {
      event2.currentTarget.style.borderColor = "";
    },
    menuHover(type) {
      if (this.cmpDisabled) {
        return;
      }
      if (this.menus.trigger != "hover") {
        return;
      }
      if (type == "enter") {
        this.showLayer();
      } else if (type == "leave") {
        this.hideLayer();
      }
    },
    layerClick(item) {
      if (this.cmpDisabled) {
        return;
      }
      if (this.isDefinedMenu) {
        this.handleOpt(item);
      } else {
        this.$emit("custom", { ...item });
      }
      this.hideLayer();
    },
    menuClick() {
      if (this.cmpDisabled) {
        return;
      }
      if (this.type == "select" || this.type == "display") {
        if (this.menus.trigger == "click") {
          if (this.layerShow) {
            this.hideLayer();
          } else {
            this.showLayer();
          }
        }
      } else {
        if (this.isDefinedMenu) {
          this.handleOpt();
        } else {
          this.$emit("custom");
        }
      }
    },
    showLayer() {
      if (this.cmpDisabled) {
        return;
      }
      if (this.type == "select" || this.type == "display") {
        this.layerShow = true;
      }
    },
    hideLayer() {
      if (this.type == "select" || this.type == "display") {
        this.layerShow = false;
      }
    },
    handleOpt(item) {
      if (this.cmpDisabled) {
        return;
      }
      const editor = this.menus.instance.editor;
      if (this.name == "undo") {
        this.menus.instance.undo();
      } else if (this.name == "redo") {
        this.menus.instance.redo();
      } else if (this.name == "removeformat") {
        this.menus.instance.removeFormat();
      } else if (this.name == "indent") {
        if (item.value == "indent-right") {
          this.menus.instance.setIndent();
        } else {
          this.menus.instance.setOutdent();
        }
      } else if (this.name == "divider") {
        this.menus.instance.insertDivider();
      } else if (this.name == "code") {
        this.menus.instance.setCodeStyle();
      } else if (this.name == "bold") {
        this.menus.instance.setBold();
      } else if (this.name == "italic") {
        this.menus.instance.setItalic();
      } else if (this.name == "underline") {
        this.menus.instance.setUnderline();
      } else if (this.name == "strikethrough") {
        this.menus.instance.setStrikeThrough();
      } else if (this.name == "subscript") {
        this.menus.instance.setSub();
      } else if (this.name == "superscript") {
        this.menus.instance.setSuper();
      } else if (this.name == "title") {
        this.menus.instance.setTitle(item.value);
      } else if (this.name == "fontfamily") {
        this.menus.instance.setFontFamily(item.value);
      } else if (this.name == "fontsize") {
        this.menus.instance.setFontSize(item.value);
      } else if (this.name == "forecolor") {
        this.menus.instance.setForeColor(item.value);
      } else if (this.name == "backcolor") {
        this.menus.instance.setBackColor(item.value);
      } else if (this.name == "ol" || this.name == "ul") {
        this.menus.instance.setList(this.name == "ol");
      } else if (this.name == "justify") {
        this.menus.instance.setJustify(item.value);
      } else if (this.name == "quote") {
        this.menus.instance.setQuote();
      } else if (this.name == "codeblock") {
        this.menus.instance.setCodeBlock();
      } else if (this.name == "empty") {
        const paragraph = new AlexElement("block", "p", null, null, null);
        const breakEl = new AlexElement("closed", "br", null, null, null);
        editor.addElementTo(breakEl, paragraph);
        editor.stack = [paragraph];
        editor.range.anchor.moveToStart(breakEl);
        editor.range.focus.moveToStart(breakEl);
        editor.formatElementStack();
        editor.domRender();
        editor.rangeRender();
      } else if (this.name == "codeview") {
        this.menus.instance.codeViewShow = !this.menus.instance.codeViewShow;
        this.active = this.menus.instance.codeViewShow;
      }
    },
    handleRangeUpdate(range) {
      if (this.rangeUpdateTimer) {
        clearTimeout(this.rangeUpdateTimer);
        this.rangeUpdateTimer = null;
      }
      this.rangeUpdateTimer = setTimeout(() => {
        const editor = this.menus.instance.editor;
        if (this.name == "code") {
          this.active = editor.queryTextMark("data-code-style");
        } else if (this.name == "bold") {
          this.active = editor.queryTextStyle("font-weight", "bold");
        } else if (this.name == "italic") {
          this.active = editor.queryTextStyle("font-style", "italic");
        } else if (this.name == "underline") {
          this.active = editor.queryTextStyle("text-decoration-line", "underline") || editor.queryTextStyle("text-decoration", "underline");
        } else if (this.name == "strikethrough") {
          this.active = editor.queryTextStyle("text-decoration-line", "line-through") || editor.queryTextStyle("text-decoration", "line-through");
        } else if (this.name == "subscript") {
          this.active = editor.queryTextStyle("vertical-align", "sub");
        } else if (this.name == "superscript") {
          this.active = editor.queryTextStyle("vertical-align", "super");
        } else if (this.name == "title") {
          if (editor.range.anchor.isEqual(editor.range.focus)) {
            this.selectedVal = this.parseList.find((item) => {
              return item.value == editor.range.anchor.element.getBlock().parsedom;
            }) || { ...this.defaultVal };
          } else {
            const result = editor.getElementsByRange(true, false);
            this.selectedVal = this.parseList.find((item) => {
              return result.every((el) => {
                if (el.element.isBlock()) {
                  return el.element.parsedom == item.value;
                }
                return el.element.getBlock().parsedom == item.value;
              });
            }) || { ...this.defaultVal };
          }
        } else if (this.name == "fontfamily") {
          this.selectedVal = this.parseList.find((item) => {
            return editor.queryTextStyle("font-family", item.value);
          }) || { ...this.defaultVal };
        } else if (this.name == "fontsize") {
          this.selectedVal = this.parseList.find((item) => {
            return editor.queryTextStyle("font-size", item.value);
          }) || { ...this.defaultVal };
        } else if (this.name == "forecolor") {
          this.selectedVal = this.parseList.find((item) => {
            return editor.queryTextStyle("color", item.value);
          }) || {};
        } else if (this.name == "backcolor") {
          this.selectedVal = this.parseList.find((item) => {
            return editor.queryTextStyle("background-color", item.value);
          }) || {};
        } else if (this.name == "ol" || this.name == "ul") {
          if (editor.range.anchor.isEqual(editor.range.focus)) {
            const block2 = editor.range.anchor.element.getBlock();
            this.active = elementUtil.isList(block2, this.name == "ol");
          } else {
            const result = editor.getElementsByRange(true, false);
            this.active = result.every((item) => {
              if (item.element.isBlock()) {
                return elementUtil.isList(item.element, this.name == "ol");
              } else {
                const block2 = item.element.getBlock();
                return elementUtil.isList(block2, this.name == "ol");
              }
            });
          }
        } else if (this.name == "justify") {
          if (editor.range.anchor.isEqual(editor.range.focus)) {
            const block2 = editor.range.anchor.element.getBlock();
            const inblock2 = editor.range.anchor.element.getInblock();
            if (inblock2) {
              this.selectedVal = this.parseList.find((item) => {
                return inblock2.hasStyles() && inblock2.styles["text-align"] == item.value;
              }) || {};
            } else {
              this.selectedVal = this.parseList.find((item) => {
                return block2.hasStyles() && block2.styles["text-align"] == item.value;
              }) || {};
            }
          } else {
            const result = editor.getElementsByRange(true, false);
            this.selectedVal = this.parseList.find((item) => {
              return result.every((el) => {
                if (el.element.isBlock() || el.element.isInblock()) {
                  return el.element.hasStyles() && el.element.styles["text-align"] == item.value;
                }
                const block2 = el.element.getBlock();
                const inblock2 = el.element.getInblock();
                if (inblock2) {
                  return inblock2.hasStyles() && inblock2.styles["text-align"] == item.value;
                }
                return block2.hasStyles() && block2.styles["text-align"] == item.value;
              });
            }) || {};
          }
        } else if (this.name == "quote") {
          if (editor.range.anchor.isEqual(editor.range.focus)) {
            const block2 = editor.range.anchor.element.getBlock();
            this.active = block2.parsedom == "blockquote";
          } else {
            const result = editor.getElementsByRange(true, false);
            this.active = result.every((item) => {
              if (item.element.isBlock()) {
                return item.element.parsedom == "blockquote";
              } else {
                const block2 = item.element.getBlock();
                return block2.parsedom == "blockquote";
              }
            });
          }
        } else if (this.name == "link") {
          this.active = this.menus.instance.isLink;
        } else if (this.name == "table") {
          this.active = this.menus.instance.isTable;
        } else if (this.name == "codeblock") {
          this.active = this.menus.instance.isPre;
        } else if (!this.isDefinedMenu && typeof this.customActive == "function") {
          const obj2 = this.customActive.apply(this, [this.name]);
          if (this.type == "default") {
            this.active = obj2;
          } else if (this.type == "select") {
            if (typeof obj2 == "boolean") {
              this.active = obj2;
            } else {
              this.selectedVal = this.parseList.find((item) => {
                return item.value == obj2;
              }) || {};
            }
          } else {
            if (typeof obj2 == "boolean") {
              this.active = obj2;
            } else {
              this.selectedVal = this.parseList.find((item) => {
                return item.value == obj2;
              }) || { ...this.defaultVal };
            }
          }
        }
      }, 100);
    },
    insertLink() {
      if (this.cmpDisabled) {
        return;
      }
      if (!this.linkParams.url) {
        this.hideLayer();
        return;
      }
      if (this.active) {
        const element2 = this.menus.instance.linkAdjusterProps.element;
        element2.marks.href = this.linkParams.url;
        if (this.linkParams.target) {
          element2.marks.target = "_blank";
        } else {
          delete element2.marks.target;
        }
      } else {
        if (!this.linkParams.text) {
          this.linkParams.text = this.linkParams.url;
        }
        const marks = {
          href: this.linkParams.url
        };
        if (this.linkParams.target) {
          marks.target = "_blank";
        }
        const link = new AlexElement("inline", "a", marks, null, null);
        const text = new AlexElement("text", null, null, null, this.linkParams.text);
        this.menus.instance.editor.addElementTo(text, link);
        this.menus.instance.editor.insertElement(link);
      }
      this.menus.instance.editor.formatElementStack();
      this.menus.instance.editor.domRender();
      this.menus.instance.editor.rangeRender();
      this.hideLayer();
    },
    deleteLink() {
      if (this.cmpDisabled) {
        return;
      }
      const element2 = this.menus.instance.linkAdjusterProps.element;
      element2.parsedom = AlexElement.TEXT_NODE;
      delete element2.marks.target;
      delete element2.marks.href;
      this.menus.instance.editor.formatElementStack();
      this.menus.instance.editor.domRender();
      this.menus.instance.editor.rangeRender();
      this.hideLayer();
    },
    insertRemote() {
      if (this.cmpDisabled) {
        return;
      }
      if (!this.mediaParams.remoteUrl) {
        this.hideLayer();
        return;
      }
      if (this.name == "video") {
        this.menus.instance.insertVideo(this.mediaParams.remoteUrl);
      } else {
        this.menus.instance.insertImage(this.mediaParams.remoteUrl);
      }
      this.menus.instance.editor.formatElementStack();
      this.menus.instance.editor.domRender();
      this.menus.instance.editor.rangeRender();
      this.hideLayer();
    },
    confirmTableSize() {
      if (this.cmpDisabled) {
        return;
      }
      const rowLength = this.tableParams.size[0];
      const colLength = this.tableParams.size[1];
      const table = new AlexElement("block", "table", null, null, null);
      const tbody = new AlexElement("inblock", "tbody", null, null, null);
      this.menus.instance.editor.addElementTo(tbody, table);
      for (let i = 0; i < rowLength; i++) {
        const row = new AlexElement("inblock", "tr", null, null, null);
        for (let j = 0; j < colLength; j++) {
          const column = new AlexElement("inblock", "td", null, null, null);
          const breakEl2 = new AlexElement("closed", "br", null, null, null);
          this.menus.instance.editor.addElementTo(breakEl2, column);
          this.menus.instance.editor.addElementTo(column, row);
        }
        this.menus.instance.editor.addElementTo(row, tbody);
      }
      this.menus.instance.editor.insertElement(table);
      const paragraph = new AlexElement("block", AlexElement.BLOCK_NODE, null, null, null);
      const breakEl = new AlexElement("closed", "br", null, null, null);
      this.menus.instance.editor.addElementTo(breakEl, paragraph);
      this.menus.instance.editor.addElementAfter(paragraph, table);
      this.menus.instance.editor.formatElementStack();
      this.menus.instance.editor.range.anchor.moveToStart(tbody);
      this.menus.instance.editor.range.focus.moveToStart(tbody);
      this.menus.instance.editor.domRender();
      this.menus.instance.editor.rangeRender();
      this.hideLayer();
    },
    changeTableSize(data2) {
      if (this.cmpDisabled) {
        return;
      }
      this.tableParams.size = [data2.x, data2.y];
      for (let i in this.tableParams.grids) {
        const grid = this.tableParams.grids[i];
        for (let j in grid) {
          if (grid[j].x <= data2.x && grid[j].y <= data2.y) {
            this.tableParams.grids[i][j].inside = true;
          } else {
            this.tableParams.grids[i][j].inside = false;
          }
        }
      }
    },
    addTableRow() {
      if (this.cmpDisabled) {
        return;
      }
      if (!this.menus.instance.editor.range.anchor.isEqual(this.menus.instance.editor.range.focus)) {
        this.menus.instance.editor.range.anchor.element = this.menus.instance.editor.range.focus.element;
        this.menus.instance.editor.range.anchor.offset = this.menus.instance.editor.range.focus.offset;
      }
      const row = this.menus.instance.getCurrentParsedomElement("tr");
      if (row) {
        const newRow = row.clone();
        newRow.children.forEach((column) => {
          column.children = [];
          const breakEl = new AlexElement("closed", "br", null, null, null);
          this.menus.instance.editor.addElementTo(breakEl, column);
        });
        this.menus.instance.editor.addElementAfter(newRow, row);
        this.menus.instance.editor.formatElementStack();
        this.menus.instance.editor.range.anchor.moveToStart(newRow);
        this.menus.instance.editor.range.focus.moveToStart(newRow);
        this.menus.instance.editor.domRender();
        this.menus.instance.editor.rangeRender();
      }
      this.hideLayer();
    },
    removeTableRow() {
      if (this.cmpDisabled) {
        return;
      }
      if (!this.menus.instance.editor.range.anchor.isEqual(this.menus.instance.editor.range.focus)) {
        this.menus.instance.editor.range.anchor.element = this.menus.instance.editor.range.focus.element;
        this.menus.instance.editor.range.anchor.offset = this.menus.instance.editor.range.focus.offset;
      }
      const row = this.menus.instance.getCurrentParsedomElement("tr");
      if (row) {
        const parent = row.parent;
        if (parent.children.length == 1) {
          this.deleteTable();
          return;
        }
        const previousRow = this.menus.instance.editor.getPreviousElement(row);
        const nextRow = this.menus.instance.editor.getNextElement(row);
        row.toEmpty();
        this.menus.instance.editor.formatElementStack();
        if (previousRow) {
          this.menus.instance.editor.range.anchor.moveToEnd(previousRow.children[0]);
          this.menus.instance.editor.range.focus.moveToEnd(previousRow.children[0]);
        } else {
          this.menus.instance.editor.range.anchor.moveToEnd(nextRow.children[0]);
          this.menus.instance.editor.range.focus.moveToEnd(nextRow.children[0]);
        }
        this.menus.instance.editor.domRender();
        this.menus.instance.editor.rangeRender();
      }
      this.hideLayer();
    },
    addTableColumn() {
      if (this.cmpDisabled) {
        return;
      }
      if (!this.menus.instance.editor.range.anchor.isEqual(this.menus.instance.editor.range.focus)) {
        this.menus.instance.editor.range.anchor.element = this.menus.instance.editor.range.focus.element;
        this.menus.instance.editor.range.anchor.offset = this.menus.instance.editor.range.focus.offset;
      }
      const column = this.menus.instance.getCurrentParsedomElement("td");
      const tbody = this.menus.instance.getCurrentParsedomElement("tbody");
      const table = this.menus.instance.getCurrentParsedomElement("table");
      if (column && table && tbody) {
        const rows = tbody.children;
        const index = column.parent.children.findIndex((item) => {
          return item.isEqual(column);
        });
        rows.forEach((row) => {
          const newColumn = column.clone(false);
          const breakEl = new AlexElement("closed", "br", null, null, null);
          this.menus.instance.editor.addElementTo(breakEl, newColumn);
          this.menus.instance.editor.addElementTo(newColumn, row, index + 1);
        });
        const colgroup = table.children.find((item) => {
          return item.parsedom == "colgroup";
        });
        const col = new AlexElement("closed", "col", null, null, null);
        this.menus.instance.editor.addElementTo(col, colgroup, index + 1);
        this.menus.instance.editor.formatElementStack();
        const nextColumn = this.menus.instance.editor.getNextElement(column);
        this.menus.instance.editor.range.anchor.moveToStart(nextColumn);
        this.menus.instance.editor.range.focus.moveToStart(nextColumn);
        this.menus.instance.editor.domRender();
        this.menus.instance.editor.rangeRender();
      }
      this.hideLayer();
    },
    removeTableColumn() {
      if (this.cmpDisabled) {
        return;
      }
      if (!this.menus.instance.editor.range.anchor.isEqual(this.menus.instance.editor.range.focus)) {
        this.menus.instance.editor.range.anchor.element = this.menus.instance.editor.range.focus.element;
        this.menus.instance.editor.range.anchor.offset = this.menus.instance.editor.range.focus.offset;
      }
      const column = this.menus.instance.getCurrentParsedomElement("td");
      const tbody = this.menus.instance.getCurrentParsedomElement("tbody");
      const table = this.menus.instance.getCurrentParsedomElement("table");
      if (column && table && tbody) {
        const rows = tbody.children;
        const parent = column.parent;
        if (parent.children.length == 1) {
          this.deleteTable();
          return;
        }
        const previousColumn = this.menus.instance.editor.getPreviousElement(column);
        const nextColumn = this.menus.instance.editor.getNextElement(column);
        const index = column.parent.children.findIndex((item) => {
          return item.isEqual(column);
        });
        rows.forEach((row) => {
          row.children[index].toEmpty();
        });
        const colgroup = table.children.find((item) => {
          return item.parsedom == "colgroup";
        });
        colgroup.children[index].toEmpty();
        this.menus.instance.editor.formatElementStack();
        if (previousColumn) {
          this.menus.instance.editor.range.anchor.moveToEnd(previousColumn);
          this.menus.instance.editor.range.focus.moveToEnd(previousColumn);
        } else {
          this.menus.instance.editor.range.anchor.moveToEnd(nextColumn);
          this.menus.instance.editor.range.focus.moveToEnd(nextColumn);
        }
        this.menus.instance.editor.domRender();
        this.menus.instance.editor.rangeRender();
      }
      this.hideLayer();
    },
    deleteTable() {
      if (this.cmpDisabled) {
        return;
      }
      if (!this.menus.instance.editor.range.anchor.isEqual(this.menus.instance.editor.range.focus)) {
        this.menus.instance.editor.range.anchor.element = this.menus.instance.editor.range.focus.element;
        this.menus.instance.editor.range.anchor.offset = this.menus.instance.editor.range.focus.offset;
      }
      const table = this.menus.instance.tableAdjusterProps.element;
      table.toEmpty();
      this.menus.instance.editor.formatElementStack();
      this.menus.instance.editor.domRender();
      this.menus.instance.editor.rangeRender();
      this.hideLayer();
    }
  }
};
const _hoisted_1$1 = ["data-id"];
const _hoisted_2$1 = ["disabled", "data-id"];
const _hoisted_3 = {
  key: 0,
  class: "mvi-editor-menu-text"
};
const _hoisted_4 = {
  key: 0,
  class: "mvi-editor-menu-colors"
};
const _hoisted_5 = ["onClick"];
const _hoisted_6 = {
  key: 1,
  class: "mvi-editor-menu-table"
};
const _hoisted_7 = { class: "mvi-editor-menu-table-operations" };
const _hoisted_8 = { class: "mvi-editor-menu-table-footer" };
const _hoisted_9 = { class: "mvi-editor-menu-table-grids" };
const _hoisted_10 = ["onMouseenter"];
const _hoisted_11 = {
  key: 0,
  class: "mvi-editor-menu-table-size"
};
const _hoisted_12 = {
  key: 2,
  class: "mvi-editor-menu-link"
};
const _hoisted_13 = ["disabled", "placeholder"];
const _hoisted_14 = ["placeholder"];
const _hoisted_15 = { class: "mvi-editor-menu-link-footer" };
const _hoisted_16 = { class: "mvi-editor-menu-link-operation" };
const _hoisted_17 = {
  key: 3,
  class: "mvi-editor-menu-media"
};
const _hoisted_18 = {
  key: 0,
  class: "mvi-editor-menu-media-upload"
};
const _hoisted_19 = {
  key: 1,
  class: "mvi-editor-menu-media-remote"
};
const _hoisted_20 = ["placeholder"];
const _hoisted_21 = {
  key: 4,
  class: "mvi-editor-menu-default"
};
const _hoisted_22 = ["textContent"];
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_Tooltip = resolveComponent("Tooltip");
  const _component_Checkbox = resolveComponent("Checkbox");
  const _component_Tab = resolveComponent("Tab");
  const _component_Tabs = resolveComponent("Tabs");
  const _component_EditorTag = resolveComponent("EditorTag");
  const _component_Layer = resolveComponent("Layer");
  return openBlock(), createElementBlock("div", {
    class: "mvi-editor-menu",
    "data-id": `mvi-editor-menu-${$setup.uid}`,
    onMouseenter: _cache[22] || (_cache[22] = ($event) => $options.menuHover("enter")),
    onMouseleave: _cache[23] || (_cache[23] = ($event) => $options.menuHover("leave"))
  }, [
    createVNode(_component_Tooltip, {
      disabled: !$options.menus.useTooltip || !$props.title || $options.cmpDisabled,
      title: $props.title,
      trigger: "hover",
      placement: $options.menus.combinedTooltipProps.placement,
      timeout: $options.menus.combinedTooltipProps.timeout,
      color: $options.menus.combinedTooltipProps.color,
      "text-color": $options.menus.combinedTooltipProps.textColor,
      "border-color": $options.menus.combinedTooltipProps.borderColor,
      offset: $options.menus.combinedTooltipProps.offset,
      "z-index": $options.menus.combinedTooltipProps.zIndex,
      fixed: $options.menus.combinedTooltipProps.fixed,
      "fixed-auto": $options.menus.combinedTooltipProps.fixedAuto,
      width: $options.menus.combinedTooltipProps.width,
      animation: $options.menus.combinedTooltipProps.animation,
      "show-triangle": $options.menus.combinedTooltipProps.showTriangle,
      block: ""
    }, {
      default: withCtx(() => [
        createElementVNode("div", {
          disabled: $options.cmpDisabled || null,
          class: "mvi-editor-menu-el",
          "data-id": `mvi-editor-menu-el-${$setup.uid}`,
          onClick: _cache[0] || (_cache[0] = (...args) => $options.menuClick && $options.menuClick(...args)),
          style: normalizeStyle($options.activeColorStyle)
        }, [
          $props.type == "display" ? (openBlock(), createElementBlock("span", _hoisted_3, toDisplayString($data.selectedVal.label), 1)) : $options.parseIcon($props.icon).type || $options.parseIcon($props.icon).url ? (openBlock(), createBlock(_component_Icon, {
            key: 1,
            type: $options.parseIcon($props.icon).type,
            url: $options.parseIcon($props.icon).url,
            size: $options.parseIcon($props.icon).size,
            color: $options.parseIcon($props.icon).color,
            spin: $options.parseIcon($props.icon).spin
          }, null, 8, ["type", "url", "size", "color", "spin"])) : createCommentVNode("", true),
          $props.type == "select" || $props.type == "display" ? (openBlock(), createBlock(_component_Icon, {
            key: 2,
            type: "caret-down",
            class: "mvi-editor-menu-caret"
          })) : createCommentVNode("", true)
        ], 12, _hoisted_2$1)
      ]),
      _: 1
    }, 8, ["disabled", "title", "placement", "timeout", "color", "text-color", "border-color", "offset", "z-index", "fixed", "fixed-auto", "width", "animation", "show-triangle"]),
    $props.type == "select" || $props.type == "display" ? (openBlock(), createBlock(_component_Layer, {
      key: 0,
      modelValue: $data.layerShow,
      "onUpdate:modelValue": _cache[21] || (_cache[21] = ($event) => $data.layerShow = $event),
      ref: "layer",
      placement: $options.menus.combinedLayerProps.placement,
      "z-index": $options.menus.combinedLayerProps.zIndex,
      fixed: $options.menus.combinedLayerProps.fixed,
      "fixed-auto": $options.menus.combinedLayerProps.fixedAuto,
      offset: $options.menus.combinedLayerProps.offset,
      timeout: $options.menus.combinedLayerProps.timeout,
      "show-triangle": $options.menus.combinedLayerProps.showTriangle,
      animation: $options.menus.combinedLayerProps.animation,
      shadow: $options.menus.combinedLayerProps.shadow,
      border: $options.menus.combinedLayerProps.border,
      width: $options.menus.combinedLayerProps.width,
      closable: $options.menus.trigger == "click",
      target: `[data-id='mvi-editor-menu-el-${$setup.uid}']`,
      root: `[data-id='mvi-editor-menu-${$setup.uid}']`,
      onShowing: $options.beforeLayerShow
    }, {
      default: withCtx(() => [
        _ctx.$slots.layer ? renderSlot(_ctx.$slots, "layer", { key: 0 }, void 0, true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          $props.name == "forecolor" || $props.name == "backcolor" ? (openBlock(), createElementBlock("div", _hoisted_4, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($options.parseList, (item) => {
              return openBlock(), createElementBlock("div", {
                class: "mvi-editor-menu-color",
                style: normalizeStyle($options.menuColorStyle(item))
              }, [
                createVNode(_component_Tooltip, {
                  disabled: !$options.menus.useTooltip || !item.label || $options.cmpDisabled,
                  trigger: "hover",
                  title: item.label,
                  placement: $options.menus.combinedTooltipProps.placement,
                  timeout: $options.menus.combinedTooltipProps.timeout,
                  color: $options.menus.combinedTooltipProps.color,
                  "text-color": $options.menus.combinedTooltipProps.textColor,
                  "border-color": $options.menus.combinedTooltipProps.borderColor,
                  offset: $options.menus.combinedTooltipProps.offset,
                  "z-index": $options.menus.combinedTooltipProps.zIndex,
                  fixed: $options.menus.combinedTooltipProps.fixed,
                  "fixed-auto": $options.menus.combinedTooltipProps.fixedAuto,
                  width: $options.menus.combinedTooltipProps.width,
                  animation: $options.menus.combinedTooltipProps.animation,
                  "show-triangle": $options.menus.combinedTooltipProps.showTriangle,
                  block: ""
                }, {
                  default: withCtx(() => [
                    createElementVNode("div", {
                      style: normalizeStyle({ backgroundColor: item.value }),
                      onClick: ($event) => $options.layerClick(item),
                      class: "mvi-editor-menu-color-el"
                    }, null, 12, _hoisted_5)
                  ]),
                  _: 2
                }, 1032, ["disabled", "title", "placement", "timeout", "color", "text-color", "border-color", "offset", "z-index", "fixed", "fixed-auto", "width", "animation", "show-triangle"])
              ], 4);
            }), 256))
          ])) : $props.name == "table" ? (openBlock(), createElementBlock("div", _hoisted_6, [
            $data.active ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createElementVNode("div", _hoisted_7, [
                createElementVNode("div", {
                  onClick: _cache[1] || (_cache[1] = (...args) => $options.addTableRow && $options.addTableRow(...args)),
                  style: normalizeStyle({ color: $options.activeColor }),
                  class: "mvi-editor-menu-table-operation"
                }, toDisplayString($props.props.insertRowText), 5),
                createElementVNode("div", {
                  onClick: _cache[2] || (_cache[2] = (...args) => $options.removeTableRow && $options.removeTableRow(...args)),
                  class: "mvi-editor-menu-table-operation"
                }, toDisplayString($props.props.removeRowText), 1),
                createElementVNode("div", {
                  onClick: _cache[3] || (_cache[3] = (...args) => $options.addTableColumn && $options.addTableColumn(...args)),
                  style: normalizeStyle({ color: $options.activeColor }),
                  class: "mvi-editor-menu-table-operation"
                }, toDisplayString($props.props.insertColumnText), 5),
                createElementVNode("div", {
                  onClick: _cache[4] || (_cache[4] = (...args) => $options.removeTableColumn && $options.removeTableColumn(...args)),
                  class: "mvi-editor-menu-table-operation"
                }, toDisplayString($props.props.removeColumnText), 1)
              ]),
              createElementVNode("div", _hoisted_8, [
                createElementVNode("span", {
                  onClick: _cache[5] || (_cache[5] = (...args) => $options.deleteTable && $options.deleteTable(...args))
                }, toDisplayString($props.props.deleteText), 1)
              ])
            ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList($data.tableParams.grids, (item) => {
                return openBlock(), createElementBlock("div", _hoisted_9, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(item, (el) => {
                    return openBlock(), createElementBlock("div", {
                      onClick: _cache[6] || (_cache[6] = (...args) => $options.confirmTableSize && $options.confirmTableSize(...args)),
                      onMouseenter: ($event) => $options.changeTableSize(el),
                      class: normalizeClass(["mvi-editor-menu-table-grid", el.inside ? "active" : ""])
                    }, null, 42, _hoisted_10);
                  }), 256))
                ]);
              }), 256)),
              $data.tableParams.size.length ? (openBlock(), createElementBlock("div", _hoisted_11, toDisplayString($data.tableParams.size[0]) + " \xD7 " + toDisplayString($data.tableParams.size[1]), 1)) : createCommentVNode("", true)
            ], 64))
          ])) : $props.name == "link" ? (openBlock(), createElementBlock("div", _hoisted_12, [
            withDirectives(createElementVNode("input", {
              disabled: !$data.linkParams.showText || null,
              ref: "linkText",
              onFocus: _cache[7] || (_cache[7] = (...args) => $options.inputFocus && $options.inputFocus(...args)),
              onBlur: _cache[8] || (_cache[8] = (...args) => $options.inputBlur && $options.inputBlur(...args)),
              "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => $data.linkParams.text = $event),
              placeholder: $props.props.placeholder[0],
              type: "text"
            }, null, 40, _hoisted_13), [
              [
                vModelText,
                $data.linkParams.text,
                void 0,
                { trim: true }
              ]
            ]),
            withDirectives(createElementVNode("input", {
              ref: "linkUrl",
              onFocus: _cache[10] || (_cache[10] = (...args) => $options.inputFocus && $options.inputFocus(...args)),
              onBlur: _cache[11] || (_cache[11] = (...args) => $options.inputBlur && $options.inputBlur(...args)),
              "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => $data.linkParams.url = $event),
              placeholder: $props.props.placeholder[1],
              type: "text"
            }, null, 40, _hoisted_14), [
              [
                vModelText,
                $data.linkParams.url,
                void 0,
                { trim: true }
              ]
            ]),
            createElementVNode("div", _hoisted_15, [
              createVNode(_component_Checkbox, {
                label: $props.props.targetText,
                placement: "right",
                size: "0.24rem",
                color: $options.activeColor,
                modelValue: $data.linkParams.target,
                "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => $data.linkParams.target = $event)
              }, null, 8, ["label", "color", "modelValue"]),
              createElementVNode("div", _hoisted_16, [
                !$data.linkParams.showText ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  class: "mvi-editor-menu-link-delete",
                  onClick: _cache[14] || (_cache[14] = (...args) => $options.deleteLink && $options.deleteLink(...args))
                }, toDisplayString($props.props.removeText), 1)) : createCommentVNode("", true),
                createElementVNode("span", {
                  class: "mvi-editor-menu-link-insert",
                  style: normalizeStyle({ color: $options.activeColor }),
                  onClick: _cache[15] || (_cache[15] = (...args) => $options.insertLink && $options.insertLink(...args))
                }, toDisplayString($props.props.insertText), 5)
              ])
            ])
          ])) : $props.name == "image" || $props.name == "video" ? (openBlock(), createElementBlock("div", _hoisted_17, [
            createVNode(_component_Tabs, {
              onChange: $options.tabChange,
              modelValue: $data.mediaParams.tabIndex,
              "onUpdate:modelValue": _cache[20] || (_cache[20] = ($event) => $data.mediaParams.tabIndex = $event),
              flex: "flex-start",
              offset: "0.4rem",
              "active-color": $options.activeColor
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList($options.parseList, (item) => {
                  return openBlock(), createBlock(_component_Tab, {
                    title: item.label
                  }, {
                    default: withCtx(() => [
                      item.value == "upload" ? (openBlock(), createElementBlock("div", _hoisted_18, [
                        createVNode(_component_Icon, { type: "upload-square" })
                      ])) : item.value == "remote" ? (openBlock(), createElementBlock("div", _hoisted_19, [
                        withDirectives(createElementVNode("input", {
                          onFocus: _cache[16] || (_cache[16] = (...args) => $options.inputFocus && $options.inputFocus(...args)),
                          onBlur: _cache[17] || (_cache[17] = (...args) => $options.inputBlur && $options.inputBlur(...args)),
                          "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => $data.mediaParams.remoteUrl = $event),
                          placeholder: $props.props.placeholder,
                          type: "text"
                        }, null, 40, _hoisted_20), [
                          [
                            vModelText,
                            $data.mediaParams.remoteUrl,
                            void 0,
                            { trim: true }
                          ]
                        ]),
                        createElementVNode("div", {
                          class: "mvi-editor-menu-media-insert",
                          style: normalizeStyle({ color: $options.activeColor }),
                          onClick: _cache[19] || (_cache[19] = (...args) => $options.insertRemote && $options.insertRemote(...args))
                        }, toDisplayString($props.props.insertText), 5)
                      ])) : createCommentVNode("", true)
                    ]),
                    _: 2
                  }, 1032, ["title"]);
                }), 256))
              ]),
              _: 1
            }, 8, ["onChange", "modelValue", "active-color"])
          ])) : (openBlock(), createElementBlock("div", _hoisted_21, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($options.parseList, (item) => {
              return openBlock(), createBlock(_component_EditorTag, {
                tag: $options.layerElTag(item),
                class: normalizeClass(["mvi-editor-menu-layer-el", $data.selectedVal.value == item.value ? "active" : ""]),
                onClick: ($event) => $options.layerClick(item)
              }, {
                default: withCtx(() => [
                  item.icon.type || item.icon.url ? (openBlock(), createBlock(_component_Icon, {
                    key: 0,
                    class: "mvi-editor-menu-layer-icon",
                    type: item.icon.type,
                    url: item.icon.url,
                    spin: item.icon.spin,
                    size: item.icon.size,
                    color: item.icon.color
                  }, null, 8, ["type", "url", "spin", "size", "color"])) : createCommentVNode("", true),
                  createElementVNode("span", {
                    textContent: toDisplayString(item.label)
                  }, null, 8, _hoisted_22)
                ]),
                _: 2
              }, 1032, ["tag", "class", "onClick"]);
            }), 256))
          ]))
        ], 64))
      ]),
      _: 3
    }, 8, ["modelValue", "placement", "z-index", "fixed", "fixed-auto", "offset", "timeout", "show-triangle", "animation", "shadow", "border", "width", "closable", "target", "root", "onShowing"])) : createCommentVNode("", true)
  ], 40, _hoisted_1$1);
}
const EditorMenu = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4], ["__scopeId", "data-v-9f3babac"]]);
EditorMenu.install = (app) => {
  app.component(EditorMenu.name, EditorMenu);
};
const row_vue_vue_type_style_index_0_scoped_3f4f3a9a_lang = "";
const _sfc_main$3 = {
  name: "m-row",
  props: {
    justify: {
      type: String,
      default: "flex-start",
      validator(value) {
        return ["flex-start", "flex-end", "space-around", "space-between"].includes(value);
      }
    },
    align: {
      type: String,
      default: "flex-start",
      validator(value) {
        return ["flex-start", "flex-end", "center"].includes(value);
      }
    },
    tag: {
      type: String,
      default: "div"
    }
  },
  provide() {
    return {
      row: this
    };
  },
  computed: {
    rowStyle() {
      let style = {};
      style.justifyContent = this.justify;
      style.alignItems = this.align;
      return style;
    }
  },
  components: {
    Row: {
      render() {
        return h(
          this.$parent.tag,
          {},
          {
            default: this.$slots.default
          }
        );
      }
    }
  }
};
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Row = resolveComponent("Row", true);
  return openBlock(), createBlock(_component_Row, {
    class: "mvi-row",
    style: normalizeStyle($options.rowStyle)
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ]),
    _: 3
  }, 8, ["style"]);
}
const Row = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3], ["__scopeId", "data-v-3f4f3a9a"]]);
Row.install = (app) => {
  app.component(Row.name, Row);
};
const col_vue_vue_type_style_index_0_scoped_7098c473_lang = "";
const _sfc_main$2 = {
  name: "m-col",
  props: {
    span: {
      type: Number,
      default: 24
    },
    offset: {
      type: Number,
      default: 0
    },
    tag: {
      type: String,
      default: "div"
    },
    xs: {
      type: [Number, Object],
      default: null
    },
    sm: {
      type: [Number, Object],
      default: null
    },
    md: {
      type: [Number, Object],
      default: null
    },
    lg: {
      type: [Number, Object],
      default: null
    },
    xl: {
      type: [Number, Object],
      default: null
    }
  },
  inject: ["row"],
  computed: {
    colStyle() {
      let cls = [];
      if (this.span) {
        cls.push("mvi-col-" + this.span);
      }
      if (this.offset) {
        cls.push("mvi-col-offset-" + this.offset);
      }
      if (obj$1.common.isObject(this.xs)) {
        if (obj$1.number.isNumber(this.xs.span)) {
          cls.push("mvi-col-xs-" + this.xs.span);
        }
        if (obj$1.number.isNumber(this.xs.offset)) {
          cls.push("mvi-col-offset-xs-" + this.xs.offset);
        }
      } else if (obj$1.number.isNumber(this.xs)) {
        cls.push("mvi-col-xs-" + this.xs);
      }
      if (obj$1.common.isObject(this.sm)) {
        if (obj$1.number.isNumber(this.sm.span)) {
          cls.push("mvi-col-sm-" + this.sm.span);
        }
        if (obj$1.number.isNumber(this.sm.offset)) {
          cls.push("mvi-col-offset-sm-" + this.sm.offset);
        }
      } else if (obj$1.number.isNumber(this.sm)) {
        cls.push("mvi-col-sm-" + this.sm);
      }
      if (obj$1.common.isObject(this.md)) {
        if (obj$1.number.isNumber(this.md.span)) {
          cls.push("mvi-col-md-" + this.md.span);
        }
        if (obj$1.number.isNumber(this.md.offset)) {
          cls.push("mvi-col-offset-md-" + this.md.offset);
        }
      } else if (obj$1.number.isNumber(this.md)) {
        cls.push("mvi-col-md-" + this.md);
      }
      if (obj$1.common.isObject(this.lg)) {
        if (obj$1.number.isNumber(this.lg.span)) {
          cls.push("mvi-col-lg-" + this.lg.span);
        }
        if (obj$1.number.isNumber(this.lg.offset)) {
          cls.push("mvi-col-offset-lg-" + this.lg.offset);
        }
      } else if (obj$1.number.isNumber(this.lg)) {
        cls.push("mvi-col-lg-" + this.lg);
      }
      if (obj$1.common.isObject(this.xl)) {
        if (obj$1.number.isNumber(this.xl.span)) {
          cls.push("mvi-col-xl-" + this.xl.span);
        }
        if (obj$1.number.isNumber(this.xl.offset)) {
          cls.push("mvi-col-offset-xl-" + this.xl.offset);
        }
      } else if (obj$1.number.isNumber(this.xl)) {
        cls.push("mvi-col-xl-" + this.xl);
      }
      return cls;
    }
  },
  components: {
    Col: {
      render() {
        return h(
          this.$parent.tag,
          {},
          {
            default: this.$slots.default
          }
        );
      }
    }
  }
};
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Col = resolveComponent("Col", true);
  return openBlock(), createBlock(_component_Col, {
    class: normalizeClass($options.colStyle)
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ]),
    _: 3
  }, 8, ["class"]);
}
const Col = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2], ["__scopeId", "data-v-7098c473"]]);
Col.install = (app) => {
  app.component(Col.name, Col);
};
const form_vue_vue_type_style_index_0_scoped_318b5f2d_lang = "";
const _sfc_main$1 = {
  name: "m-form",
  props: {
    width: {
      type: String,
      default: null
    },
    block: {
      type: Boolean,
      default: false
    },
    align: {
      type: String,
      default: "center"
    },
    labelBlock: {
      type: Boolean,
      default: false
    },
    labelWidth: {
      type: String,
      default: null
    },
    labelOffset: {
      type: String,
      default: null
    }
  },
  computed: {
    formStyle() {
      return {
        width: this.block && this.width ? this.width : ""
      };
    }
  },
  provide() {
    return {
      form: this
    };
  }
};
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["mvi-form", $props.block ? "block" : ""]),
    style: normalizeStyle($options.formStyle)
  }, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true)
  ], 6);
}
const Form = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1], ["__scopeId", "data-v-318b5f2d"]]);
Form.install = (app) => {
  app.component(Form.name, Form);
};
const formEl_vue_vue_type_style_index_0_scoped_5f7982ad_lang = "";
const _sfc_main = {
  name: "m-form-el",
  props: {
    align: {
      type: String,
      default: null
    },
    width: {
      type: String,
      default: null
    },
    label: {
      type: String,
      default: ""
    },
    labelWidth: {
      type: String,
      default: null
    },
    labelOffset: {
      type: String,
      default: null
    }
  },
  inject: ["form"],
  computed: {
    labelCls() {
      let cls = ["mvi-form-label"];
      if (this.form.labelBlock && this.form.block) {
        cls.push("block");
      }
      return cls;
    },
    labelStyle() {
      let style = {};
      if (!this.form.labelBlock) {
        if (this.labelWidth) {
          style.width = this.labelWidth;
        } else if (this.form.labelWidth) {
          style.width = this.form.labelWidth;
        }
      }
      if (this.labelOffset) {
        if (this.form.labelBlock) {
          style.marginBottom = this.labelOffset;
        } else {
          style.marginRight = this.labelOffset;
        }
      } else if (this.form.labelOffset) {
        if (this.form.labelBlock) {
          style.marginBottom = this.form.labelOffset;
        } else {
          style.marginRight = this.form.labelOffset;
        }
      }
      return style;
    },
    formElStyle() {
      let style = {};
      if (this.width) {
        style.width = this.width;
      }
      if (this.align) {
        style.alignItems = this.align;
      } else if (this.form.align) {
        style.alignItems = this.form.align;
      }
      return style;
    }
  }
};
const _hoisted_1 = ["textContent"];
const _hoisted_2 = {
  key: 1,
  class: "mvi-form-container"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["mvi-form-el", $options.form.block ? "block" : ""]),
    style: normalizeStyle($options.formElStyle)
  }, [
    $props.label ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass($options.labelCls),
      textContent: toDisplayString($props.label),
      style: normalizeStyle($options.labelStyle)
    }, null, 14, _hoisted_1)) : createCommentVNode("", true),
    _ctx.$slots.default ? (openBlock(), createElementBlock("div", _hoisted_2, [
      renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ])) : createCommentVNode("", true)
  ], 6);
}
const FormEl = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-5f7982ad"]]);
FormEl.install = (app) => {
  app.component(FormEl.name, FormEl);
};
const install = (app) => {
  const components = {
    Dap: obj$1,
    Anchor: Anchor$1,
    Resize: Resize$1,
    Drag: Drag$1,
    Prop: Prop$1,
    Scroll: Scroll$1,
    Spy: Spy$1,
    Observe: Observe$1,
    Upload: Upload$1,
    Px: Px$1,
    Ripple: Ripple$1,
    Button,
    Icon,
    Cell,
    CellGroup,
    Navbar,
    Tabbar,
    Image,
    Overlay,
    Popup,
    Checkbox,
    Radio,
    DatePicker,
    DateNativePicker,
    Input,
    Modal,
    Dialog,
    Toast,
    Loading,
    Msgbox,
    NumberKeyboard,
    Search,
    Progress,
    Slider,
    Stepper,
    Switch,
    Actionsheet,
    Dropdown,
    Notify,
    PullRefresh,
    SwipeCell,
    CircleProgress,
    Collapse,
    CollapseItem,
    Divider,
    Roll,
    Steps,
    Step,
    Label,
    Swiper,
    SwiperSlide,
    Tabs,
    Tab,
    Badge,
    Table,
    Calendar,
    Triangle,
    Tooltip,
    ColorPicker,
    ImagePreview,
    Page,
    LoadingBar,
    Picker,
    TransitionSlide,
    List,
    Skeleton,
    Sign,
    Layer,
    Select,
    Autocomplete,
    DateChooser,
    Field,
    Editor,
    EditorMenus,
    EditorMenu,
    Row,
    Col,
    Form,
    FormEl
  };
  Object.values(components).map((component) => {
    component.install(app);
  });
};
const version = "1.7.1";
const stdin_default = {
  install,
  version
};
export {
  Actionsheet,
  AlexElement,
  Anchor$1 as Anchor,
  Autocomplete,
  Badge,
  Button,
  Calendar,
  Cell,
  CellGroup,
  Checkbox,
  CircleProgress,
  Col,
  Collapse,
  CollapseItem,
  ColorPicker,
  obj$1 as Dap,
  DateChooser,
  DateNativePicker,
  DatePicker,
  Dialog,
  Divider,
  Drag$1 as Drag,
  Dropdown,
  Editor,
  definedMenus as EditorDefinedMenuConfig,
  EditorMenu,
  EditorMenus,
  Field,
  Form,
  FormEl,
  Icon,
  Image,
  ImagePreview,
  Input,
  Label,
  Layer,
  List,
  Loading,
  LoadingBar,
  Modal,
  Msgbox,
  Navbar,
  Notify,
  NumberKeyboard,
  Observe$1 as Observe,
  Overlay,
  Page,
  Picker,
  Popup,
  Progress,
  Prop$1 as Prop,
  PullRefresh,
  Px$1 as Px,
  Radio,
  Resize$1 as Resize,
  Ripple$1 as Ripple,
  Roll,
  Row,
  Scroll$1 as Scroll,
  Search,
  Select,
  Sign,
  Skeleton,
  Slider,
  Spy$1 as Spy,
  Step,
  Stepper,
  Steps,
  SwipeCell,
  Swiper,
  SwiperSlide,
  Switch,
  Tab,
  Tabbar,
  Table,
  Tabs,
  Toast,
  Tooltip,
  TransitionSlide,
  Triangle,
  Upload$1 as Upload,
  stdin_default as default,
  install,
  version
};
